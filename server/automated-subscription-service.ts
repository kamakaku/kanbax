/**
 * automated-subscription-service.ts
 * Ein vereinfachter Service f√ºr vollautomatische Subscription-Updates
 * ohne Abh√§ngigkeiten von anderen Diensten
 */

import { eq, sql, and } from 'drizzle-orm';
import { db } from './db';
import { 
  users, 
  subscriptions, 
  subscriptionPackages, 
  companyPaymentInfo
} from '@shared/schema';

/**
 * F√ºhrt ein garantiertes Update des Benutzerabonnements durch.
 * Diese Funktion umgeht alle anderen Services und f√ºhrt ein direktes Update in der Datenbank durch.
 * 
 * @param userId - Benutzer-ID, die aktualisiert werden soll
 * @param tierName - Name des neuen Abonnementpakets (z.B. 'freelancer', 'organisation')
 * @param billingCycle - Abrechnungszyklus ('monthly' oder 'yearly')
 * @returns Promise mit Erfolg-Status und Informationen
 */
export async function guaranteedSubscriptionUpdate(
  userId: number, 
  tierName: string, 
  billingCycle: string
): Promise<{ success: boolean; message: string; data?: any; error?: any }> {
  // Normalisieren des Billing-Zyklus f√ºr die Protokollierung
  const logBillingCycle = billingCycle === 'yearly' ? 'yearly' : 'monthly';
  console.log(`üîÑ [AUTOMATED-UPDATE] Garantiertes Update f√ºr Benutzer ${userId}, Tier ${tierName}, Zyklus ${logBillingCycle}`);
  
  // Explizite Debug-Ausgabe zur Verfolgung des billingCycle-Parameters
  console.log(`‚öôÔ∏è [AUTOMATED-UPDATE] Erhaltener billingCycle=${billingCycle}, Typ=${typeof billingCycle}`);
  
  try {
    // 1. Pr√ºfen, ob der Benutzer existiert
    const user = await db.query.users.findFirst({
      where: eq(users.id, userId)
    });
    
    if (!user) {
      return { success: false, message: "Benutzer nicht gefunden", error: "USER_NOT_FOUND" };
    }
    
    console.log(`üë§ [AUTOMATED-UPDATE] Benutzer gefunden: ${user.email}`);
    
    // 2. Pr√ºfen, ob das Paket existiert
    const packageInfo = await db.query.subscriptionPackages.findFirst({
      where: eq(subscriptionPackages.name, tierName.toLowerCase())
    });
    
    if (!packageInfo) {
      return { success: false, message: "Paket nicht gefunden", error: "PACKAGE_NOT_FOUND" };
    }
    
    const packageId = packageInfo.id;
    console.log(`üì¶ [AUTOMATED-UPDATE] Paket gefunden: ${packageInfo.name} (ID: ${packageId})`);
    
    // 3. Billingzyklus normalisieren und sicherstellen, dass er korrekt ist
    const normalizedBillingCycle = (billingCycle && billingCycle.toLowerCase() === 'yearly') ? 'yearly' : 'monthly';
    console.log(`üîÑ [AUTOMATED-UPDATE] Normalisierter Billing-Zyklus: ${normalizedBillingCycle} (Original: ${billingCycle})`);
    
    // 4. Laufzeit des Abonnements berechnen
    const expirationPeriod = normalizedBillingCycle === 'yearly'
      ? 365 * 24 * 60 * 60 * 1000  // 1 Jahr in Millisekunden
      : 30 * 24 * 60 * 60 * 1000;  // 30 Tage in Millisekunden
      
    console.log(`‚è±Ô∏è [AUTOMATED-UPDATE] Expiration basierend auf Zyklus ${normalizedBillingCycle} berechnet: ${expirationPeriod}ms`);
    
    // Ablaufdatum bestimmen (null f√ºr Free-Tier)
    const expirationDate = tierName.toLowerCase() === 'free'
      ? null
      : new Date(Date.now() + expirationPeriod);
    
    console.log(`üìÖ [AUTOMATED-UPDATE] Ablaufdatum berechnet: ${expirationDate}`);
    
    // 5. Benutzer in der Datenbank aktualisieren
    const userUpdateResult = await db.update(users)
      .set({
        subscriptionTier: tierName.toLowerCase(),
        subscriptionBillingCycle: normalizedBillingCycle,
        subscriptionExpiresAt: expirationDate,
        updatedAt: new Date()
      })
      .where(eq(users.id, userId))
      .returning();
    
    console.log(`‚úÖ [AUTOMATED-UPDATE] Benutzer aktualisiert:`, userUpdateResult);
    
    // 6. Subscription-Eintrag erstellen oder aktualisieren
    const existingSubscription = await db.query.subscriptions.findFirst({
      where: eq(subscriptions.userId, userId)
    });
    
    let subscriptionUpdateResult;
    
    if (existingSubscription) {
      // Vorhandenes Abonnement aktualisieren
      subscriptionUpdateResult = await db.update(subscriptions)
        .set({
          packageId,
          status: "active",
          billingCycle: normalizedBillingCycle,
          updatedAt: new Date()
        })
        .where(eq(subscriptions.id, existingSubscription.id))
        .returning();
      
      console.log(`‚úÖ [AUTOMATED-UPDATE] Vorhandenes Abonnement aktualisiert:`, subscriptionUpdateResult);
    } else {
      // Neues Abonnement erstellen
      subscriptionUpdateResult = await db.insert(subscriptions)
        .values({
          userId,
          packageId,
          status: "active",
          billingCycle: normalizedBillingCycle,
          createdAt: new Date(),
          updatedAt: new Date()
        })
        .returning();
      
      console.log(`‚úÖ [AUTOMATED-UPDATE] Neues Abonnement erstellt:`, subscriptionUpdateResult);
    }
    
    // 7. Wenn der Benutzer zu einer Firma geh√∂rt und Firmenadmin ist, aktualisiere die Firma
    if (user.companyId && user.isCompanyAdmin) {
      try {
        console.log(`üè¢ [AUTOMATED-UPDATE] Benutzer ist Admin der Firma ${user.companyId}, aktualisiere Firmen-Abonnement`);
        
        // Firmen-Abonnement aktualisieren
        await db.update(companyPaymentInfo)
          .set({
            subscriptionTier: tierName.toLowerCase(),
            subscriptionStatus: "active",
            subscriptionStartDate: new Date(),
            subscriptionEndDate: expirationDate,
            billingCycle: normalizedBillingCycle,
            updatedAt: new Date()
          })
          .where(eq(companyPaymentInfo.companyId, user.companyId));
        
        console.log(`‚úÖ [AUTOMATED-UPDATE] Firmen-Abonnement aktualisiert f√ºr Firma ${user.companyId}`);
      } catch (companyError) {
        console.error(`‚ùå [AUTOMATED-UPDATE] Fehler beim Aktualisieren des Firmen-Abonnements:`, companyError);
        // Wir brechen hier nicht ab, da die Hauptaktion (Benutzerupdate) bereits abgeschlossen ist
      }
    }
    
    return {
      success: true,
      message: "Abonnement erfolgreich aktualisiert",
      data: {
        user: userUpdateResult[0],
        subscription: subscriptionUpdateResult[0]
      }
    };
  } catch (error) {
    console.error(`‚ùå [AUTOMATED-UPDATE] Fehler bei garantiertem Update:`, error);
    return {
      success: false,
      message: "Fehler beim Aktualisieren des Abonnements",
      error
    };
  }
}

/**
 * Die vereinfachte Tier-Rang-Funktion f√ºr einfachen Vergleich
 */
export function getTierRank(tier: string): number {
  switch (tier.toLowerCase()) {
    case 'free': return 0;
    case 'freelancer': return 1;
    case 'organisation': return 2;
    case 'enterprise': return 3;
    case 'kanbax': return 4;
    default: return -1;
  }
}