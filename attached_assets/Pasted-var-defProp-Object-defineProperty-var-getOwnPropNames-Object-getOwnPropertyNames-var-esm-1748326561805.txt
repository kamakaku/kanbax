var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  activityLogs: () => activityLogs,
  boardMembers: () => boardMembers2,
  boards: () => boards,
  checklistItems: () => checklistItems,
  columns: () => columns,
  comments: () => comments,
  companies: () => companies,
  companyPaymentInfo: () => companyPaymentInfo,
  insertActivityLogSchema: () => insertActivityLogSchema,
  insertBoardMemberSchema: () => insertBoardMemberSchema,
  insertBoardSchema: () => insertBoardSchema,
  insertChecklistItemSchema: () => insertChecklistItemSchema,
  insertColumnSchema: () => insertColumnSchema,
  insertCommentSchema: () => insertCommentSchema,
  insertCompanyPaymentInfoSchema: () => insertCompanyPaymentInfoSchema,
  insertCompanySchema: () => insertCompanySchema,
  insertKeyResultSchema: () => insertKeyResultSchema,
  insertMeetingProtocolSchema: () => insertMeetingProtocolSchema,
  insertNotificationSchema: () => insertNotificationSchema,
  insertNotificationSettingsSchema: () => insertNotificationSettingsSchema,
  insertObjectiveMemberSchema: () => insertObjectiveMemberSchema,
  insertObjectiveSchema: () => insertObjectiveSchema,
  insertOkrCommentSchema: () => insertOkrCommentSchema,
  insertOkrCycleSchema: () => insertOkrCycleSchema,
  insertPaymentSchema: () => insertPaymentSchema,
  insertProjectSchema: () => insertProjectSchema,
  insertProjectTeamSchema: () => insertProjectTeamSchema,
  insertSubscriptionPackageSchema: () => insertSubscriptionPackageSchema,
  insertSubscriptionSchema: () => insertSubscriptionSchema,
  insertTaskSchema: () => insertTaskSchema,
  insertTaskStateChangeSchema: () => insertTaskStateChangeSchema,
  insertTaskTimeEntrySchema: () => insertTaskTimeEntrySchema,
  insertTeamMemberSchema: () => insertTeamMemberSchema,
  insertTeamSchema: () => insertTeamSchema,
  insertUserProductivityMetricsSchema: () => insertUserProductivityMetricsSchema,
  insertUserSchema: () => insertUserSchema,
  keyResults: () => keyResults,
  meetingProtocols: () => meetingProtocols,
  notificationSettings: () => notificationSettings,
  notifications: () => notifications,
  objectiveMembers: () => objectiveMembers,
  objectives: () => objectives,
  okrComments: () => okrComments,
  okrCycles: () => okrCycles,
  payments: () => payments,
  projectTeams: () => projectTeams,
  projects: () => projects,
  subscriptionAuditLogs: () => subscriptionAuditLogs,
  subscriptionPackages: () => subscriptionPackages,
  subscriptions: () => subscriptions,
  taskStateChanges: () => taskStateChanges,
  taskTimeEntries: () => taskTimeEntries,
  tasks: () => tasks,
  teamMembers: () => teamMembers,
  teams: () => teams,
  updateBoardSchema: () => updateBoardSchema,
  updateProjectSchema: () => updateProjectSchema,
  updateTaskSchema: () => updateTaskSchema,
  userFavoriteBoards: () => userFavoriteBoards,
  userFavoriteObjectives: () => userFavoriteObjectives,
  userFavoriteProjects: () => userFavoriteProjects,
  userProductivityMetrics: () => userProductivityMetrics,
  users: () => users
});
import { pgTable, text, serial, integer, timestamp, boolean, primaryKey, jsonb, real } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
var companies, users, teams, teamMembers, projects, boards, columns, tasks, checklistItems, comments, activityLogs, checklistItemSchema, insertUserSchema, insertProjectSchema, updateProjectSchema, insertBoardSchema, insertColumnSchema, insertTaskSchema, insertChecklistItemSchema, insertCommentSchema, insertActivityLogSchema, insertTeamSchema, insertTeamMemberSchema, okrCycles, insertOkrCycleSchema, objectives, keyResults, insertKeyResultSchema, okrComments, insertOkrCommentSchema, insertObjectiveSchema, insertCompanySchema, updateTaskSchema, updateBoardSchema, boardMembers2, insertBoardMemberSchema, objectiveMembers, insertObjectiveMemberSchema, userProductivityMetrics, taskTimeEntries, taskStateChanges, insertUserProductivityMetricsSchema, insertTaskTimeEntrySchema, insertTaskStateChangeSchema, projectTeams, insertProjectTeamSchema, notifications, notificationSettings, insertNotificationSchema, insertNotificationSettingsSchema, userFavoriteProjects, userFavoriteBoards, userFavoriteObjectives, meetingProtocols, insertMeetingProtocolSchema, subscriptionPackages, insertSubscriptionPackageSchema, subscriptions, insertSubscriptionSchema, payments, insertPaymentSchema, companyPaymentInfo, insertCompanyPaymentInfoSchema, subscriptionAuditLogs;
var init_schema = __esm({
  "shared/schema.ts"() {
    "use strict";
    companies = pgTable("companies", {
      id: serial("id").primaryKey(),
      name: text("name").notNull(),
      description: text("description"),
      inviteCode: text("invite_code").notNull().unique(),
      // Einladungscode für das Unternehmen
      isPaused: boolean("is_paused").default(false).notNull(),
      // Ob das Unternehmen pausiert ist
      pauseReason: text("pause_reason"),
      // Begründung für die Pausierung
      pausedAt: timestamp("paused_at"),
      // Zeitpunkt der Pausierung
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    users = pgTable("users", {
      id: serial("id").primaryKey(),
      username: text("username").notNull().unique(),
      email: text("email").notNull().unique(),
      passwordHash: text("password_hash").notNull(),
      avatarUrl: text("avatar_url"),
      companyId: integer("company_id").references(() => companies.id),
      isCompanyAdmin: boolean("is_company_admin").default(false),
      isHyperAdmin: boolean("is_hyper_admin").default(false),
      // Hyper-Admin für die gesamte SaaS-Plattform
      isActive: boolean("is_active").default(false),
      // Benutzer muss von einem Admin aktiviert werden
      isPaused: boolean("is_paused").default(false).notNull(),
      // Ob der Benutzer pausiert ist
      pauseReason: text("pause_reason"),
      // Begründung für die Pausierung
      pausedAt: timestamp("paused_at"),
      // Zeitpunkt der Pausierung
      lastLoginAt: timestamp("last_login_at"),
      subscriptionTier: text("subscription_tier").default("free"),
      // free, basic, premium, enterprise
      subscriptionBillingCycle: text("subscription_billing_cycle").default("monthly"),
      // monthly, yearly
      subscriptionExpiresAt: timestamp("subscription_expires_at"),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    teams = pgTable("teams", {
      id: serial("id").primaryKey(),
      name: text("name").notNull(),
      description: text("description"),
      companyId: integer("company_id").notNull().references(() => companies.id),
      creatorId: integer("creator_id").notNull(),
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    teamMembers = pgTable("team_members", {
      id: serial("id").primaryKey(),
      teamId: integer("team_id").notNull(),
      userId: integer("user_id").notNull(),
      role: text("role").notNull().default("member"),
      // 'member' or 'admin'
      joinedAt: timestamp("joined_at").defaultNow().notNull()
    });
    projects = pgTable("projects", {
      id: serial("id").primaryKey(),
      title: text("title").notNull(),
      description: text("description"),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      teamIds: integer("team_ids").array().default([]),
      memberIds: integer("member_ids").array().default([]),
      isFavorite: boolean("is_favorite").default(false),
      archived: boolean("archived").default(false),
      companyId: integer("company_id").references(() => companies.id),
      creator_id: integer("creator_id").notNull().default(1)
      // Default für existierende Einträge
    });
    boards = pgTable("boards", {
      id: serial("id").primaryKey(),
      title: text("title").notNull(),
      description: text("description"),
      richDescription: text("rich_description"),
      // Rich text description
      project_id: integer("project_id"),
      creator_id: integer("creator_id").notNull(),
      team_ids: integer("team_ids").array().default([]).notNull(),
      assigned_user_ids: integer("assigned_user_ids").array().default([]).notNull(),
      is_favorite: boolean("is_favorite").default(false),
      archived: boolean("archived").default(false),
      attachments: text("attachments").array()
      // Array of file paths/urls
    });
    columns = pgTable("columns", {
      id: serial("id").primaryKey(),
      title: text("title").notNull(),
      boardId: integer("board_id").notNull(),
      order: integer("order").notNull()
    });
    tasks = pgTable("tasks", {
      id: serial("id").primaryKey(),
      title: text("title").notNull(),
      description: text("description"),
      richDescription: text("rich_description"),
      // Rich text description
      status: text("status").notNull(),
      order: integer("order").notNull(),
      boardId: integer("board_id").notNull(),
      // Bleibt .notNull() für Kompatibilität mit bestehenden Daten
      columnId: integer("column_id"),
      priority: text("priority").notNull().default("medium"),
      labels: text("labels").array(),
      startDate: text("start_date"),
      // Store as ISO string for start date
      dueDate: text("due_date"),
      // Store as ISO string for due date
      archived: boolean("archived").default(false),
      assignedUserIds: integer("assigned_user_ids").array(),
      assignedTeamId: integer("assigned_team_id"),
      assignedAt: timestamp("assigned_at"),
      checklist: text("checklist").array(),
      // Keep as text array, but store stringified objects
      attachments: text("attachments").array()
      // Array of file paths/urls
      // Wir kommentieren die company_id aus, da die Migration noch nicht durchgeführt wurde
      // company_id: integer("company_id").references(() => companies.id), // Referenz zum Unternehmen
    });
    checklistItems = pgTable("checklist_items", {
      id: serial("id").primaryKey(),
      taskId: integer("task_id").notNull(),
      title: text("title").notNull(),
      completed: boolean("completed").default(false),
      itemOrder: integer("item_order").notNull()
    });
    comments = pgTable("comments", {
      id: serial("id").primaryKey(),
      content: text("content").notNull(),
      rawContent: text("raw_content").notNull(),
      // Store raw content for the editor
      taskId: integer("task_id").notNull(),
      authorId: integer("author_id").notNull(),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    activityLogs = pgTable("activity_logs", {
      id: serial("id").primaryKey(),
      action: text("action").notNull(),
      // 'create', 'update', 'delete', 'assign', 'mention', 'comment', 'approval'
      details: text("details"),
      userId: integer("user_id").references(() => users.id),
      boardId: integer("board_id").references(() => boards.id),
      projectId: integer("project_id").references(() => projects.id),
      objectiveId: integer("objective_id").references(() => objectives.id),
      taskId: integer("task_id").references(() => tasks.id),
      commentId: integer("comment_id").references(() => comments.id),
      teamId: integer("team_id").references(() => teams.id),
      targetUserId: integer("target_user_id").references(() => users.id),
      // Empfänger der Aktivität
      createdAt: timestamp("created_at").defaultNow().notNull(),
      // Sichtbarkeitskontrolle
      visibleToTeams: integer("visible_to_teams").array(),
      visibleToUsers: integer("visible_to_users").array(),
      requiresNotification: boolean("requires_notification").default(false),
      notificationSent: boolean("notification_sent").default(false),
      notificationType: text("notification_type")
      // Spezifischer Benachrichtigungstyp
    });
    checklistItemSchema = z.object({
      text: z.string().min(1, "Text is required"),
      checked: z.boolean().default(false)
    });
    insertUserSchema = createInsertSchema(users).pick({
      username: true,
      email: true,
      passwordHash: true,
      companyId: true,
      isActive: true
    }).extend({
      username: z.string().min(3, "Benutzername muss mindestens 3 Zeichen lang sein"),
      email: z.string().email("Ung\xFCltige E-Mail-Adresse"),
      password: z.string().min(8, "Passwort muss mindestens 8 Zeichen lang sein"),
      inviteCode: z.union([
        z.string().min(6, "Einladungscode muss mindestens 6 Zeichen lang sein"),
        z.string().length(0),
        z.undefined(),
        z.null()
      ]).optional(),
      isActive: z.boolean().default(false)
    }).omit({ passwordHash: true, companyId: true });
    insertProjectSchema = createInsertSchema(projects).pick({
      title: true,
      description: true,
      companyId: true,
      creator_id: true,
      archived: true
    }).extend({
      title: z.string().min(1, "Titel ist erforderlich"),
      description: z.string().optional(),
      companyId: z.union([
        z.number().int().positive("Unternehmens-ID muss eine positive Zahl sein"),
        z.null()
      ]).optional(),
      // Erlaubt null für companyId
      teamIds: z.array(z.number().int().positive()).optional(),
      memberIds: z.array(z.number().int().positive()).optional(),
      creator_id: z.number().int().positive("Creator ID ist erforderlich"),
      archived: z.boolean().default(false)
    });
    updateProjectSchema = insertProjectSchema.partial();
    insertBoardSchema = createInsertSchema(boards).pick({
      title: true,
      description: true,
      project_id: true,
      creator_id: true,
      team_ids: true,
      assigned_user_ids: true,
      is_favorite: true,
      archived: true
    }).extend({
      title: z.string().min(1, "Titel ist erforderlich"),
      description: z.string().nullable().optional(),
      project_id: z.number().int().positive("Projekt ID muss positiv sein").nullable().optional(),
      creator_id: z.number().int().positive("Creator ID ist erforderlich").default(0),
      team_ids: z.preprocess(
        (val) => (Array.isArray(val) ? val : []).filter(Boolean).map(Number),
        z.array(z.number().int().positive("Team ID muss eine positive Zahl sein"))
      ).default([]),
      assigned_user_ids: z.preprocess(
        (val) => (Array.isArray(val) ? val : []).filter(Boolean).map(Number),
        z.array(z.number().int().positive("Benutzer ID muss eine positive Zahl sein"))
      ).default([]),
      is_favorite: z.boolean().default(false),
      archived: z.boolean().default(false)
    });
    insertColumnSchema = createInsertSchema(columns).pick({
      title: true,
      boardId: true,
      order: true
    }).extend({
      title: z.string().min(1, "Title is required"),
      boardId: z.number().int().positive("Board ID is required")
    });
    insertTaskSchema = createInsertSchema(tasks).pick({
      title: true,
      description: true,
      richDescription: true,
      status: true,
      order: true,
      boardId: true,
      columnId: true,
      priority: true,
      labels: true,
      startDate: true,
      dueDate: true,
      archived: true,
      assignedUserIds: true,
      assignedTeamId: true,
      checklist: true,
      attachments: true
    }).extend({
      title: z.string().min(1, "Title is required"),
      status: z.enum(["backlog", "todo", "in-progress", "review", "done"]),
      // Erlaubt null, undefined oder positive Zahlen für persönliche Aufgaben
      boardId: z.union([
        z.number().int().positive("Board ID must be a positive integer if provided"),
        z.null(),
        z.undefined()
      ]).optional(),
      // Erlaubt null, undefined oder positive Zahlen für persönliche Aufgaben
      columnId: z.union([
        z.number().int().positive("Column ID must be a positive integer if provided"),
        z.null(),
        z.undefined()
      ]).optional(),
      priority: z.enum(["low", "medium", "high"]).default("medium"),
      labels: z.array(z.string()).default([]),
      startDate: z.string().nullable().optional(),
      // Accept ISO string or null for start date
      dueDate: z.string().nullable().optional(),
      // Accept ISO string or null for due date
      checklist: z.array(z.string()).default([]),
      // Accept stringified objects
      archived: z.boolean().default(false),
      assignedUserIds: z.array(z.number().int().positive()).default([]),
      assignedTeamId: z.union([
        z.number().int().positive("Team ID must be positive if provided"),
        z.null()
      ]).optional().nullable(),
      // Dateianlagen
      attachments: z.array(z.string()).optional().nullable()
    });
    insertChecklistItemSchema = createInsertSchema(checklistItems).pick({
      taskId: true,
      title: true,
      completed: true,
      itemOrder: true
    }).extend({
      taskId: z.number().int().positive("Task ID is required"),
      title: z.string().min(1, "Title is required"),
      completed: z.boolean().default(false)
    });
    insertCommentSchema = createInsertSchema(comments).pick({
      content: true,
      rawContent: true,
      taskId: true,
      authorId: true
    }).extend({
      content: z.string().min(1, "Comment cannot be empty"),
      rawContent: z.string().min(1, "Raw content cannot be empty"),
      taskId: z.number().int().positive("Task ID is required"),
      authorId: z.number().int().positive("Author ID is required")
    });
    insertActivityLogSchema = createInsertSchema(activityLogs).pick({
      action: true,
      details: true,
      userId: true,
      boardId: true,
      projectId: true,
      objectiveId: true,
      taskId: true,
      commentId: true,
      teamId: true,
      targetUserId: true,
      visibleToTeams: true,
      visibleToUsers: true,
      requiresNotification: true,
      notificationSent: true,
      notificationType: true
    }).extend({
      action: z.enum(["create", "update", "delete", "assign", "mention", "comment", "approval"]),
      details: z.string().optional(),
      userId: z.number().int().positive().optional(),
      boardId: z.number().int().positive().optional(),
      projectId: z.number().int().positive().optional(),
      objectiveId: z.number().int().positive().optional(),
      taskId: z.number().int().positive().optional(),
      commentId: z.number().int().positive().optional(),
      teamId: z.number().int().positive().optional(),
      targetUserId: z.number().int().positive().optional(),
      visibleToTeams: z.array(z.number().int().positive()).optional(),
      visibleToUsers: z.array(z.number().int().positive()).optional(),
      requiresNotification: z.boolean().default(false),
      notificationSent: z.boolean().default(false),
      notificationType: z.enum(["task", "board", "project", "team", "okr", "approval", "mention", "assignment"]).optional()
    });
    insertTeamSchema = createInsertSchema(teams).pick({
      name: true,
      description: true,
      companyId: true,
      creatorId: true
    }).extend({
      name: z.string().min(1, "Team name is required"),
      description: z.string().optional(),
      companyId: z.number().int().positive("Company ID ist erforderlich"),
      creatorId: z.number().int().positive("Creator ID ist erforderlich"),
      member_ids: z.array(z.string()).optional()
      // Changed from memberIds to member_ids
    });
    insertTeamMemberSchema = createInsertSchema(teamMembers).pick({
      teamId: true,
      userId: true,
      role: true
    }).extend({
      role: z.enum(["member", "admin"]).default("member")
    });
    okrCycles = pgTable("okr_cycles", {
      id: serial("id").primaryKey(),
      title: text("title").notNull(),
      startDate: timestamp("start_date").notNull(),
      endDate: timestamp("end_date").notNull(),
      status: text("status").notNull().default("active"),
      // active, completed, archived
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    insertOkrCycleSchema = createInsertSchema(okrCycles).pick({
      title: true,
      startDate: true,
      endDate: true,
      status: true
    }).extend({
      title: z.string().min(1, "Titel ist erforderlich"),
      startDate: z.string().min(1, "Startdatum ist erforderlich"),
      endDate: z.string().min(1, "Enddatum ist erforderlich"),
      status: z.enum(["active", "completed", "archived"]).default("active")
    });
    objectives = pgTable("objectives", {
      id: serial("id").primaryKey(),
      title: text("title").notNull(),
      description: text("description"),
      richDescription: text("rich_description"),
      // Rich text description
      status: text("status").notNull().default("active"),
      isFavorite: boolean("is_favorite").default(false),
      progress: integer("progress").default(0),
      // Optional associations
      projectId: integer("project_id"),
      cycleId: integer("cycle_id"),
      teamId: integer("team_id"),
      userId: integer("user_id"),
      userIds: integer("user_ids").array(),
      creatorId: integer("creator_id").notNull(),
      // Add creatorId field
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull(),
      attachments: text("attachments").array()
      // Array of file paths/urls
    });
    keyResults = pgTable("key_results", {
      id: serial("id").primaryKey(),
      title: text("title").notNull(),
      description: text("description"),
      richDescription: text("rich_description"),
      // Rich text description
      objectiveId: integer("objective_id").notNull(),
      type: text("type").notNull(),
      // percentage, checkbox, progress, checklist
      targetValue: integer("target_value").notNull(),
      currentValue: integer("current_value").default(0),
      progress: integer("progress").default(0),
      linkedTaskIds: integer("linked_task_ids").array(),
      status: text("status").notNull().default("active"),
      // active, completed, archived
      checklistItems: text("checklist_items").array(),
      // Store JSON stringified checklist items
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull(),
      attachments: text("attachments").array()
      // Array of file paths/urls
    });
    insertKeyResultSchema = createInsertSchema(keyResults).pick({
      title: true,
      description: true,
      objectiveId: true,
      type: true,
      targetValue: true,
      currentValue: true,
      linkedTaskIds: true,
      status: true,
      checklistItems: true
    }).extend({
      title: z.string().min(1, "Titel ist erforderlich"),
      objectiveId: z.number().int().positive("Objective ID ist erforderlich"),
      type: z.enum(["percentage", "checkbox", "progress", "checklist"]),
      targetValue: z.number().min(0),
      currentValue: z.number().min(0).optional(),
      linkedTaskIds: z.array(z.number()).optional(),
      status: z.enum(["active", "completed", "archived"]).default("active"),
      checklistItems: z.array(z.object({
        title: z.string(),
        completed: z.boolean().default(false)
      })).optional()
    });
    okrComments = pgTable("okr_comments", {
      id: serial("id").primaryKey(),
      content: text("content").notNull(),
      richContent: text("rich_content"),
      // Rich text content
      authorId: integer("author_id").notNull(),
      objectiveId: integer("objective_id"),
      keyResultId: integer("key_result_id"),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      attachments: text("attachments").array()
      // Array of file paths/urls
    });
    insertOkrCommentSchema = createInsertSchema(okrComments).pick({
      content: true,
      authorId: true,
      objectiveId: true,
      keyResultId: true
    }).extend({
      content: z.string().min(1, "Comment content is required"),
      authorId: z.number().int().positive("Author ID is required"),
      objectiveId: z.number().int().positive().optional(),
      keyResultId: z.number().int().positive().optional()
    });
    insertObjectiveSchema = createInsertSchema(objectives).pick({
      title: true,
      description: true,
      projectId: true,
      cycleId: true,
      teamId: true,
      userId: true,
      userIds: true,
      status: true,
      creatorId: true
    }).extend({
      title: z.string().min(1, "Titel ist erforderlich"),
      projectId: z.number().int().positive().optional(),
      cycleId: z.number().int().positive().optional(),
      teamId: z.number().int().positive().optional(),
      userId: z.number().int().positive().optional(),
      userIds: z.array(z.number().int().positive()).optional(),
      status: z.enum(["active", "completed", "archived"]).default("active"),
      creatorId: z.number().int().positive("Creator ID ist erforderlich")
    });
    insertCompanySchema = createInsertSchema(companies).pick({
      name: true,
      description: true,
      inviteCode: true
    }).extend({
      name: z.string().min(1, "Unternehmensname ist erforderlich"),
      inviteCode: z.string().min(6, "Einladungscode muss mindestens 6 Zeichen haben"),
      description: z.string().optional()
    });
    updateTaskSchema = insertTaskSchema.partial();
    updateBoardSchema = createInsertSchema(boards).pick({
      title: true,
      description: true,
      project_id: true,
      team_ids: true,
      assigned_user_ids: true,
      is_favorite: true,
      archived: true
    }).extend({
      title: z.string().optional(),
      description: z.string().nullable().optional(),
      project_id: z.number().int().positive().nullable().optional(),
      team_ids: z.array(z.number().int()).default([]),
      assigned_user_ids: z.array(z.number().int()).default([]),
      is_favorite: z.boolean().optional(),
      archived: z.boolean().optional()
    });
    boardMembers2 = pgTable("board_members", {
      id: serial("id").primaryKey(),
      boardId: integer("board_id").notNull().references(() => boards.id),
      userId: integer("user_id").notNull().references(() => users.id),
      role: text("role").notNull().default("member"),
      // 'member', 'admin', or 'guest'
      invitedAt: timestamp("invited_at").defaultNow().notNull(),
      acceptedAt: timestamp("accepted_at")
    });
    insertBoardMemberSchema = createInsertSchema(boardMembers2).pick({
      boardId: true,
      userId: true,
      role: true
    }).extend({
      role: z.enum(["member", "admin", "guest"]).default("member")
    });
    objectiveMembers = pgTable("objective_members", {
      id: serial("id").primaryKey(),
      objectiveId: integer("objective_id").notNull().references(() => objectives.id),
      userId: integer("user_id").notNull().references(() => users.id),
      role: text("role").notNull().default("member"),
      // 'member', 'admin', 'guest'
      invitedAt: timestamp("invited_at").defaultNow().notNull(),
      acceptedAt: timestamp("accepted_at")
    });
    insertObjectiveMemberSchema = createInsertSchema(objectiveMembers).pick({
      objectiveId: true,
      userId: true,
      role: true
    }).extend({
      role: z.enum(["member", "admin", "guest"]).default("member")
    });
    userProductivityMetrics = pgTable("user_productivity_metrics", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull(),
      date: timestamp("date").notNull(),
      tasksCompleted: integer("tasks_completed").default(0),
      tasksCreated: integer("tasks_created").default(0),
      timeSpentMinutes: integer("time_spent_minutes").default(0),
      objectivesAchieved: integer("objectives_achieved").default(0),
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    taskTimeEntries = pgTable("task_time_entries", {
      id: serial("id").primaryKey(),
      taskId: integer("task_id").notNull(),
      userId: integer("user_id").notNull(),
      startTime: timestamp("start_time").notNull(),
      endTime: timestamp("end_time"),
      durationMinutes: integer("duration_minutes"),
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    taskStateChanges = pgTable("task_state_changes", {
      id: serial("id").primaryKey(),
      taskId: integer("task_id").notNull(),
      userId: integer("user_id").notNull(),
      fromState: text("from_state").notNull(),
      toState: text("to_state").notNull(),
      changedAt: timestamp("changed_at").defaultNow().notNull()
    });
    insertUserProductivityMetricsSchema = createInsertSchema(userProductivityMetrics).pick({
      userId: true,
      date: true,
      tasksCompleted: true,
      tasksCreated: true,
      timeSpentMinutes: true,
      objectivesAchieved: true
    }).extend({
      userId: z.number().int().positive("User ID is required"),
      date: z.string().min(1, "Date is required")
    });
    insertTaskTimeEntrySchema = createInsertSchema(taskTimeEntries).pick({
      taskId: true,
      userId: true,
      startTime: true,
      endTime: true,
      durationMinutes: true
    }).extend({
      taskId: z.number().int().positive("Task ID is required"),
      userId: z.number().int().positive("User ID is required"),
      startTime: z.string().min(1, "Start time is required")
    });
    insertTaskStateChangeSchema = createInsertSchema(taskStateChanges).pick({
      taskId: true,
      userId: true,
      fromState: true,
      toState: true
    }).extend({
      taskId: z.number().int().positive("Task ID is required"),
      userId: z.number().int().positive("User ID is required"),
      fromState: z.string().min(1, "Previous state is required"),
      toState: z.string().min(1, "New state is required")
    });
    projectTeams = pgTable("project_teams", {
      id: serial("id").primaryKey(),
      projectId: integer("project_id").notNull(),
      teamId: integer("team_id").notNull(),
      role: text("role").notNull().default("member"),
      // 'member' or 'admin'
      addedAt: timestamp("added_at").defaultNow().notNull()
    });
    insertProjectTeamSchema = createInsertSchema(projectTeams).pick({
      projectId: true,
      teamId: true,
      role: true
    }).extend({
      role: z.enum(["member", "admin"]).default("member")
    });
    notifications = pgTable("notifications", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull(),
      title: text("title").notNull(),
      message: text("message").notNull(),
      type: text("type").notNull(),
      // 'task', 'board', 'project', 'team', 'okr'
      read: boolean("read").default(false),
      link: text("link"),
      // URL to the related content
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    notificationSettings = pgTable("notification_settings", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull(),
      // Aufgaben
      taskAssigned: boolean("task_assigned").default(true),
      taskDue: boolean("task_due").default(true),
      taskUpdates: boolean("task_updates").default(true),
      taskComments: boolean("task_comments").default(true),
      // Boards
      boardInvite: boolean("board_invite").default(true),
      boardUpdates: boolean("board_updates").default(true),
      // Teams
      teamInvite: boolean("team_invite").default(true),
      teamUpdates: boolean("team_updates").default(true),
      // Projekte
      projectUpdate: boolean("project_update").default(true),
      // OKRs
      okrProgress: boolean("okr_progress").default(true),
      okrComments: boolean("okr_comments").default(true),
      // Allgemein
      mentions: boolean("mentions").default(true),
      //Meeting Protokolle
      protocolUpdates: boolean("protocol_updates").default(true)
    });
    insertNotificationSchema = createInsertSchema(notifications).pick({
      userId: true,
      title: true,
      message: true,
      type: true,
      link: true
    }).extend({
      type: z.enum([
        // Aufgaben
        "task",
        "task_update",
        "task_delete",
        "task_comment",
        // Boards
        "board",
        "board_update",
        // Projekte
        "project",
        "project_update",
        // Teams 
        "team",
        "team_update",
        // OKRs
        "okr",
        "okr_update",
        "okr_delete",
        "okr_comment",
        // Allgemein
        "approval",
        "mention",
        "assignment",
        "comment",
        "protocol"
      ])
    });
    insertNotificationSettingsSchema = createInsertSchema(notificationSettings).pick({
      userId: true,
      // Aufgaben
      taskAssigned: true,
      taskDue: true,
      taskUpdates: true,
      taskComments: true,
      // Boards
      boardInvite: true,
      boardUpdates: true,
      // Teams
      teamInvite: true,
      teamUpdates: true,
      // Projekte
      projectUpdate: true,
      // OKRs
      okrProgress: true,
      okrComments: true,
      // Allgemein
      mentions: true,
      //Meeting Protokolle
      protocolUpdates: true
    });
    userFavoriteProjects = pgTable("user_favorite_projects", {
      userId: integer("user_id").notNull(),
      projectId: integer("project_id").notNull(),
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => {
      return {
        pk: primaryKey({ columns: [table.userId, table.projectId] })
      };
    });
    userFavoriteBoards = pgTable("user_favorite_boards", {
      userId: integer("user_id").notNull(),
      boardId: integer("board_id").notNull(),
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => {
      return {
        pk: primaryKey({ columns: [table.userId, table.boardId] })
      };
    });
    userFavoriteObjectives = pgTable("user_favorite_objectives", {
      userId: integer("user_id").notNull(),
      objectiveId: integer("objective_id").notNull(),
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => {
      return {
        pk: primaryKey({ columns: [table.userId, table.objectiveId] })
      };
    });
    meetingProtocols = pgTable("meeting_protocols", {
      id: serial("id").primaryKey(),
      title: text("title").notNull(),
      date: timestamp("date").notNull(),
      // Datum des Meetings
      teamId: integer("team_id").references(() => teams.id),
      projectId: integer("project_id").references(() => projects.id),
      objectiveId: integer("objective_id").references(() => objectives.id),
      creatorId: integer("creator_id").notNull().references(() => users.id),
      // Ersteller des Protokolls
      agenda: text("agenda"),
      // Tagesordnung (Legacy-Feld, wird für ältere Protokolle beibehalten)
      decisions: text("decisions"),
      // Getroffene Entscheidungen (Legacy-Feld)
      agendaItems: jsonb("agenda_items"),
      // Strukturierte Agenda-Punkte mit Beschlüssen/Kategorien/Zuordnungen
      participants: text("participants").array(),
      // Teilnehmer als Array von User-IDs
      teamParticipants: integer("team_participants").array(),
      // Teilnehmende Teams als Array von Team-IDs
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    insertMeetingProtocolSchema = createInsertSchema(meetingProtocols).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    subscriptionPackages = pgTable("subscription_packages", {
      id: serial("id").primaryKey(),
      name: text("name").notNull().unique(),
      // free, freelancer, organisation, enterprise, kanbax
      displayName: text("display_name").notNull(),
      // Display name for UI (e.g., "Kostenlos", "Freelancer", etc.)
      description: text("description").notNull(),
      price: integer("price").notNull(),
      // Price in cents/month
      maxProjects: integer("max_projects").notNull(),
      // Max number of projects allowed
      maxBoards: integer("max_boards").notNull(),
      // Max number of boards allowed
      maxTeams: integer("max_teams").notNull(),
      // Max number of teams allowed
      maxUsersPerCompany: integer("max_users_per_company").notNull(),
      // Max number of users per company
      maxTasks: integer("max_tasks").default(0),
      // Max number of tasks allowed (0 = unlimited)
      maxOkrs: integer("max_okrs").default(0),
      // Max number of OKRs allowed (0 = none)
      hasGanttView: boolean("has_gantt_view").default(false),
      // Whether Gantt view is available
      hasAdvancedReporting: boolean("has_advanced_reporting").default(false),
      // Whether advanced reporting is available
      hasApiAccess: boolean("has_api_access").default(false),
      // Whether API access is available
      hasCustomBranding: boolean("has_custom_branding").default(false),
      // Whether custom branding is available
      hasPrioritySupport: boolean("has_priority_support").default(false),
      // Whether priority support is available
      requiresCompany: boolean("requires_company").default(false),
      // Whether a company association is required for this package
      stripeProductId: text("stripe_product_id"),
      // Stripe product ID for this package
      stripePriceId: text("stripe_price_id"),
      // Stripe price ID for this package
      isActive: boolean("is_active").default(true),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    insertSubscriptionPackageSchema = createInsertSchema(subscriptionPackages).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    subscriptions = pgTable("subscriptions", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").references(() => users.id).notNull(),
      companyId: integer("company_id").references(() => companies.id),
      packageId: integer("package_id").references(() => subscriptionPackages.id).notNull(),
      status: text("status").notNull().default("pending"),
      // pending, active, cancelled, expired
      stripeCustomerId: text("stripe_customer_id"),
      stripeSubscriptionId: text("stripe_subscription_id"),
      billingCycle: text("billing_cycle").default("monthly"),
      // monthly oder yearly
      startDate: timestamp("start_date").defaultNow().notNull(),
      endDate: timestamp("end_date"),
      trialEndsAt: timestamp("trial_ends_at"),
      cancellationReason: text("cancellation_reason"),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    insertSubscriptionSchema = createInsertSchema(subscriptions).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    payments = pgTable("payments", {
      id: serial("id").primaryKey(),
      subscriptionId: integer("subscription_id").references(() => subscriptions.id).notNull(),
      amount: real("amount").notNull(),
      currency: text("currency").notNull().default("eur"),
      status: text("status").notNull(),
      // succeeded, pending, failed
      stripePaymentIntentId: text("stripe_payment_intent_id"),
      stripeInvoiceId: text("stripe_invoice_id"),
      paymentMethod: text("payment_method"),
      receiptUrl: text("receipt_url"),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    insertPaymentSchema = createInsertSchema(payments).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    companyPaymentInfo = pgTable("company_payment_info", {
      id: serial("id").primaryKey(),
      companyId: integer("company_id").notNull().references(() => companies.id),
      stripeCustomerId: text("stripe_customer_id"),
      // Stripe customer ID
      stripeSubscriptionId: text("stripe_subscription_id"),
      // Stripe subscription ID
      subscriptionStatus: text("subscription_status").default("inactive"),
      // active, inactive, past_due, canceled, etc.
      subscriptionTier: text("subscription_tier").notNull().default("free"),
      // References subscription_packages.name
      subscriptionStartDate: timestamp("subscription_start_date"),
      subscriptionEndDate: timestamp("subscription_end_date"),
      billingCycle: text("billing_cycle").default("monthly"),
      // monthly, yearly
      isPaused: boolean("is_paused").default(false).notNull(),
      // Ob das Abonnement pausiert ist
      pauseReason: text("pause_reason"),
      // Begründung für die Pausierung
      pausedAt: timestamp("paused_at"),
      // Zeitpunkt der Pausierung
      billingEmail: text("billing_email").notNull(),
      billingName: text("billing_name").notNull(),
      billingAddress: text("billing_address"),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    insertCompanyPaymentInfoSchema = createInsertSchema(companyPaymentInfo).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    subscriptionAuditLogs = pgTable("subscription_audit_logs", {
      id: serial("id").primaryKey(),
      companyId: integer("company_id").references(() => companies.id),
      userId: integer("user_id").references(() => users.id),
      // Der Benutzer, dessen Abonnement geändert wurde
      changedByUserId: integer("changed_by_user_id").references(() => users.id),
      // Der Benutzer (Admin), der die Änderung vorgenommen hat
      action: text("action").notNull(),
      // upgrade, downgrade, cancel, renewal, payment_failed, admin_change, user_subscription_change, etc.
      oldTier: text("old_tier"),
      newTier: text("new_tier"),
      details: text("details"),
      // Additional details about the change
      amount: integer("amount"),
      // Amount involved in the transaction (if applicable)
      stripeEventId: text("stripe_event_id"),
      // Stripe event ID (if applicable)
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
  }
});

// server/db.ts
import { Pool, neonConfig } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-serverless";
import ws from "ws";
var pool, db;
var init_db = __esm({
  "server/db.ts"() {
    "use strict";
    init_schema();
    neonConfig.webSocketConstructor = ws;
    if (!process.env.DATABASE_URL) {
      throw new Error(
        "DATABASE_URL must be set. Did you forget to provision a database?"
      );
    }
    pool = new Pool({ connectionString: process.env.DATABASE_URL });
    db = drizzle({ client: pool, schema: schema_exports });
  }
});

// server/permissions.ts
import { eq, inArray, and, or, desc, sql, exists } from "drizzle-orm";
var PermissionService, permissionService;
var init_permissions = __esm({
  "server/permissions.ts"() {
    "use strict";
    init_db();
    init_schema();
    PermissionService = class {
      // Prüft, ob ein Benutzer ein Hyper-Admin ist
      async isHyperAdmin(userId) {
        if (!userId) return false;
        console.log(`Checking if user ${userId} is a Hyper-Admin`);
        const userQuery = await db.query.users.findFirst({
          where: eq(users.id, userId)
        });
        const isAdmin = userQuery?.isHyperAdmin === true;
        console.log(`User ${userId} is Hyper-Admin: ${isAdmin}`);
        return isAdmin;
      }
      // Zugriffsprüfung für Unternehmen
      async canAccessCompany(userId, companyId) {
        console.log(`Checking company access for user ${userId} on company ${companyId}`);
        const isHyperAdmin = await this.isHyperAdmin(userId);
        if (isHyperAdmin) {
          console.log(`Access GRANTED: User ${userId} is a Hyper-Admin`);
          return true;
        }
        const [user] = await db.select().from(users).where(and(
          eq(users.id, userId),
          eq(users.companyId, companyId)
        ));
        return !!user;
      }
      // Zugriffsprüfung für Teams unter Berücksichtigung der Unternehmenszugehörigkeit
      async canAccessTeam(userId, teamId) {
        console.log(`Checking team access for user ${userId} on team ${teamId}`);
        const isHyperAdmin = await this.isHyperAdmin(userId);
        if (isHyperAdmin) {
          console.log(`Access GRANTED: User ${userId} is a Hyper-Admin`);
          return true;
        }
        const [team] = await db.select().from(teams).where(eq(teams.id, teamId));
        if (!team) return false;
        if (team.creatorId === userId) {
          console.log(`Access GRANTED: User ${userId} is creator of team ${teamId}`);
          return true;
        }
        const [teamMember] = await db.select().from(teamMembers).where(and(
          eq(teamMembers.teamId, teamId),
          eq(teamMembers.userId, userId)
        ));
        if (teamMember) {
          console.log(`Access GRANTED: User ${userId} is a member of team ${teamId}`);
          return true;
        }
        console.log(`Access DENIED: User ${userId} has no permissions for team ${teamId}`);
        return false;
      }
      // Zugriffsprüfung für Projekte unter Berücksichtigung der Unternehmenszugehörigkeit
      async canAccessProject(userId, projectId) {
        console.log(`Checking project access for user ${userId} on project ${projectId}`);
        const isHyperAdmin = await this.isHyperAdmin(userId);
        if (isHyperAdmin) {
          console.log(`Access GRANTED: User ${userId} is a Hyper-Admin`);
          return true;
        }
        const [project] = await db.select().from(projects).where(eq(projects.id, projectId));
        if (!project) return false;
        if (project.creator_id === userId) {
          console.log(`Access GRANTED: User ${userId} is creator of project ${projectId}`);
          return true;
        }
        if (project.memberIds && project.memberIds.includes(userId)) {
          console.log(`Access GRANTED: User ${userId} is directly assigned to project ${projectId}`);
          return true;
        }
        const userTeams = await db.select().from(teamMembers).where(eq(teamMembers.userId, userId));
        const userTeamIds = userTeams.map((tm) => tm.teamId);
        if (project.teamIds && project.teamIds.some((teamId) => userTeamIds.includes(teamId))) {
          console.log(`Access GRANTED: User ${userId} is member of a team assigned to project ${projectId}`);
          return true;
        }
        console.log(`Access DENIED: User ${userId} has no permissions for project ${projectId}`);
        return false;
      }
      // Zugriffsprüfung für Boards unter Berücksichtigung der Unternehmenszugehörigkeit
      async canAccessBoard(userId, boardId) {
        console.log(`Checking board access for user ${userId} on board ${boardId}`);
        const isHyperAdmin = await this.isHyperAdmin(userId);
        if (isHyperAdmin) {
          console.log(`Access GRANTED: User ${userId} is a Hyper-Admin`);
          return true;
        }
        const [board] = await db.select().from(boards).where(eq(boards.id, boardId));
        if (!board) return false;
        if (board.creator_id === userId) {
          console.log(`Access GRANTED: User ${userId} is creator of board ${boardId}`);
          return true;
        }
        if (board.assigned_user_ids && board.assigned_user_ids.includes(userId)) {
          console.log(`Access GRANTED: User ${userId} is directly assigned to board ${boardId}`);
          return true;
        }
        const [boardMember] = await db.select().from(boardMembers2).where(and(
          eq(boardMembers2.boardId, boardId),
          eq(boardMembers2.userId, userId)
        ));
        if (boardMember) {
          console.log(`Access GRANTED: User ${userId} is a board member of board ${boardId}`);
          return true;
        }
        const userTeams = await db.select().from(teamMembers).where(eq(teamMembers.userId, userId));
        const userTeamIds = userTeams.map((tm) => tm.teamId);
        if (board.team_ids && board.team_ids.some((teamId) => userTeamIds.includes(teamId))) {
          console.log(`Access GRANTED: User ${userId} is member of a team assigned to board ${boardId}`);
          return true;
        }
        if (board.project_id) {
          const hasProjectAccess = await this.canAccessProject(userId, board.project_id);
          if (hasProjectAccess) {
            console.log(`Access GRANTED: User ${userId} has access to project of board ${boardId}`);
            return true;
          }
        }
        console.log(`Access DENIED: User ${userId} has no permissions for board ${boardId}`);
        return false;
      }
      // Zugriffsprüfung für Objectives unter Berücksichtigung der Unternehmenszugehörigkeit
      async canAccessObjective(userId, objectiveId) {
        console.log(`Checking objective access for user ${userId} on objective ${objectiveId}`);
        const isHyperAdmin = await this.isHyperAdmin(userId);
        if (isHyperAdmin) {
          console.log(`Access GRANTED: User ${userId} is a Hyper-Admin`);
          return true;
        }
        const [objective] = await db.select().from(objectives).where(eq(objectives.id, objectiveId));
        if (!objective) return false;
        if (objective.creatorId === userId) {
          console.log(`Access GRANTED: User ${userId} is creator of objective ${objectiveId}`);
          return true;
        }
        if (objective.userIds && objective.userIds.includes(userId)) {
          console.log(`Access GRANTED: User ${userId} is directly assigned to objective ${objectiveId}`);
          return true;
        }
        const [objectiveMember] = await db.select().from(objectiveMembers).where(and(
          eq(objectiveMembers.objectiveId, objectiveId),
          eq(objectiveMembers.userId, userId)
        ));
        if (objectiveMember) {
          console.log(`Access GRANTED: User ${userId} is a member of objective ${objectiveId}`);
          return true;
        }
        if (objective.teamId) {
          const hasTeamAccess = await this.canAccessTeam(userId, objective.teamId);
          if (hasTeamAccess) {
            console.log(`Access GRANTED: User ${userId} is member of team assigned to objective ${objectiveId}`);
            return true;
          }
        }
        if (objective.projectId) {
          const hasProjectAccess = await this.canAccessProject(userId, objective.projectId);
          if (hasProjectAccess) {
            console.log(`Access GRANTED: User ${userId} has access to project of objective ${objectiveId}`);
            return true;
          }
        }
        console.log(`Access DENIED: User ${userId} has no permissions for objective ${objectiveId}`);
        return false;
      }
      // Zugriffsprüfung für Benutzer unter Berücksichtigung der Unternehmenszugehörigkeit
      async canAccessUser(userId, targetUserId) {
        if (userId === targetUserId) return true;
        const isHyperAdmin = await this.isHyperAdmin(userId);
        if (isHyperAdmin) {
          console.log(`Access GRANTED: User ${userId} is a Hyper-Admin`);
          return true;
        }
        const [user] = await db.select().from(users).where(eq(users.id, userId));
        if (!user || !user.companyId) return false;
        const [targetUser] = await db.select().from(users).where(eq(users.id, targetUserId));
        if (!targetUser || !targetUser.companyId) return false;
        return user.companyId === targetUser.companyId;
      }
      // Filterfunktionen für verschiedene Entitäten
      async filterBoards(userId, boards4) {
        const accessibleBoards = await Promise.all(
          boards4.map(async (board) => {
            const hasAccess = await this.canAccessBoard(userId, board.id);
            return hasAccess ? board : null;
          })
        );
        return accessibleBoards.filter((board) => board !== null);
      }
      async filterProjects(userId, projects3) {
        const accessibleProjects = await Promise.all(
          projects3.map(async (project) => {
            const hasAccess = await this.canAccessProject(userId, project.id);
            return hasAccess ? project : null;
          })
        );
        return accessibleProjects.filter((project) => project !== null);
      }
      async filterUsers(userId, users2) {
        const isHyperAdmin = await this.isHyperAdmin(userId);
        if (isHyperAdmin) {
          console.log(`User ${userId} is a Hyper-Admin and can see all users`);
          return users2;
        }
        const currentUser = await db.query.users.findFirst({
          where: eq(users2.id, userId)
        });
        if (!currentUser || !currentUser.companyId) {
          return users2.filter((user) => user.id === userId);
        }
        return users2.filter(
          (user) => user.id === userId || user.companyId === currentUser.companyId
        );
      }
      async filterTeams(userId, teams2) {
        const accessibleTeams = await Promise.all(
          teams2.map(async (team) => {
            const hasAccess = await this.canAccessTeam(userId, team.id);
            return hasAccess ? team : null;
          })
        );
        return accessibleTeams.filter((team) => team !== null);
      }
      async filterTeamMembers(userId, teamMembers2) {
        const isHyperAdmin = await this.isHyperAdmin(userId);
        if (isHyperAdmin) {
          console.log(`User ${userId} is a Hyper-Admin and can see all team members`);
          return teamMembers2;
        }
        const currentUser = await db.query.users.findFirst({
          where: eq(users.id, userId)
        });
        if (!currentUser || !currentUser.companyId) {
          return teamMembers2.filter((tm) => tm.userId === userId);
        }
        const companyTeams = await db.query.teams.findMany({
          where: eq(teams.companyId, currentUser.companyId)
        });
        const companyTeamIds = new Set(companyTeams.map((team) => team.id));
        return teamMembers2.filter((tm) => companyTeamIds.has(tm.teamId));
      }
      async filterColumns(userId, columns2) {
        if (columns2.length === 0) return [];
        const boardId = columns2[0].boardId;
        const hasAccess = await this.canAccessBoard(userId, boardId);
        return hasAccess ? columns2 : [];
      }
      async filterComments(userId, comments2) {
        const filteredComments = await Promise.all(
          comments2.map(async (comment) => {
            const task = await db.select().from(tasks).where(eq(tasks.id, comment.taskId)).limit(1);
            if (!task[0]) return null;
            const hasAccess = await this.canAccessBoard(userId, task[0].boardId);
            return hasAccess ? comment : null;
          })
        );
        return filteredComments.filter((comment) => comment !== null);
      }
      async filterChecklistItems(userId, items) {
        const filteredItems = await Promise.all(
          items.map(async (item) => {
            const task = await db.select().from(tasks).where(eq(tasks.id, item.taskId)).limit(1);
            if (!task[0]) return null;
            const hasAccess = await this.canAccessBoard(userId, task[0].boardId);
            return hasAccess ? item : null;
          })
        );
        return filteredItems.filter((item) => item !== null);
      }
      // Activity Log Filterung basierend auf Unternehmenszugehörigkeit und Relevanz
      async getVisibleActivityLogs(userId) {
        try {
          console.log(`Getting visible activity logs for user ${userId}`);
          const isHyperAdmin = await this.isHyperAdmin(userId);
          if (isHyperAdmin) {
            console.log(`User ${userId} is a Hyper-Admin and can see all activity logs`);
            const result2 = await pool.query(`
          SELECT a.*, 
                 b.title as board_title, 
                 p.title as project_title,
                 o.title as objective_title,
                 t.title as task_title,
                 tm.name as team_title,
                 u.username, 
                 u.avatar_url,
                 tu.username as target_username
          FROM activity_logs a
          LEFT JOIN boards b ON a.board_id = b.id
          LEFT JOIN projects p ON a.project_id = p.id
          LEFT JOIN objectives o ON a.objective_id = o.id
          LEFT JOIN tasks t ON a.task_id = t.id
          LEFT JOIN teams tm ON a.team_id = tm.id
          LEFT JOIN users u ON a.user_id = u.id
          LEFT JOIN users tu ON a.target_user_id = tu.id
          ORDER BY a.created_at DESC
          LIMIT 200
        `);
            return result2.rows;
          }
          const userResult = await pool.query(`
        SELECT company_id FROM users WHERE id = $1
      `, [userId]);
          if (userResult.rows.length === 0) {
            console.log(`User ${userId} not found, returning empty activity list`);
            return [];
          }
          const companyId = userResult.rows[0].company_id;
          console.log(`User ${userId} belongs to company ${companyId}`);
          const accessibleBoardsQuery = await pool.query(`
        SELECT DISTINCT b.id 
        FROM boards b
        LEFT JOIN board_members bm ON b.id = bm.board_id
        LEFT JOIN teams t ON (b.team_ids IS NOT NULL AND b.team_ids && ARRAY[t.id])
        LEFT JOIN team_members tm ON t.id = tm.team_id
        LEFT JOIN tasks task ON task.board_id = b.id
        WHERE 
          -- Der Benutzer ist Ersteller des Boards
          b.creator_id = $1 OR 
          -- Der Benutzer ist Board-Mitglied
          bm.user_id = $1 OR 
          -- Der Benutzer ist in einem Team, das dem Board zugeordnet ist
          tm.user_id = $1 OR
          -- Der Benutzer ist dem Board direkt zugewiesen
          (b.assigned_user_ids IS NOT NULL AND $1 = ANY(b.assigned_user_ids)) OR
          -- Der Benutzer ist einer Task in diesem Board zugewiesen
          (task.assigned_user_ids IS NOT NULL AND $1 = ANY(task.assigned_user_ids))
      `, [userId]);
          const accessibleBoardIds = accessibleBoardsQuery.rows.map((row) => row.id);
          console.log(`User ${userId} has access to ${accessibleBoardIds.length} boards`);
          const accessibleProjectsQuery = await pool.query(`
        SELECT DISTINCT p.id 
        FROM projects p
        LEFT JOIN project_teams pt ON p.id = pt.project_id
        LEFT JOIN team_members tm ON pt.team_id = tm.team_id
        -- Zus\xE4tzlich Boards einbeziehen, die zu diesem Projekt geh\xF6ren
        LEFT JOIN boards b ON b.project_id = p.id
        LEFT JOIN board_members bm ON b.id = bm.board_id
        -- Zus\xE4tzlich Tasks einbeziehen, die zu einem Board dieses Projekts geh\xF6ren
        LEFT JOIN tasks t ON t.board_id = b.id
        WHERE 
          -- Der Benutzer ist Projektersteller
          p.creator_id = $1 OR 
          -- Der Benutzer ist Mitglied eines Teams, das dem Projekt zugewiesen ist
          tm.user_id = $1 OR
          -- Der Benutzer ist Ersteller eines Boards in diesem Projekt
          b.creator_id = $1 OR
          -- Der Benutzer ist Mitglied eines Boards in diesem Projekt
          bm.user_id = $1 OR
          -- Der Benutzer ist einem Board direkt zugewiesen, das zu diesem Projekt geh\xF6rt
          (b.assigned_user_ids IS NOT NULL AND $1 = ANY(b.assigned_user_ids)) OR
          -- Der Benutzer ist einer Task in diesem Projekt zugewiesen
          (t.assigned_user_ids IS NOT NULL AND $1 = ANY(t.assigned_user_ids))
      `, [userId]);
          const accessibleProjectIds = accessibleProjectsQuery.rows.map((row) => row.id);
          console.log(`User ${userId} has access to ${accessibleProjectIds.length} projects`);
          const accessibleTeamsQuery = await pool.query(`
        SELECT DISTINCT t.id 
        FROM teams t
        LEFT JOIN team_members tm ON t.id = tm.team_id
        WHERE 
          t.creator_id = $1 OR 
          tm.user_id = $1
      `, [userId]);
          const accessibleTeamIds = accessibleTeamsQuery.rows.map((row) => row.id);
          console.log(`User ${userId} is a member of ${accessibleTeamIds.length} teams`);
          const accessibleObjectivesQuery = await pool.query(`
        SELECT DISTINCT o.id 
        FROM objectives o
        LEFT JOIN objective_members om ON o.id = om.objective_id
        LEFT JOIN teams t ON o.team_id = t.id
        LEFT JOIN team_members tm ON t.id = tm.team_id
        -- Zus\xE4tzlich Key Results einbeziehen, die zu diesem Objective geh\xF6ren
        LEFT JOIN key_results kr ON kr.objective_id = o.id
        WHERE 
          -- Der Benutzer ist Objective-Ersteller
          o.creator_id = $1 OR 
          -- Der Benutzer ist direkt dem Objective zugewiesen
          om.user_id = $1 OR 
          -- Der Benutzer ist Mitglied eines Teams, das dem Objective zugewiesen ist
          tm.user_id = $1 OR
          -- Der Benutzer ist Ersteller eines Key Results in diesem Objective
          kr.creator_id = $1 OR
          -- Der Benutzer kann das Objective sehen, weil er in der visibleToUserIds-Liste steht
          (o.visible_to_user_ids IS NOT NULL AND $1 = ANY(o.visible_to_user_ids))
      `, [userId]);
          const accessibleObjectiveIds = accessibleObjectivesQuery.rows.map((row) => row.id);
          console.log(`User ${userId} has access to ${accessibleObjectiveIds.length} objectives`);
          const accessibleTasksQuery = await pool.query(`
        SELECT DISTINCT t.id 
        FROM tasks t
        LEFT JOIN boards b ON t.board_id = b.id
        LEFT JOIN board_members bm ON b.id = bm.board_id
        LEFT JOIN teams tm ON (
          -- Wenn das Board Teams hat
          (b.team_ids IS NOT NULL AND b.team_ids && ARRAY[tm.id]) OR
          -- ODER wenn die Task direkt einem Team zugewiesen ist
          t.assigned_team_id = tm.id
        )
        LEFT JOIN team_members tm_members ON tm.id = tm_members.team_id
        WHERE 
          -- Direkter Zugriff \xFCber Task-Eigenschaften (Tasks haben keine creator_id Spalte)
          (t.assigned_user_ids IS NOT NULL AND $1 = ANY(t.assigned_user_ids)) OR
          -- Zugriff \xFCber Board-Mitgliedschaft
          bm.user_id = $1 OR 
          -- Zugriff \xFCber Team-Mitgliedschaft
          tm_members.user_id = $1 OR
          -- Zus\xE4tzlich: Der Benutzer hat Zugriff auf das Board
          (b.creator_id = $1) OR
          (b.assigned_user_ids IS NOT NULL AND $1 = ANY(b.assigned_user_ids))
      `, [userId]);
          const accessibleTaskIds = accessibleTasksQuery.rows.map((row) => row.id);
          console.log(`User ${userId} has access to ${accessibleTaskIds.length} tasks`);
          const queryParts = [];
          const queryParams = [userId];
          let paramCounter = 2;
          queryParts.push(`a.user_id = $1 OR a.target_user_id = $1`);
          if (accessibleBoardIds.length > 0) {
            const placeholders = accessibleBoardIds.map((_, idx) => `$${paramCounter + idx}`).join(",");
            queryParts.push(`(a.board_id IS NOT NULL AND a.board_id IN (${placeholders}))`);
            queryParams.push(...accessibleBoardIds);
            paramCounter += accessibleBoardIds.length;
          }
          if (accessibleProjectIds.length > 0) {
            const placeholders = accessibleProjectIds.map((_, idx) => `$${paramCounter + idx}`).join(",");
            queryParts.push(`(a.project_id IS NOT NULL AND a.project_id IN (${placeholders}))`);
            queryParams.push(...accessibleProjectIds);
            paramCounter += accessibleProjectIds.length;
          }
          if (accessibleObjectiveIds.length > 0) {
            const placeholders = accessibleObjectiveIds.map((_, idx) => `$${paramCounter + idx}`).join(",");
            queryParts.push(`(a.objective_id IS NOT NULL AND a.objective_id IN (${placeholders}))`);
            queryParams.push(...accessibleObjectiveIds);
            paramCounter += accessibleObjectiveIds.length;
          }
          if (accessibleTeamIds.length > 0) {
            const placeholders = accessibleTeamIds.map((_, idx) => `$${paramCounter + idx}`).join(",");
            queryParts.push(`(a.team_id IS NOT NULL AND a.team_id IN (${placeholders}))`);
            queryParams.push(...accessibleTeamIds);
            paramCounter += accessibleTeamIds.length;
          }
          if (accessibleTaskIds.length > 0) {
            const placeholders = accessibleTaskIds.map((_, idx) => `$${paramCounter + idx}`).join(",");
            queryParts.push(`(a.task_id IS NOT NULL AND a.task_id IN (${placeholders}))`);
            queryParams.push(...accessibleTaskIds);
            paramCounter += accessibleTaskIds.length;
          }
          queryParams.push(companyId);
          const companyIdParamIndex = paramCounter;
          const whereConditions = [];
          if (accessibleBoardIds.length > 0) {
            whereConditions.push(inArray(activityLogs.boardId, accessibleBoardIds));
          }
          if (accessibleProjectIds.length > 0) {
            whereConditions.push(inArray(activityLogs.projectId, accessibleProjectIds));
          }
          if (accessibleObjectiveIds.length > 0) {
            whereConditions.push(inArray(activityLogs.objectiveId, accessibleObjectiveIds));
          }
          if (accessibleTeamIds.length > 0) {
            whereConditions.push(inArray(activityLogs.teamId, accessibleTeamIds));
          }
          if (accessibleTaskIds.length > 0) {
            whereConditions.push(inArray(activityLogs.taskId, accessibleTaskIds));
          }
          const baseCondition = whereConditions.length > 0 ? or(...whereConditions) : sql`FALSE`;
          const companyCondition = companyId ? exists(
            db.select().from(users).where(and(
              eq(users.id, activityLogs.userId),
              eq(users.companyId, companyId)
            ))
          ) : sql`TRUE`;
          console.log(`Executing safe activity logs query with Drizzle ORM`);
          const result = await db.select({
            id: activityLogs.id,
            action: activityLogs.action,
            details: activityLogs.details,
            userId: activityLogs.userId,
            boardId: activityLogs.boardId,
            projectId: activityLogs.projectId,
            objectiveId: activityLogs.objectiveId,
            taskId: activityLogs.taskId,
            commentId: activityLogs.commentId,
            teamId: activityLogs.teamId,
            targetUserId: activityLogs.targetUserId,
            createdAt: activityLogs.createdAt,
            visibleToTeams: activityLogs.visibleToTeams,
            visibleToUsers: activityLogs.visibleToUsers,
            requiresNotification: activityLogs.requiresNotification,
            notificationSent: activityLogs.notificationSent,
            notificationType: activityLogs.notificationType,
            board_title: boards.title,
            project_title: projects.title,
            objective_title: objectives.title,
            task_title: tasks.title,
            team_title: teams.name,
            username: users.username,
            avatar_url: users.avatarUrl,
            target_username: sql`tu.username`
          }).from(activityLogs).leftJoin(boards, eq(activityLogs.boardId, boards.id)).leftJoin(projects, eq(activityLogs.projectId, projects.id)).leftJoin(objectives, eq(activityLogs.objectiveId, objectives.id)).leftJoin(tasks, eq(activityLogs.taskId, tasks.id)).leftJoin(teams, eq(activityLogs.teamId, teams.id)).leftJoin(users, eq(activityLogs.userId, users.id)).leftJoin(sql`users tu`, sql`${activityLogs.targetUserId} = tu.id`).where(and(baseCondition, companyCondition)).orderBy(desc(activityLogs.createdAt)).limit(100);
          console.log(`Found ${result.length} relevant activity logs for user ${userId}`);
          return result;
        } catch (error) {
          console.error("Error getting visible activity logs:", error);
          return [];
        }
      }
    };
    permissionService = new PermissionService();
  }
});

// server/subscription-service.ts
import { eq as eq2, and as and2, sql as sql2, inArray as inArray2, count } from "drizzle-orm";
var SubscriptionService, subscriptionService;
var init_subscription_service = __esm({
  "server/subscription-service.ts"() {
    "use strict";
    init_db();
    init_schema();
    SubscriptionService = class {
      /**
       * Liefert die Standard-Pakete mit ihren Einschränkungen
       */
      getDefaultPackages() {
        return [
          {
            name: "free",
            displayName: "Kostenlos",
            description: "Ideal f\xFCr Einzelpersonen",
            price: 0,
            maxProjects: 1,
            maxBoards: 1,
            maxTeams: 0,
            // Keine Teams erlaubt
            maxUsersPerCompany: 1,
            maxTasks: 10,
            // Aktualisiert von 20 auf 10, um mit taskLimitMiddleware.ts übereinzustimmen
            maxOkrs: 0,
            // Keine OKRs erlaubt
            hasGanttView: false,
            hasAdvancedReporting: false,
            hasApiAccess: false,
            hasCustomBranding: false,
            hasPrioritySupport: false,
            requiresCompany: false,
            hasTeamFeatures: false,
            // Teams-Funktionalität deaktiviert
            hasOkrFeatures: false,
            // OKR-Funktionalität deaktiviert
            isActive: true
          },
          {
            name: "freelancer",
            displayName: "Freelancer",
            description: "F\xFCr Selbstst\xE4ndige",
            price: 900,
            // 9€ pro Monat in Cent
            maxProjects: 3,
            maxBoards: 5,
            maxTeams: 0,
            // Keine Teams erlaubt
            maxUsersPerCompany: 1,
            maxTasks: 50,
            maxOkrs: 0,
            // Keine OKRs erlaubt
            hasGanttView: true,
            hasAdvancedReporting: false,
            hasApiAccess: false,
            hasCustomBranding: false,
            hasPrioritySupport: false,
            requiresCompany: false,
            hasTeamFeatures: false,
            // Teams-Funktionalität deaktiviert
            hasOkrFeatures: false,
            // OKR-Funktionalität deaktiviert
            isActive: true
          },
          {
            name: "organisation",
            displayName: "Organisation",
            description: "F\xFCr kleine Teams",
            price: 4900,
            // 49€ pro Jahr in Cent (jährliche Abrechnung)
            maxProjects: 10,
            maxBoards: 20,
            maxTeams: 5,
            maxUsersPerCompany: 10,
            maxTasks: 500,
            maxOkrs: 10,
            hasGanttView: true,
            hasAdvancedReporting: true,
            hasApiAccess: true,
            hasCustomBranding: false,
            hasPrioritySupport: false,
            requiresCompany: true,
            isActive: true
          },
          {
            name: "enterprise",
            displayName: "Enterprise",
            description: "F\xFCr gro\xDFe Unternehmen",
            price: 9900,
            // 99€ pro Jahr in Cent (jährliche Abrechnung)
            maxProjects: 50,
            maxBoards: 100,
            maxTeams: 20,
            maxUsersPerCompany: 30,
            maxTasks: 2e3,
            maxOkrs: 50,
            hasGanttView: true,
            hasAdvancedReporting: true,
            hasApiAccess: true,
            hasCustomBranding: true,
            hasPrioritySupport: true,
            requiresCompany: true,
            isActive: true
          },
          {
            name: "kanbax",
            displayName: "kanbax",
            description: "Internes Paket f\xFCr kanbax-Mitarbeiter",
            price: 0,
            // Kostenlos für interne Nutzung
            maxProjects: 999999,
            // Praktisch unbegrenzt
            maxBoards: 999999,
            // Praktisch unbegrenzt
            maxTeams: 999999,
            // Praktisch unbegrenzt
            maxUsersPerCompany: 999999,
            // Praktisch unbegrenzt
            maxTasks: 999999,
            // Praktisch unbegrenzt
            maxOkrs: 999999,
            // Praktisch unbegrenzt
            hasGanttView: true,
            hasAdvancedReporting: true,
            hasApiAccess: true,
            hasCustomBranding: true,
            hasPrioritySupport: true,
            requiresCompany: true,
            hasTeamFeatures: true,
            hasOkrFeatures: true,
            isActive: true
          }
        ];
      }
      /**
       * Prüft, ob eine Firma die maximale Anzahl an Aufgaben erreicht hat
       */
      async hasReachedTaskLimit(companyId) {
        try {
          const usersResult = await db.query.users.findMany({
            where: eq2(users.companyId, companyId)
          });
          const userIds = usersResult.map((user) => user.id);
          if (userIds.length === 0) return false;
          const userIdsStr = userIds.join(",");
          const taskCountResult = await db.execute(
            sql2`SELECT COUNT(*) as count FROM tasks WHERE assigned_user_ids && ARRAY[${sql2.raw(userIdsStr)}]`
          );
          const taskCount = parseInt(String(taskCountResult.rows[0]?.count) || "0");
          const paymentInfo = await db.query.companyPaymentInfo.findFirst({
            where: eq2(companyPaymentInfo.companyId, companyId)
          });
          const subscriptionTier = paymentInfo?.subscriptionTier || "free";
          const packageLimits = await db.query.subscriptionPackages.findFirst({
            where: eq2(subscriptionPackages.name, subscriptionTier)
          });
          if (!packageLimits) {
            const DEFAULT_FREE_MAX_TASKS = 10;
            console.log(`Tasklimit-Pr\xFCfung: Keine Paketlimits gefunden, verwende Standard (${DEFAULT_FREE_MAX_TASKS})`);
            return taskCount >= DEFAULT_FREE_MAX_TASKS;
          }
          if (packageLimits.maxTasks >= 999999) {
            return false;
          }
          return taskCount >= packageLimits.maxTasks;
        } catch (error) {
          console.error("Fehler bei der \xDCberpr\xFCfung des Task-Limits:", error);
          return false;
        }
      }
      /**
       * Prüft, ob eine Firma die maximale Anzahl an OKRs erreicht hat
       */
      async hasReachedOkrLimit(companyId) {
        try {
          const usersResult = await db.query.users.findMany({
            where: eq2(users.companyId, companyId)
          });
          const userIds = usersResult.map((user) => user.id);
          if (userIds.length === 0) return false;
          const userIdsStr = userIds.join(",");
          const objectiveCountResult = await db.execute(
            sql2`SELECT COUNT(*) as count FROM objectives WHERE creator_id IN (${sql2.raw(userIdsStr)}) AND archived = false`
          );
          const objectiveCount = parseInt(String(objectiveCountResult.rows[0]?.count) || "0");
          const paymentInfo = await db.query.companyPaymentInfo.findFirst({
            where: eq2(companyPaymentInfo.companyId, companyId)
          });
          const subscriptionTier = paymentInfo?.subscriptionTier || "free";
          const packageLimits = await db.query.subscriptionPackages.findFirst({
            where: eq2(subscriptionPackages.name, subscriptionTier)
          });
          if (!packageLimits) {
            return objectiveCount >= 0;
          }
          if (packageLimits.maxOkrs >= 999999) {
            return false;
          }
          return objectiveCount >= packageLimits.maxOkrs;
        } catch (error) {
          console.error("Fehler bei der \xDCberpr\xFCfung des OKR-Limits:", error);
          return false;
        }
      }
      /**
       * Prüft, ob eine Firma die maximale Anzahl an Projekten erreicht hat
       */
      async hasReachedProjectLimit(companyId) {
        try {
          const projectCountResult = await db.execute(
            sql2`SELECT COUNT(*) as count FROM projects WHERE company_id = ${sql2.raw(companyId.toString())} AND archived = false`
          );
          const projectCount = parseInt(String(projectCountResult.rows[0]?.count) || "0");
          console.log(`Projektlimit-Pr\xFCfung: Unternehmen ${companyId} hat ${projectCount} Projekte`);
          const paymentInfo = await db.query.companyPaymentInfo.findFirst({
            where: eq2(companyPaymentInfo.companyId, companyId)
          });
          const subscriptionTier = paymentInfo?.subscriptionTier || "free";
          console.log(`Projektlimit-Pr\xFCfung: Abonnement-Stufe ist "${subscriptionTier}"`);
          const packageLimits = await db.query.subscriptionPackages.findFirst({
            where: eq2(subscriptionPackages.name, subscriptionTier)
          });
          const DEFAULT_FREE_MAX_PROJECTS = 1;
          if (!packageLimits) {
            console.log(`Projektlimit-Pr\xFCfung: Keine Paketlimits gefunden, verwende Standard (${DEFAULT_FREE_MAX_PROJECTS})`);
            return projectCount >= DEFAULT_FREE_MAX_PROJECTS;
          }
          console.log(`Projektlimit-Pr\xFCfung: Paketlimit ist ${packageLimits.maxProjects}, aktuelle Anzahl: ${projectCount}`);
          if (packageLimits.maxProjects >= 999999) {
            return false;
          }
          const hasReachedLimit = projectCount >= packageLimits.maxProjects;
          console.log(`Projektlimit-Pr\xFCfung: Limit erreicht? ${hasReachedLimit}`);
          return hasReachedLimit;
        } catch (error) {
          console.error("Fehler bei der \xDCberpr\xFCfung des Projektlimits:", error);
          return false;
        }
      }
      /**
       * Prüft, ob eine Firma die maximale Anzahl an Boards erreicht hat
       */
      async hasReachedBoardLimit(companyId) {
        try {
          const usersResult = await db.query.users.findMany({
            where: eq2(users.companyId, companyId)
          });
          const userIds = usersResult.map((user) => user.id);
          if (userIds.length === 0) return false;
          const boardCountResult = await db.select({
            count: count()
          }).from(boards).where(
            and2(
              inArray2(boards.creator_id, userIds),
              eq2(boards.archived, false)
            )
          );
          const boardCount = parseInt(String(boardCountResult[0]?.count) || "0");
          console.log(`Boardlimit-Pr\xFCfung: Unternehmen ${companyId} hat ${boardCount} Boards`);
          const paymentInfo = await db.query.companyPaymentInfo.findFirst({
            where: eq2(companyPaymentInfo.companyId, companyId)
          });
          const subscriptionTier = paymentInfo?.subscriptionTier || "free";
          console.log(`Boardlimit-Pr\xFCfung: Abonnement-Stufe ist "${subscriptionTier}"`);
          const packageLimits = await db.query.subscriptionPackages.findFirst({
            where: eq2(subscriptionPackages.name, subscriptionTier)
          });
          const DEFAULT_FREE_MAX_BOARDS = 1;
          if (!packageLimits) {
            console.log(`Boardlimit-Pr\xFCfung: Keine Paketlimits gefunden, verwende Standard (${DEFAULT_FREE_MAX_BOARDS})`);
            return boardCount >= DEFAULT_FREE_MAX_BOARDS;
          }
          console.log(`Boardlimit-Pr\xFCfung: Paketlimit ist ${packageLimits.maxBoards}, aktuelle Anzahl: ${boardCount}`);
          if (packageLimits.maxBoards >= 999999) {
            return false;
          }
          const hasReachedLimit = boardCount >= packageLimits.maxBoards;
          console.log(`Boardlimit-Pr\xFCfung: Limit erreicht? ${hasReachedLimit}`);
          return hasReachedLimit;
        } catch (error) {
          console.error("Fehler bei der \xDCberpr\xFCfung des Board-Limits:", error);
          return false;
        }
      }
      /**
       * Prüft, ob eine Firma die maximale Anzahl an Teams erreicht hat
       */
      async hasReachedTeamLimit(companyId) {
        try {
          const teamCountResult = await db.execute(
            sql2`SELECT COUNT(*) as count FROM teams WHERE company_id = ${sql2.raw(companyId.toString())}`
          );
          const teamCount = parseInt(String(teamCountResult.rows[0]?.count) || "0");
          const paymentInfo = await db.query.companyPaymentInfo.findFirst({
            where: eq2(companyPaymentInfo.companyId, companyId)
          });
          const subscriptionTier = paymentInfo?.subscriptionTier || "free";
          const packageLimits = await db.query.subscriptionPackages.findFirst({
            where: eq2(subscriptionPackages.name, subscriptionTier)
          });
          if (!packageLimits) {
            return teamCount >= 2;
          }
          return teamCount >= packageLimits.maxTeams;
        } catch (error) {
          console.error("Fehler bei der \xDCberpr\xFCfung des Team-Limits:", error);
          return false;
        }
      }
      /**
       * Prüft, ob eine Firma die maximale Anzahl an Aufgaben erreicht hat
       */
      async hasReachedTaskLimit(companyId) {
        try {
          const usersResult = await db.query.users.findMany({
            where: eq2(users.companyId, companyId)
          });
          const userIds = usersResult.map((user) => user.id);
          if (userIds.length === 0) return false;
          const taskCountResult = await db.execute(
            sql2`SELECT COUNT(*) as count FROM tasks WHERE assigned_user_ids && ARRAY[${sql2.join(userIds, sql2`, `)}]`
          );
          const taskCount = parseInt(String(taskCountResult.rows[0]?.count) || "0");
          console.log(`Tasklimit-Pr\xFCfung: Unternehmen ${companyId} hat ${taskCount} Aufgaben`);
          const paymentInfo = await db.query.companyPaymentInfo.findFirst({
            where: eq2(companyPaymentInfo.companyId, companyId)
          });
          const subscriptionTier = paymentInfo?.subscriptionTier || "free";
          console.log(`Tasklimit-Pr\xFCfung: Abonnement-Stufe ist "${subscriptionTier}"`);
          const packageLimits = await db.query.subscriptionPackages.findFirst({
            where: eq2(subscriptionPackages.name, subscriptionTier)
          });
          if (!packageLimits) {
            const DEFAULT_FREE_MAX_TASKS = 10;
            console.log(`Tasklimit-Pr\xFCfung: Keine Paketlimits gefunden, verwende Standard (${DEFAULT_FREE_MAX_TASKS})`);
            return taskCount >= DEFAULT_FREE_MAX_TASKS;
          }
          console.log(`Tasklimit-Pr\xFCfung: Paketlimit ist ${packageLimits.maxTasks}, aktuelle Anzahl: ${taskCount}`);
          if (packageLimits.maxTasks >= 999999) {
            return false;
          }
          const hasReachedLimit = taskCount >= packageLimits.maxTasks;
          console.log(`Tasklimit-Pr\xFCfung: Limit erreicht? ${hasReachedLimit}`);
          return hasReachedLimit;
        } catch (error) {
          console.error("Fehler bei der \xDCberpr\xFCfung des Aufgabenlimits:", error);
          return false;
        }
      }
      /**
       * Gibt den Namen des aktuellen Abonnements für ein Unternehmen zurück
       */
      async getCurrentSubscriptionName(companyId) {
        try {
          const paymentInfo = await db.query.companyPaymentInfo.findFirst({
            where: eq2(companyPaymentInfo.companyId, companyId)
          });
          return paymentInfo?.subscriptionTier || "free";
        } catch (error) {
          console.error("Fehler beim Abrufen des Abonnementnamens:", error);
          return "free";
        }
      }
      /**
       * Prüft, ob eine Firma die maximale Anzahl an Benutzern erreicht hat
       */
      async hasReachedUserLimit(companyId) {
        try {
          const userCountResult = await db.execute(
            sql2`SELECT COUNT(*) as count FROM users WHERE company_id = ${sql2.raw(companyId.toString())} AND is_active = true`
          );
          const userCount = parseInt(String(userCountResult.rows[0]?.count) || "0");
          const paymentInfo = await db.query.companyPaymentInfo.findFirst({
            where: eq2(companyPaymentInfo.companyId, companyId)
          });
          const subscriptionTier = paymentInfo?.subscriptionTier || "free";
          const packageLimits = await db.query.subscriptionPackages.findFirst({
            where: eq2(subscriptionPackages.name, subscriptionTier)
          });
          if (!packageLimits) {
            return userCount >= 5;
          }
          return userCount >= packageLimits.maxUsersPerCompany;
        } catch (error) {
          console.error("Fehler bei der \xDCberpr\xFCfung des Benutzer-Limits:", error);
          return false;
        }
      }
      /**
       * Prüft, ob ein Benutzer Teams oder zusätzliche Benutzer hinzufügen darf
       * In den Paketen "Free" und "Freelancer" ist dies nicht erlaubt
       */
      async canAddTeamMembers(userId) {
        try {
          const user = await db.query.users.findFirst({
            where: eq2(users.id, userId)
          });
          if (!user) return false;
          if (user.subscriptionTier === "free" || user.subscriptionTier === "freelancer") {
            return false;
          }
          return true;
        } catch (error) {
          console.error("Fehler bei der \xDCberpr\xFCfung der Team-Mitglieder-Berechtigung:", error);
          return false;
        }
      }
      /**
       * Prüft, ob ein Benutzer Teams zuweisen darf
       * In den Paketen "Free" und "Freelancer" ist dies nicht erlaubt
       */
      async canAssignTeams(userId) {
        try {
          const user = await db.query.users.findFirst({
            where: eq2(users.id, userId)
          });
          if (!user) return false;
          if (user.subscriptionTier === "free" || user.subscriptionTier === "freelancer") {
            return false;
          }
          return true;
        } catch (error) {
          console.error("Fehler bei der \xDCberpr\xFCfung der Team-Zuweisung-Berechtigung:", error);
          return false;
        }
      }
      /**
       * Prüft, ob eine Firma Zugriff auf eine bestimmte Funktion hat
       */
      async hasFeatureAccess(companyId, featureName) {
        try {
          const paymentInfo = await db.query.companyPaymentInfo.findFirst({
            where: eq2(companyPaymentInfo.companyId, companyId)
          });
          const subscriptionTier = paymentInfo?.subscriptionTier || "free";
          const packageLimits = await db.query.subscriptionPackages.findFirst({
            where: eq2(subscriptionPackages.name, subscriptionTier)
          });
          if (!packageLimits) {
            return featureName === "basicFeatures";
          }
          switch (featureName) {
            case "teams":
              return packageLimits.hasTeamFeatures === true;
            case "okrs":
              return packageLimits.hasOkrFeatures === true;
            case "ganttView":
              return packageLimits.hasGanttView === true;
            case "advancedReporting":
              return packageLimits.hasAdvancedReporting === true;
            case "apiAccess":
              return packageLimits.hasApiAccess === true;
            case "customBranding":
              return packageLimits.hasCustomBranding === true;
            case "prioritySupport":
              return packageLimits.hasPrioritySupport === true;
            case "basicFeatures":
              return true;
            // Basis-Features sind in allen Paketen verfügbar
            default:
              return false;
          }
        } catch (error) {
          console.error(`Fehler bei der \xDCberpr\xFCfung des Zugriffs auf Feature "${featureName}":`, error);
          return false;
        }
      }
      /**
       * Aktualisiert das Abonnement einer Firma (intern, nicht für Stripe)
       * @param companyId Die ID des Unternehmens
       * @param newTier Das neue Abonnement-Tier
       * @param userId Die ID des Benutzers, der die Änderung durchführt
       * @param billingCycle Der Abrechnungszyklus (monatlich oder jährlich)
       */
      async updateSubscription(companyId, newTier, userId, billingCycle = "monthly") {
        try {
          console.log(`Aktualisiere Abonnement f\xFCr Unternehmen ${companyId} auf ${newTier} durch Benutzer ${userId} mit Abrechnungszyklus ${billingCycle}`);
          const normalizedBillingCycle = billingCycle && billingCycle.toLowerCase() === "yearly" ? "yearly" : "monthly";
          const expirationPeriod = normalizedBillingCycle === "yearly" ? 365 * 24 * 60 * 60 * 1e3 : 30 * 24 * 60 * 60 * 1e3;
          const subscriptionEndDate = newTier.toLowerCase() === "free" ? null : new Date(Date.now() + expirationPeriod);
          const currentPaymentInfo = await db.query.companyPaymentInfo.findFirst({
            where: eq2(companyPaymentInfo.companyId, companyId)
          });
          if (!currentPaymentInfo) {
            const company = await db.query.companies.findFirst({
              where: eq2(companies.id, companyId)
            });
            if (!company) {
              throw new Error("Firma nicht gefunden");
            }
            await db.insert(companyPaymentInfo).values({
              companyId,
              subscriptionTier: newTier,
              subscriptionStatus: "active",
              subscriptionStartDate: /* @__PURE__ */ new Date(),
              subscriptionEndDate,
              billingCycle: normalizedBillingCycle,
              // Abrechnungszyklus explizit speichern
              billingEmail: "billing@example.com",
              // Default
              billingName: company.name
            });
            await db.insert(subscriptionAuditLogs).values({
              companyId,
              userId,
              action: "create",
              newTier,
              details: `Abonnement erstellt (${normalizedBillingCycle})`
            });
            return true;
          }
          const oldTier = currentPaymentInfo.subscriptionTier;
          await db.update(companyPaymentInfo).set({
            subscriptionTier: newTier,
            billingCycle: normalizedBillingCycle,
            // Abrechnungszyklus explizit aktualisieren
            subscriptionEndDate,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq2(companyPaymentInfo.companyId, companyId));
          await db.insert(subscriptionAuditLogs).values({
            companyId,
            userId,
            action: newTier === "free" ? "downgrade" : oldTier === "free" ? "upgrade" : "change_tier",
            oldTier,
            newTier,
            details: `Abonnement von ${oldTier} auf ${newTier} ge\xE4ndert`
          });
          return true;
        } catch (error) {
          console.error("Fehler beim Aktualisieren des Abonnements:", error);
          return false;
        }
      }
      /**
       * Aktualisiert das Abonnement-Tier eines Benutzers
       * @param userId Die ID des Benutzers
       * @param newTier Das neue Abonnement-Tier
       * @param adminUserId Die ID des Administrators, der die Änderung durchführt (optional)
       * @param billingCycle Der Abrechnungszyklus (monatlich oder jährlich)
       */
      async updateUserSubscriptionTier(userId, newTier, adminUserId, billingCycle = "monthly") {
        try {
          console.log(`Aktualisiere Benutzer-Abonnement f\xFCr Benutzer ${userId} auf ${newTier} durch Admin ${adminUserId} mit Abrechnungszyklus ${billingCycle}`);
          const normalizedBillingCycle = billingCycle && billingCycle.toLowerCase() === "yearly" ? "yearly" : "monthly";
          const expirationPeriod = normalizedBillingCycle === "yearly" ? 365 * 24 * 60 * 60 * 1e3 : 30 * 24 * 60 * 60 * 1e3;
          const subscriptionExpiresAt = newTier.toLowerCase() === "free" ? null : new Date(Date.now() + expirationPeriod);
          const user = await db.query.users.findFirst({
            where: eq2(users.id, userId)
          });
          if (!user) {
            throw new Error("Benutzer nicht gefunden");
          }
          const oldTier = user.subscriptionTier || "free";
          await db.update(users).set({
            subscriptionTier: newTier,
            subscriptionBillingCycle: normalizedBillingCycle,
            subscriptionExpiresAt
          }).where(eq2(users.id, userId));
          await db.insert(subscriptionAuditLogs).values({
            userId,
            action: "user_subscription_change",
            oldTier,
            newTier,
            changedByUserId: adminUserId,
            details: `Benutzer-Abonnement von ${oldTier} auf ${newTier} ge\xE4ndert`
          });
          return true;
        } catch (error) {
          console.error("Fehler beim Aktualisieren des Benutzer-Abonnements:", error);
          return false;
        }
      }
      /**
       * Gibt die Standard-Paket-Definition zurück für die Initialisierung der Datenbank
       * (Diese Version ist für die Datenbank-Initialisierung)
       */
      getDefaultPackagesForDb() {
        return [
          {
            name: "free",
            displayName: "Kostenlos",
            description: "Grundlegende Funktionen f\xFCr Einzelpersonen",
            price: 0,
            maxProjects: 1,
            // Nur 1 Projekt erlaubt für Free-Benutzer
            maxBoards: 1,
            // 1 Board für Free-Benutzer
            maxTeams: 0,
            maxUsersPerCompany: 1,
            maxTasks: 10,
            // 10 Tasks um mit der Hauptkonfiguration übereinzustimmen
            maxOkrs: 0,
            hasGanttView: false,
            hasAdvancedReporting: false,
            hasApiAccess: false,
            hasCustomBranding: false,
            hasPrioritySupport: false,
            requiresCompany: false
          },
          {
            name: "freelancer",
            displayName: "Freelancer",
            description: "Erweitertes Paket f\xFCr Einzelpersonen",
            price: 800,
            // 8,00 € (monatliche oder jährliche Abrechnung möglich)
            maxProjects: 5,
            maxBoards: 5,
            maxTeams: 0,
            maxUsersPerCompany: 1,
            maxTasks: 999999,
            // unbegrenzt
            maxOkrs: 0,
            hasGanttView: true,
            hasAdvancedReporting: false,
            hasApiAccess: false,
            hasCustomBranding: false,
            hasPrioritySupport: false,
            requiresCompany: false
          },
          {
            name: "organisation",
            displayName: "Organisation",
            description: "Umfassende Funktionen f\xFCr kleine und mittelgro\xDFe Teams",
            price: 2900,
            // 29,00 € (monatliche oder jährliche Abrechnung möglich)
            maxProjects: 10,
            maxBoards: 999999,
            // unbegrenzt
            maxTeams: 4,
            maxUsersPerCompany: 10,
            maxTasks: 999999,
            // unbegrenzt
            maxOkrs: 3,
            hasGanttView: true,
            hasAdvancedReporting: true,
            hasApiAccess: false,
            hasCustomBranding: false,
            hasPrioritySupport: false,
            requiresCompany: true
          },
          {
            name: "enterprise",
            displayName: "Enterprise",
            description: "Unbegrenzte Funktionen f\xFCr gro\xDFe Unternehmen",
            price: 7900,
            // 79,00 € (monatliche oder jährliche Abrechnung möglich)
            maxProjects: 999999,
            // unbegrenzt
            maxBoards: 999999,
            // unbegrenzt
            maxTeams: 999999,
            // unbegrenzt
            maxUsersPerCompany: 30,
            maxTasks: 999999,
            // unbegrenzt
            maxOkrs: 999999,
            // unbegrenzt
            hasGanttView: true,
            hasAdvancedReporting: true,
            hasApiAccess: true,
            hasCustomBranding: true,
            hasPrioritySupport: true,
            requiresCompany: true
          },
          {
            name: "kanbax",
            displayName: "kanbax",
            description: "Spezialpaket mit unbegrenzten Funktionen",
            price: 0,
            maxProjects: 999999,
            // unbegrenzt
            maxBoards: 999999,
            // unbegrenzt
            maxTeams: 999999,
            // unbegrenzt
            maxUsersPerCompany: 999999,
            // unbegrenzt
            maxTasks: 999999,
            // unbegrenzt
            maxOkrs: 999999,
            // unbegrenzt
            hasGanttView: true,
            hasAdvancedReporting: true,
            hasApiAccess: true,
            hasCustomBranding: true,
            hasPrioritySupport: true,
            requiresCompany: false
          }
        ];
      }
    };
    subscriptionService = new SubscriptionService();
  }
});

// server/storage.ts
import { eq as eq3, desc as desc2, and as and3, gte, inArray as inArray3, sql as sql3 } from "drizzle-orm";
var DatabaseStorage, storage;
var init_storage = __esm({
  "server/storage.ts"() {
    "use strict";
    init_schema();
    init_schema();
    init_db();
    init_schema();
    init_schema();
    init_schema();
    init_schema();
    init_schema();
    init_schema();
    init_schema();
    init_permissions();
    init_subscription_service();
    DatabaseStorage = class {
      _permissionService;
      _subscriptionService;
      get permissionService() {
        if (!this._permissionService) {
          this._permissionService = permissionService;
        }
        return this._permissionService;
      }
      get subscriptionService() {
        if (!this._subscriptionService) {
          this._subscriptionService = subscriptionService;
        }
        return this._subscriptionService;
      }
      // Project operations
      async getProjects(userId) {
        try {
          console.log("Fetching projects for user:", userId);
          const projectResults = await db.select().from(projects);
          const favoriteProjects = await db.select().from(userFavoriteProjects).where(eq3(userFavoriteProjects.userId, userId));
          const favoriteProjectIds = new Set(favoriteProjects.map((fp) => fp.projectId));
          console.log("Starting permission check for projects, total projects:", projectResults.length);
          const accessibleProjectsPromises = projectResults.map(async (project) => {
            const hasAccess = await this.permissionService.canAccessProject(userId, project.id);
            console.log(`Project ${project.id} (${project.title}) permission check result:`, { hasAccess });
            if (hasAccess) {
              return {
                ...project,
                isFavorite: favoriteProjectIds.has(project.id)
              };
            }
            return null;
          });
          const accessibleProjects = (await Promise.all(accessibleProjectsPromises)).filter((project) => project !== null);
          console.log(`User ${userId} has access to ${accessibleProjects.length} of ${projectResults.length} projects`);
          return accessibleProjects;
        } catch (error) {
          console.error("Error in getProjects:", error);
          throw error;
        }
      }
      async getProject(userId, id) {
        try {
          const [project] = await db.select().from(projects).where(eq3(projects.id, id));
          if (!project || !await this.permissionService.canAccessProject(userId, id)) {
            throw new Error(`Project ${id} not found or unauthorized access`);
          }
          const [favorite] = await db.select().from(userFavoriteProjects).where(and3(
            eq3(userFavoriteProjects.userId, userId),
            eq3(userFavoriteProjects.projectId, id)
          ));
          let members = [];
          if (project.memberIds && project.memberIds.length > 0) {
            members = await db.select({
              id: users.id,
              username: users.username,
              email: users.email,
              avatarUrl: users.avatarUrl
            }).from(users).where(inArray3(users.id, project.memberIds));
          }
          let creator = null;
          if (project.creator_id) {
            const [creatorUser] = await db.select({
              id: users.id,
              username: users.username,
              email: users.email,
              avatarUrl: users.avatarUrl
            }).from(users).where(eq3(users.id, project.creator_id));
            creator = creatorUser;
          }
          return {
            ...project,
            isFavorite: favorite ? true : false,
            members,
            creator
          };
        } catch (error) {
          console.error("Error in getProject:", error);
          throw error;
        }
      }
      async createProject(userId, insertProject) {
        const projectData = {
          ...insertProject,
          creator_id: userId
        };
        const [project] = await db.insert(projects).values(projectData).returning();
        return project;
      }
      async updateProject(userId, id, updateProject) {
        if (!await this.permissionService.canAccessProject(userId, id)) {
          throw new Error(`Project ${id} not found or unauthorized access`);
        }
        const projectData = {
          ...updateProject,
          teamIds: Array.isArray(updateProject.teamIds) ? updateProject.teamIds : [],
          memberIds: Array.isArray(updateProject.memberIds) ? updateProject.memberIds : [],
          isFavorite: updateProject.isFavorite ?? void 0
        };
        const [project] = await db.update(projects).set(projectData).where(eq3(projects.id, id)).returning();
        if (!project) {
          throw new Error(`Project ${id} not found`);
        }
        return this.getProject(userId, id);
      }
      async deleteProject(userId, id) {
        if (!await this.permissionService.canAccessProject(userId, id)) {
          throw new Error(`Project ${id} not found or unauthorized access`);
        }
        const [project] = await db.delete(projects).where(eq3(projects.id, id)).returning();
        if (!project) {
          throw new Error(`Project ${id} not found`);
        }
      }
      async archiveProject(userId, id) {
        if (!await this.permissionService.canAccessProject(userId, id)) {
          throw new Error(`Project ${id} not found or unauthorized access`);
        }
        const [project] = await db.update(projects).set({ archived: true }).where(eq3(projects.id, id)).returning();
        if (!project) {
          throw new Error(`Project ${id} not found`);
        }
        await this.createActivityLog({
          action: "update",
          details: `Projekt "${project.title}" wurde archiviert`,
          userId,
          projectId: id,
          requiresNotification: true,
          notificationType: "project"
        });
        return this.getProject(userId, id);
      }
      async unarchiveProject(userId, id) {
        if (!await this.permissionService.canAccessProject(userId, id)) {
          throw new Error(`Project ${id} not found or unauthorized access`);
        }
        const [project] = await db.update(projects).set({ archived: false }).where(eq3(projects.id, id)).returning();
        if (!project) {
          throw new Error(`Project ${id} not found`);
        }
        await this.createActivityLog({
          action: "update",
          details: `Projekt "${project.title}" wurde wiederhergestellt`,
          userId,
          projectId: id,
          requiresNotification: true,
          notificationType: "project"
        });
        return this.getProject(userId, id);
      }
      // Board operations
      async getBoards(userId) {
        try {
          console.log("Fetching boards for user:", userId);
          const isHyperAdmin = await this.permissionService.isHyperAdmin(userId);
          console.log(`User ${userId} is Hyper-Admin: ${isHyperAdmin}`);
          const user = await db.query.users.findFirst({
            where: eq3(users.id, userId)
          });
          const boardResults = await db.select().from(boards);
          const userTeams = await db.select().from(teamMembers).where(eq3(teamMembers.userId, userId));
          const userTeamIds = userTeams.map((tm) => tm.teamId);
          console.log(`User ${userId} is a member of teams:`, userTeamIds);
          const filteredBoardResults = boardResults.filter((board) => {
            if (isHyperAdmin === true) return true;
            if (board.creator_id === userId) {
              console.log(`Board ${board.id}: User ${userId} is creator - access granted`);
              return true;
            }
            if (board.assigned_user_ids?.includes(userId)) {
              console.log(`Board ${board.id}: User ${userId} is directly assigned - access granted`);
              return true;
            }
            if (board.team_ids && board.team_ids.some((teamId) => userTeamIds.includes(teamId))) {
              console.log(`Board ${board.id}: User ${userId} is member of an assigned team - access granted`);
              return true;
            }
            console.log(`Board ${board.id}: User ${userId} has no access`);
            return false;
          });
          const favoriteBoards = await db.select().from(userFavoriteBoards).where(eq3(userFavoriteBoards.userId, userId));
          const favoriteBoardIds = new Set(favoriteBoards.map((fb) => fb.boardId));
          console.log(`User ${userId} has ${filteredBoardResults.length} accessible boards`);
          const accessibleBoardsPromises = filteredBoardResults.map(async (board) => {
            return {
              ...board,
              is_favorite: favoriteBoardIds.has(board.id)
            };
          });
          const accessibleBoards = (await Promise.all(accessibleBoardsPromises)).filter((board) => board !== null);
          console.log(`User ${userId} has access to ${accessibleBoards.length} of ${boardResults.length} boards`);
          const processedBoards = await Promise.all(accessibleBoards.map(async (board) => {
            let teamsData = [];
            if (board.team_ids && Array.isArray(board.team_ids) && board.team_ids.length > 0) {
              teamsData = await db.select().from(teams).where(inArray3(teams.id, board.team_ids));
            }
            let assignedUsers = [];
            if (board.assigned_user_ids && Array.isArray(board.assigned_user_ids) && board.assigned_user_ids.length > 0) {
              const usersList = await db.select({
                id: users.id,
                username: users.username,
                email: users.email,
                avatarUrl: users.avatarUrl
              }).from(users).where(inArray3(users.id, board.assigned_user_ids));
              assignedUsers = usersList;
            }
            let projectData = null;
            if (board.project_id) {
              const [project] = await db.select({
                id: projects.id,
                title: projects.title
              }).from(projects).where(eq3(projects.id, board.project_id));
              projectData = project;
            }
            return {
              ...board,
              teams: teamsData,
              assignedUsers,
              project: projectData
            };
          }));
          return processedBoards;
        } catch (error) {
          console.error("Error in getBoards:", error);
          throw error;
        }
      }
      async getBoardsByProject(userId, projectId) {
        try {
          console.log(`Fetching boards for project ${projectId} and user ${userId}`);
          const isHyperAdmin = await this.permissionService.isHyperAdmin(userId);
          console.log(`User ${userId} is Hyper-Admin: ${isHyperAdmin}`);
          const hasProjectAccess = await this.permissionService.canAccessProject(userId, projectId);
          if (!hasProjectAccess && !isHyperAdmin) {
            console.log(`User ${userId} has no access to project ${projectId}`);
            return [];
          }
          const boardResults = await db.select().from(boards).where(eq3(boards.project_id, projectId));
          const favoriteBoards = await db.select().from(userFavoriteBoards).where(eq3(userFavoriteBoards.userId, userId));
          const favoriteBoardIds = new Set(favoriteBoards.map((fb) => fb.boardId));
          const userTeams = await db.select().from(teamMembers).where(eq3(teamMembers.userId, userId));
          const userTeamIds = userTeams.map((tm) => tm.teamId);
          console.log(`User ${userId} is a member of teams:`, userTeamIds);
          let filteredBoards = boardResults;
          if (!isHyperAdmin) {
            filteredBoards = boardResults.filter((board) => {
              if (board.creator_id === userId) {
                console.log(`Board ${board.id}: User ${userId} is creator - access granted`);
                return true;
              }
              if (board.assigned_user_ids?.includes(userId)) {
                console.log(`Board ${board.id}: User ${userId} is directly assigned - access granted`);
                return true;
              }
              if (board.team_ids && board.team_ids.some((teamId) => userTeamIds.includes(teamId))) {
                console.log(`Board ${board.id}: User ${userId} is member of an assigned team - access granted`);
                return true;
              }
              console.log(`Board ${board.id}: User ${userId} has no access`);
              return false;
            });
          }
          const accessibleBoardsPromises = filteredBoards.map(async (board) => {
            const hasAccess = await this.permissionService.canAccessBoard(userId, board.id);
            if (hasAccess) {
              return {
                ...board,
                is_favorite: favoriteBoardIds.has(board.id)
              };
            }
            return null;
          });
          const accessibleBoards = (await Promise.all(accessibleBoardsPromises)).filter((board) => board !== null);
          console.log(`User ${userId} has access to ${accessibleBoards.length} of ${boardResults.length} boards in project ${projectId}`);
          return accessibleBoards;
        } catch (error) {
          console.error(`Error in getBoardsByProject for project ${projectId}:`, error);
          throw error;
        }
      }
      async getBoard(userId, id) {
        try {
          const [board] = await db.select().from(boards).where(eq3(boards.id, id));
          if (!board || !await this.permissionService.canAccessBoard(userId, id)) {
            throw new Error(`Board ${id} not found or unauthorized access`);
          }
          const [favorite] = await db.select().from(userFavoriteBoards).where(and3(
            eq3(userFavoriteBoards.userId, userId),
            eq3(userFavoriteBoards.boardId, id)
          ));
          const isFavorite = favorite ? true : false;
          let boardTeams = [];
          if (board.team_ids && board.team_ids.length > 0) {
            boardTeams = await db.select().from(teams).where(inArray3(teams.id, board.team_ids));
          }
          let boardUsers = [];
          if (board.assigned_user_ids && board.assigned_user_ids.length > 0) {
            boardUsers = await db.select({
              id: users.id,
              username: users.username,
              email: users.email,
              avatarUrl: users.avatarUrl
            }).from(users).where(inArray3(users.id, board.assigned_user_ids));
          }
          let projectData = null;
          if (board.project_id) {
            [projectData] = await db.select().from(projects).where(eq3(projects.id, board.project_id));
          }
          return {
            ...board,
            teams: boardTeams,
            users: boardUsers,
            project: projectData,
            is_favorite: isFavorite
          };
        } catch (error) {
          console.error("Error in getBoard:", error);
          throw error;
        }
      }
      async createBoard(userId, insertBoard) {
        try {
          const boardData = {
            title: insertBoard.title,
            description: insertBoard.description || null,
            project_id: insertBoard.project_id || null,
            creator_id: insertBoard.creator_id,
            team_ids: Array.isArray(insertBoard.team_ids) ? insertBoard.team_ids.filter((id) => id > 0) : [],
            assigned_user_ids: Array.isArray(insertBoard.assigned_user_ids) ? insertBoard.assigned_user_ids.filter((id) => id > 0) : [],
            is_favorite: insertBoard.is_favorite || false
          };
          const [board] = await db.insert(boards).values(boardData).returning();
          if (!board) {
            throw new Error("Failed to create board - no data returned");
          }
          const defaultColumns = [
            { title: "Backlog", order: 0 },
            { title: "To Do", order: 1 },
            { title: "In Progress", order: 2 },
            { title: "Done", order: 3 }
          ];
          for (const column of defaultColumns) {
            await db.insert(columns).values({
              title: column.title,
              boardId: board.id,
              order: column.order
            });
          }
          const completeBoard = await this.getBoard(userId, board.id);
          return completeBoard;
        } catch (error) {
          console.error("Storage: Error in createBoard:", error);
          throw error;
        }
      }
      async updateBoard(userId, id, updateBoard) {
        try {
          if (!await this.permissionService.canAccessBoard(userId, id)) {
            throw new Error(`Board ${id} not found or unauthorized access`);
          }
          const [existingBoard] = await db.select().from(boards).where(eq3(boards.id, id));
          if (!existingBoard) {
            throw new Error(`Board ${id} not found`);
          }
          const updateData = {
            title: updateBoard.title || existingBoard.title,
            description: updateBoard.description ?? existingBoard.description,
            project_id: updateBoard.project_id ?? existingBoard.project_id,
            creator_id: existingBoard.creator_id,
            team_ids: Array.isArray(updateBoard.team_ids) ? updateBoard.team_ids : existingBoard.team_ids,
            assigned_user_ids: Array.isArray(updateBoard.assigned_user_ids) ? updateBoard.assigned_user_ids : existingBoard.assigned_user_ids,
            is_favorite: updateBoard.is_favorite ?? existingBoard.is_favorite
          };
          const [updatedBoard] = await db.update(boards).set(updateData).where(eq3(boards.id, id)).returning();
          if (!updatedBoard) {
            throw new Error(`Failed to update board ${id}`);
          }
          return updatedBoard;
        } catch (error) {
          console.error("Error in updateBoard:", error);
          throw error;
        }
      }
      async updateBoardUsers(userId, boardId, userIds) {
        if (!await this.permissionService.canAccessBoard(userId, boardId)) {
          throw new Error(`Board ${boardId} not found or unauthorized access`);
        }
        await db.delete(boardMembers).where(eq3(boardMembers.boardId, boardId));
        if (userIds.length > 0) {
          await db.insert(boardMembers).values(userIds.map((userId2) => ({
            boardId,
            userId: userId2,
            role: "member"
          })));
        }
      }
      async deleteBoard(userId, id) {
        if (!await this.permissionService.canAccessBoard(userId, id)) {
          throw new Error(`Board ${id} not found or unauthorized access`);
        }
        const [board] = await db.delete(boards).where(eq3(boards.id, id)).returning();
        if (!board) {
          throw new Error(`Board ${id} not found`);
        }
      }
      async archiveBoard(userId, id) {
        if (!await this.permissionService.canAccessBoard(userId, id)) {
          throw new Error(`Board ${id} not found or unauthorized access`);
        }
        const [board] = await db.update(boards).set({ archived: true }).where(eq3(boards.id, id)).returning();
        if (!board) {
          throw new Error(`Board ${id} not found`);
        }
        await this.createActivityLog({
          action: "update",
          details: `Board "${board.title}" wurde archiviert`,
          userId,
          boardId: id,
          requiresNotification: true,
          notificationType: "board"
        });
        return this.getBoard(userId, id);
      }
      async unarchiveBoard(userId, id) {
        if (!await this.permissionService.canAccessBoard(userId, id)) {
          throw new Error(`Board ${id} not found or unauthorized access`);
        }
        const [board] = await db.update(boards).set({ archived: false }).where(eq3(boards.id, id)).returning();
        if (!board) {
          throw new Error(`Board ${id} not found`);
        }
        await this.createActivityLog({
          action: "update",
          details: `Board "${board.title}" wurde wiederhergestellt`,
          userId,
          boardId: id,
          requiresNotification: true,
          notificationType: "board"
        });
        return this.getBoard(userId, id);
      }
      // Board permission implementations
      async createBoardMember(userId, member) {
        const [record] = await db.insert(boardMembers).values(member).returning();
        return record;
      }
      async getBoardMembers(userId, boardId) {
        const members = await db.select().from(boardMembers).where(eq3(boardMembers.boardId, boardId)).orderBy(boardMembers.invitedAt);
        return this.permissionService.filterBoardMembers(userId, members);
      }
      // Column operations
      async getColumns(userId, boardId) {
        const columnsData = await db.select().from(columns).where(eq3(columns.boardId, boardId)).orderBy(columns.order);
        return this.permissionService.filterColumns(userId, columnsData);
      }
      async createColumn(userId, insertColumn) {
        const [column] = await db.insert(columns).values(insertColumn).returning();
        return column;
      }
      async updateColumn(userId, id, updateColumn) {
        const [column] = await db.update(columns).set(updateColumn).where(eq3(columns.id, id)).returning();
        if (!column) {
          throw new Error(`Column ${id} not found`);
        }
        return column;
      }
      async deleteColumn(userId, id) {
        const [column] = await db.delete(columns).where(eq3(columns.id, id)).returning();
        if (!column) {
          throw new Error(`Column ${id} not found`);
        }
      }
      // Task operations
      async getTasks(userId, boardId) {
        const result = await pool.query(`
      SELECT t.*, 
        ARRAY_AGG(DISTINCT JSONB_BUILD_OBJECT(
          'id', u.id, 
          'username', u.username, 
          'avatarUrl', u.avatar_url
        )) FILTER (WHERE u.id IS NOT NULL) AS assigned_users
      FROM tasks t
      LEFT JOIN users u ON u.id = ANY(t.assigned_user_ids)
      WHERE t.board_id = $1
      GROUP BY t.id
      ORDER BY t."order"
    `, [boardId]);
        return result.rows.map((task) => {
          const assignedUsers = task.assigned_users || [];
          return {
            id: task.id,
            title: task.title,
            description: task.description,
            richDescription: task.rich_description,
            status: task.status,
            order: task.order,
            boardId: task.board_id,
            columnId: task.column_id,
            priority: task.priority,
            labels: Array.isArray(task.labels) ? task.labels : [],
            startDate: task.start_date,
            dueDate: task.due_date,
            archived: task.archived,
            assignedUserIds: Array.isArray(task.assigned_user_ids) ? task.assigned_user_ids : [],
            assignedTeamId: task.assigned_team_id,
            assignedAt: task.assigned_at,
            attachments: Array.isArray(task.attachments) ? task.attachments : [],
            createdAt: task.created_at,
            updatedAt: task.updated_at,
            checklist: Array.isArray(task.checklist) ? task.checklist : [],
            // Füge die Benutzerinformationen hinzu
            assignedUsers
          };
        });
      }
      async getUserAssignedTasks(userId) {
        try {
          console.log(`Fetching tasks assigned to user: ${userId}`);
          const result = await pool.query(`
        SELECT t.*, 
          ARRAY_AGG(DISTINCT JSONB_BUILD_OBJECT(
            'id', u.id, 
            'username', u.username, 
            'avatarUrl', u.avatar_url
          )) FILTER (WHERE u.id IS NOT NULL) AS assigned_users
        FROM tasks t
        LEFT JOIN users u ON u.id = ANY(t.assigned_user_ids)
        WHERE $1 = ANY(t.assigned_user_ids)
        GROUP BY t.id
        ORDER BY t.board_id NULLS FIRST, t.column_id NULLS FIRST, t."order"
      `, [userId]);
          const userTasks = result.rows;
          console.log(`Found ${userTasks.length} tasks assigned to user ${userId}`);
          const enrichedTasks = await Promise.all(userTasks.map(async (task) => {
            const checklist = Array.isArray(task.checklist) ? task.checklist : [];
            const assignedUserIds = Array.isArray(task.assigned_user_ids) ? task.assigned_user_ids : [];
            const labels = Array.isArray(task.labels) ? task.labels : [];
            const attachments = Array.isArray(task.attachments) ? task.attachments : [];
            const assignedUsers = task.assigned_users || [];
            let board = null;
            let column = null;
            let project = null;
            if (task.board_id !== null) {
              const [boardData] = await db.select({
                id: boards.id,
                title: boards.title,
                projectId: boards.project_id
              }).from(boards).where(eq3(boards.id, task.board_id));
              board = boardData;
              if (task.column_id !== null) {
                const [columnData] = await db.select({
                  id: columns.id,
                  title: columns.title
                }).from(columns).where(eq3(columns.id, task.column_id));
                column = columnData;
              }
              if (board && board.projectId) {
                const [projectData] = await db.select({
                  id: projects.id,
                  title: projects.title
                }).from(projects).where(eq3(projects.id, board.projectId));
                project = projectData;
              }
            }
            let assignedUser = null;
            if (assignedUserIds.includes(userId)) {
              const userData = assignedUsers.find((u) => u.id === userId);
              if (userData) {
                assignedUser = {
                  id: userData.id,
                  username: userData.username,
                  email: userData.email || "",
                  // E-Mail ist möglicherweise nicht in assignedUsers enthalten
                  avatarUrl: userData.avatarUrl
                };
              }
            }
            return {
              id: task.id,
              title: task.title,
              description: task.description,
              richDescription: task.rich_description,
              status: task.status,
              priority: task.priority,
              labels,
              checklist,
              columnId: task.column_id,
              boardId: task.board_id,
              dueDate: task.due_date,
              order: task.order,
              assignedUserIds,
              assignedTeamId: task.assigned_team_id,
              archived: task.archived,
              attachments,
              board,
              column,
              project,
              assignedUser,
              assignedUsers,
              // Markiere persönliche Aufgaben
              isPersonal: task.board_id === null
            };
          }));
          const accessibleTasks = await Promise.all(
            enrichedTasks.map(async (task) => {
              if (task.boardId === null) {
                return task;
              }
              const hasAccess = await this.permissionService.canAccessBoard(userId, task.boardId);
              return hasAccess ? task : null;
            })
          );
          return accessibleTasks.filter((task) => task !== null);
        } catch (error) {
          console.error("Error in getUserAssignedTasks:", error);
          throw error;
        }
      }
      async createTask(userId, insertTask) {
        let assignedUserIds = [...insertTask.assignedUserIds || []];
        if (!assignedUserIds.includes(userId)) {
          assignedUserIds.push(userId);
        }
        const [task] = await db.insert(tasks).values({
          ...insertTask,
          checklist: insertTask.checklist || [],
          assignedUserIds
        }).returning();
        const usersResult = await db.select({
          id: users.id,
          username: users.username,
          avatarUrl: users.avatarUrl
        }).from(users).where(inArray3(users.id, assignedUserIds));
        return {
          ...task,
          checklist: Array.isArray(task.checklist) ? task.checklist : [],
          assignedUserIds: Array.isArray(task.assignedUserIds) ? task.assignedUserIds : [],
          assignedUsers: usersResult
        };
      }
      async updateTask(userId, id, updateTask) {
        console.log("Aktualisiere Task mit ID:", id, "Anh\xE4nge:", updateTask.attachments);
        let assignedUserIds = [];
        if (updateTask.assignedUserIds) {
          if (Array.isArray(updateTask.assignedUserIds)) {
            assignedUserIds = [...updateTask.assignedUserIds];
          } else if (typeof updateTask.assignedUserIds === "string") {
            try {
              assignedUserIds = JSON.parse(updateTask.assignedUserIds);
            } catch (e) {
              assignedUserIds = [parseInt(updateTask.assignedUserIds, 10)];
            }
          } else if (typeof updateTask.assignedUserIds === "number") {
            assignedUserIds = [updateTask.assignedUserIds];
          }
        }
        if (!assignedUserIds.includes(userId)) {
          assignedUserIds.push(userId);
        }
        let labels = [];
        if (updateTask.labels) {
          if (Array.isArray(updateTask.labels)) {
            labels = updateTask.labels;
          } else if (typeof updateTask.labels === "string") {
            try {
              labels = JSON.parse(updateTask.labels);
            } catch (e) {
              labels = [updateTask.labels];
            }
          }
        }
        let checklist = [];
        if (updateTask.checklist) {
          if (Array.isArray(updateTask.checklist)) {
            checklist = updateTask.checklist;
          } else if (typeof updateTask.checklist === "string") {
            try {
              checklist = JSON.parse(updateTask.checklist);
            } catch (e) {
              checklist = [updateTask.checklist];
            }
          }
        }
        let attachments = [];
        if (updateTask.attachments) {
          if (Array.isArray(updateTask.attachments)) {
            attachments = updateTask.attachments;
          } else if (typeof updateTask.attachments === "string") {
            try {
              attachments = JSON.parse(updateTask.attachments);
            } catch (e) {
              attachments = [updateTask.attachments];
            }
          }
        }
        const cleanedUpdateTask = { ...updateTask };
        delete cleanedUpdateTask.assignedUserIds;
        delete cleanedUpdateTask.labels;
        delete cleanedUpdateTask.checklist;
        delete cleanedUpdateTask.attachments;
        const updatedData = {
          ...cleanedUpdateTask,
          labels,
          checklist,
          assignedUserIds,
          attachments
        };
        const [task] = await db.update(tasks).set(updatedData).where(eq3(tasks.id, id)).returning();
        if (!task) {
          throw new Error(`Task ${id} not found`);
        }
        const usersResult = await db.select({
          id: users.id,
          username: users.username,
          avatarUrl: users.avatarUrl
        }).from(users).where(sql3`${users.id} = ANY(${task.assignedUserIds})`);
        return {
          ...task,
          checklist: Array.isArray(task.checklist) ? task.checklist : [],
          assignedUserIds: Array.isArray(task.assignedUserIds) ? task.assignedUserIds : [],
          attachments: Array.isArray(task.attachments) ? task.attachments : [],
          assignedUsers: usersResult || []
        };
      }
      async deleteTask(userId, id) {
        const [task] = await db.delete(tasks).where(eq3(tasks.id, id)).returning();
        if (!task) {
          throw new Error(`Task ${id} not found`);
        }
      }
      // Comment operations
      async getComments(userId, taskId) {
        const commentsData = await db.select().from(comments).where(eq3(comments.taskId, taskId)).orderBy(desc2(comments.createdAt));
        return this.permissionService.filterComments(userId, commentsData);
      }
      async createComment(userId, insertComment) {
        const [task] = await db.select().from(tasks).where(eq3(tasks.id, insertComment.taskId));
        if (!task) {
          throw new Error(`Task ${insertComment.taskId} not found`);
        }
        const [comment] = await db.insert(comments).values(insertComment).returning();
        return comment;
      }
      // Checklist operations
      async getChecklistItems(userId, taskId) {
        const checklistItemsData = await db.select().from(checklistItems).where(eq3(checklistItems.taskId, taskId)).orderBy(checklistItems.itemOrder);
        return this.permissionService.filterChecklistItems(userId, checklistItemsData);
      }
      async createChecklistItem(userId, insertItem) {
        const [task] = await db.select().from(tasks).where(eq3(tasks.id, insertItem.taskId));
        if (!task) {
          throw new Error(`Task ${insertItem.taskId} not found`);
        }
        const [item] = await db.insert(checklistItems).values(insertItem).returning();
        return item;
      }
      async updateChecklistItem(userId, id, updateItem) {
        const [item] = await db.update(checklistItems).set(updateItem).where(eq3(checklistItems.id, id)).returning();
        if (!item) {
          throw new Error(`Checklist item ${id} not found`);
        }
        return item;
      }
      async deleteChecklistItem(userId, id) {
        const [item] = await db.delete(checklistItems).where(eq3(checklistItems.id, id)).returning();
        if (!item) {
          throw new Error(`Checklist item ${id} not found`);
        }
      }
      // Activity Log operations
      async getActivityLogs(userId) {
        return await this.permissionService.getVisibleActivityLogs(userId);
      }
      async createActivityLog(log2) {
        try {
          const values = [
            log2.action,
            log2.details || null,
            log2.userId || null,
            log2.boardId || null,
            log2.projectId || null,
            log2.objectiveId || null,
            log2.taskId || null,
            log2.teamId || null,
            log2.targetUserId || null,
            log2.requiresNotification || false,
            log2.notificationSent || false,
            log2.notificationType || null
          ];
          console.log("Creating activity log with:", log2);
          const result = await pool.query(`
        INSERT INTO activity_logs 
        (action, details, user_id, board_id, project_id, objective_id, task_id, team_id, target_user_id, requires_notification, notification_sent, notification_type, created_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, NOW())
        RETURNING *
      `, values);
          const newLog = result.rows[0];
          return newLog;
        } catch (error) {
          console.error("Error creating activity log:", error);
          throw error;
        }
      }
      // User operations
      async getUser(userId, id) {
        const [user] = await db.select().from(users).where(eq3(users.id, id));
        if (!user || !await this.permissionService.canAccessUser(userId, id)) {
          throw new Error(`User ${id} not found or unauthorized access`);
        }
        return user;
      }
      async getUserByUsername(userId, username) {
        const [user] = await db.select().from(users).where(eq3(users.username, username));
        return user || null;
      }
      async getUserByEmail(userId, email) {
        const [user] = await db.select().from(users).where(eq3(users.email, email));
        return user || null;
      }
      async createUser(userId, userData) {
        const [user] = await db.insert(users).values(userData).returning();
        return user;
      }
      async updateUser(userId, id, data) {
        if (!await this.permissionService.canAccessUser(userId, id)) {
          throw new Error(`User ${id} not found or unauthorized access`);
        }
        const [user] = await db.update(users).set(data).where(eq3(users.id, id)).returning();
        if (!user) {
          throw new Error(`User ${id} not found`);
        }
        return user;
      }
      async updateUserPassword(userId, id, passwordHash) {
        if (!await this.permissionService.canAccessUser(userId, id)) {
          throw new Error(`User ${id} not found or unauthorized access`);
        }
        const [user] = await db.update(users).set({ passwordHash }).where(eq3(users.id, id)).returning();
        if (!user) {
          throw new Error(`User ${id} not found`);
        }
      }
      async updateUserEmail(userId, id, email) {
        if (!await this.permissionService.canAccessUser(userId, id)) {
          throw new Error(`User ${id} not found or unauthorized access`);
        }
        const existingUser = await this.getUserByEmail(userId, email);
        if (existingUser && existingUser.id !== id) {
          throw new Error("Email is already taken");
        }
        const [user] = await db.update(users).set({ email }).where(eq3(users.id, id)).returning();
        if (!user) {
          throw new Error(`User ${id} not found`);
        }
        return user;
      }
      async getUsers(userId) {
        const usersData = await db.select().from(users);
        return this.permissionService.filterUsers(userId, usersData);
      }
      // Productivity metrics implementations
      async getUserProductivityMetrics(userId, days) {
        const startDate = /* @__PURE__ */ new Date();
        startDate.setDate(startDate.getDate() - days);
        return await db.select().from(userProductivityMetrics).where(
          and3(
            eq3(userProductivityMetrics.userId, userId),
            gte(userProductivityMetrics.date, startDate)
          )
        ).orderBy(userProductivityMetrics.date);
      }
      async createUserProductivityMetrics(userId, metrics) {
        const [result] = await db.insert(userProductivityMetrics).values(metrics).returning();
        return result;
      }
      async updateOrCreateDailyProductivityMetrics(userId, update) {
        const today = /* @__PURE__ */ new Date();
        today.setHours(0, 0, 0, 0);
        const existingMetrics = await db.select().from(userProductivityMetrics).where(
          and3(
            eq3(userProductivityMetrics.userId, userId),
            sql3`DATE(${userProductivityMetrics.date}) = DATE(${today})`
          )
        );
        if (existingMetrics.length > 0) {
          const current = existingMetrics[0];
          await db.update(userProductivityMetrics).set({
            tasksCreated: update.tasksCreated !== void 0 ? (current.tasksCreated || 0) + update.tasksCreated : current.tasksCreated,
            tasksCompleted: update.tasksCompleted !== void 0 ? (current.tasksCompleted || 0) + update.tasksCompleted : current.tasksCompleted
          }).where(eq3(userProductivityMetrics.id, current.id));
        } else {
          await db.insert(userProductivityMetrics).values({
            userId,
            date: today.toISOString(),
            tasksCreated: update.tasksCreated || 0,
            tasksCompleted: update.tasksCompleted || 0,
            timeSpentMinutes: 0,
            objectivesAchieved: 0
          });
        }
      }
      async getTaskDistribution(userId) {
        const result = await db.execute(sql3`
      WITH user_tasks AS (
        SELECT DISTINCT t.id, t.status
        FROM tasks t
        LEFT JOIN task_state_changes tsc ON t.id = tsc.task_id
        WHERE t.assigned_user_ids @> ARRAY[${userId}]::int[]
        OR tsc.user_id = ${userId}
      )
      SELECT status as name, COUNT(*) as value
      FROM user_tasks
      GROUP BY status
    `);
        return Array.isArray(result) ? result : result.rows || [];
      }
      async getProjectActivities(userId) {
        const result = await db.execute(sql3`
      WITH user_tasks AS (
        SELECT 
          t.id,
          t.board_id,
          b.project_id,
          p.title as project_name
        FROM tasks t
        LEFT JOIN boards b ON t.board_id = b.id
        LEFT JOIN projects p ON b.project_id = p.id
        WHERE t.assigned_user_ids @> ARRAY[${userId}]::int[]
      )
      SELECT 
        COALESCE(project_name, 'Ohne Projekt') as name, 
        COUNT(id) as tasks
      FROM user_tasks
      GROUP BY project_name
      ORDER BY tasks DESC
      LIMIT 5
    `);
        return Array.isArray(result) ? result : result.rows || [];
      }
      // Task time tracking implementations
      async createTaskTimeEntry(userId, entry) {
        const [result] = await db.insert(taskTimeEntries).values(entry).returning();
        return result;
      }
      async updateTaskTimeEntry(userId, id, endTime) {
        const [result] = await db.update(taskTimeEntries).set({
          endTime,
          durationMinutes: sql3`EXTRACT(EPOCH FROM ${endTime}::timestamp - start_time) / 60`
        }).where(eq3(taskTimeEntries.id, id)).returning();
        if (!result) {
          throw new Error(`Task time entry ${id} not found`);
        }
        return result;
      }
      // Task state change implementations
      async createTaskStateChange(userId, change) {
        const [result] = await db.insert(taskStateChanges).values(change).returning();
        return result;
      }
      // Team operations
      async getTeams(userId) {
        const teamsData = await db.select({
          id: teams.id,
          name: teams.name,
          description: teams.description,
          companyId: teams.companyId,
          creatorId: teams.creatorId,
          createdAt: teams.createdAt
        }).from(teams);
        return this.permissionService.filterTeams(userId, teamsData);
      }
      async getTeam(userId, id) {
        const [team] = await db.select({
          id: teams.id,
          name: teams.name,
          description: teams.description,
          companyId: teams.companyId,
          creatorId: teams.creatorId,
          createdAt: teams.createdAt
        }).from(teams).where(eq3(teams.id, id));
        if (!team || !await this.permissionService.canAccessTeam(userId, id)) {
          throw new Error(`Team ${id} not found or unauthorized access`);
        }
        return team;
      }
      async createTeam(userId, insertTeam) {
        const { member_ids, ...teamData } = insertTeam;
        const fullTeamData = {
          ...teamData,
          creatorId: userId
        };
        const [team] = await db.insert(teams).values(fullTeamData).returning();
        if (member_ids && member_ids.length > 0) {
          const memberEntries = member_ids.map((id) => ({
            teamId: team.id,
            userId: parseInt(id),
            role: "member"
          }));
          await db.insert(teamMembers).values(memberEntries);
        }
        return team;
      }
      async updateTeam(userId, id, updateTeam) {
        const { member_ids, ...teamData } = updateTeam;
        const [existingTeam] = await db.select({
          id: teams.id,
          name: teams.name,
          description: teams.description,
          companyId: teams.companyId,
          creatorId: teams.creatorId,
          createdAt: teams.createdAt
        }).from(teams).where(eq3(teams.id, id));
        if (!existingTeam) {
          throw new Error(`Team ${id} not found`);
        }
        if (existingTeam.creatorId !== userId) {
          throw new Error("Nur der Ersteller des Teams kann das Team bearbeiten");
        }
        const [team] = await db.update(teams).set(teamData).where(eq3(teams.id, id)).returning();
        if (member_ids) {
          await db.delete(teamMembers).where(eq3(teamMembers.teamId, id));
          if (member_ids.length > 0) {
            const memberEntries = member_ids.map((memberId) => ({
              teamId: id,
              userId: parseInt(memberId),
              role: "member"
            }));
            await db.insert(teamMembers).values(memberEntries);
          }
        }
        return team;
      }
      async deleteTeam(userId, id) {
        const [existingTeam] = await db.select({
          id: teams.id,
          name: teams.name,
          description: teams.description,
          companyId: teams.companyId,
          creatorId: teams.creatorId,
          createdAt: teams.createdAt
        }).from(teams).where(eq3(teams.id, id));
        if (!existingTeam) {
          throw new Error(`Team ${id} not found`);
        }
        if (existingTeam.creatorId !== userId) {
          throw new Error("Nur der Ersteller des Teams kann das Team l\xF6schen");
        }
        await db.delete(teamMembers).where(eq3(teamMembers.teamId, id));
        const [team] = await db.delete(teams).where(eq3(teams.id, id)).returning();
        if (!team) {
          throw new Error(`Team ${id} not found`);
        }
      }
      // Team member operations
      async getTeamMembers(userId) {
        const [user] = await db.select().from(users).where(eq3(users.id, userId));
        if (!user?.companyId) {
          return [];
        }
        const companyTeams = await db.select({
          id: teams.id,
          name: teams.name,
          description: teams.description,
          companyId: teams.companyId,
          creatorId: teams.creatorId,
          createdAt: teams.createdAt
        }).from(teams).where(eq3(teams.companyId, user.companyId));
        const allTeamMembers = await db.select({
          id: teamMembers.id,
          teamId: teamMembers.teamId,
          userId: teamMembers.userId,
          role: teamMembers.role
        }).from(teamMembers).where(inArray3(teamMembers.teamId, companyTeams.map((t) => t.id)));
        return allTeamMembers;
      }
      async toggleProjectFavorite(userId, id) {
        try {
          if (!await this.permissionService.canAccessProject(userId, id)) {
            throw new Error(`Project ${id} not found or unauthorized access`);
          }
          const [project] = await db.select().from(projects).where(eq3(projects.id, id));
          if (!project) {
            throw new Error(`Project ${id} not found`);
          }
          const favorites = await db.select().from(userFavoriteProjects).where(and3(
            eq3(userFavoriteProjects.userId, userId),
            eq3(userFavoriteProjects.projectId, id)
          ));
          const isFavorite = favorites.length > 0;
          if (isFavorite) {
            await db.delete(userFavoriteProjects).where(and3(
              eq3(userFavoriteProjects.userId, userId),
              eq3(userFavoriteProjects.projectId, id)
            ));
          } else {
            await db.insert(userFavoriteProjects).values({
              userId,
              projectId: id
            });
          }
          return {
            ...project,
            isFavorite: !isFavorite
          };
        } catch (error) {
          console.error("Error toggling project favorite:", error);
          throw error;
        }
      }
      async toggleBoardFavorite(userId, id) {
        try {
          if (!await this.permissionService.canAccessBoard(userId, id)) {
            throw new Error(`Board ${id} not found or unauthorized access`);
          }
          const [board] = await db.select().from(boards).where(eq3(boards.id, id));
          if (!board) {
            throw new Error(`Board ${id} not found`);
          }
          const favorites = await db.select().from(userFavoriteBoards).where(and3(
            eq3(userFavoriteBoards.userId, userId),
            eq3(userFavoriteBoards.boardId, id)
          ));
          const isFavorite = favorites.length > 0;
          if (isFavorite) {
            await db.delete(userFavoriteBoards).where(and3(
              eq3(userFavoriteBoards.userId, userId),
              eq3(userFavoriteBoards.boardId, id)
            ));
          } else {
            await db.insert(userFavoriteBoards).values({
              userId,
              boardId: id
            });
          }
          return {
            ...board,
            is_favorite: !isFavorite
          };
        } catch (error) {
          console.error("Error toggling board favorite:", error);
          throw error;
        }
      }
      async toggleObjectiveFavorite(userId, id) {
        try {
          if (!await this.permissionService.canAccessObjective(userId, id)) {
            throw new Error(`Objective ${id} not found or unauthorized access`);
          }
          const [objective] = await db.select().from(objectives).where(eq3(objectives.id, id));
          if (!objective) {
            throw new Error(`Objective ${id} not found`);
          }
          const favorites = await db.select().from(userFavoriteObjectives).where(and3(
            eq3(userFavoriteObjectives.userId, userId),
            eq3(userFavoriteObjectives.objectiveId, id)
          ));
          const isFavorite = favorites.length > 0;
          if (isFavorite) {
            await db.delete(userFavoriteObjectives).where(and3(
              eq3(userFavoriteObjectives.userId, userId),
              eq3(userFavoriteObjectives.objectiveId, id)
            ));
          } else {
            await db.insert(userFavoriteObjectives).values({
              userId,
              objectiveId: id
            });
          }
          return {
            ...objective,
            isFavorite: !isFavorite
          };
        } catch (error) {
          console.error("Error toggling objective favorite:", error);
          throw error;
        }
      }
      async createObjective(userId, insertObj) {
        try {
          let userIds = insertObj.userIds || [];
          if (!userIds.includes(userId) && userId) {
            userIds = [...userIds, userId];
          }
          const [objective] = await db.insert(objectives).values({
            ...insertObj,
            progress: 0,
            creatorId: insertObj.creatorId,
            userIds,
            isFavorite: false
          }).returning();
          if (!objective) {
            throw new Error("Failed to create objective - no data returned");
          }
          return objective;
        } catch (error) {
          console.error("Error in createObjective:", error);
          throw error;
        }
      }
      // Company operations
      async getCompany(userId, id) {
        try {
          const canAccess = await this.permissionService.canAccessCompany(userId, id);
          if (!canAccess) {
            throw new Error(`Unternehmen ${id} nicht gefunden oder keine Zugriffsberechtigung`);
          }
          const [company] = await db.select().from(companies).where(eq3(companies.id, id));
          if (!company) {
            throw new Error(`Unternehmen ${id} nicht gefunden`);
          }
          return company;
        } catch (error) {
          console.error("Error in getCompany:", error);
          throw error;
        }
      }
      async getCurrentUserCompany(userId) {
        try {
          console.log(`[storage] Fetching company for user ID: ${userId}`);
          if (!userId) {
            console.log("[storage] User ID is missing, returning null");
            return null;
          }
          console.log(`[storage] Querying user with ID: ${userId}`);
          const userResult = await db.select().from(users).where(eq3(users.id, userId));
          console.log(`[storage] User query result:`, userResult);
          if (!userResult || userResult.length === 0) {
            console.log(`[storage] User with ID ${userId} not found`);
            return null;
          }
          const user = userResult[0];
          if (!user.companyId) {
            console.log(`[storage] User has no company ID assigned`);
            return null;
          }
          console.log(`[storage] User belongs to company ID: ${user.companyId}`);
          console.log(`[storage] Querying company with ID: ${user.companyId}`);
          const companyResult = await db.select({
            id: companies.id,
            name: companies.name,
            description: companies.description,
            inviteCode: companies.inviteCode,
            createdAt: companies.createdAt
          }).from(companies).where(eq3(companies.id, user.companyId));
          console.log(`[storage] Company query result:`, companyResult);
          if (!companyResult || companyResult.length === 0) {
            console.log(`[storage] Company with ID ${user.companyId} not found`);
            return null;
          }
          const company = companyResult[0];
          console.log(`[storage] Returning company:`, company);
          return company;
        } catch (error) {
          console.error("[storage] Error in getCurrentUserCompany:", error);
          throw new Error(`Fehler beim Abrufen des Unternehmens: ${error instanceof Error ? error.message : String(error)}`);
        }
      }
      async getCompanyMembers(userId, companyId) {
        try {
          const canAccess = await this.permissionService.canAccessCompany(userId, companyId);
          if (!canAccess) {
            throw new Error(`Unternehmen ${companyId} nicht gefunden oder keine Zugriffsberechtigung`);
          }
          const members = await db.select({
            id: users.id,
            username: users.username,
            email: users.email,
            avatarUrl: users.avatarUrl,
            isCompanyAdmin: users.isCompanyAdmin,
            createdAt: users.createdAt
          }).from(users).where(
            and3(
              eq3(users.companyId, companyId),
              eq3(users.isActive, true)
              // Nur aktivierte Benutzer anzeigen
            )
          );
          return members;
        } catch (error) {
          console.error("Error in getCompanyMembers:", error);
          throw error;
        }
      }
      async updateUserCompanyRole(userId, targetUserId, isAdmin) {
        try {
          const [currentUser] = await db.select().from(users).where(eq3(users.id, userId));
          if (!currentUser || !currentUser.companyId || !currentUser.isCompanyAdmin) {
            throw new Error("Nur Unternehmensadministratoren k\xF6nnen Rollen \xE4ndern");
          }
          const [targetUser] = await db.select().from(users).where(eq3(users.id, targetUserId));
          if (!targetUser || targetUser.companyId !== currentUser.companyId) {
            throw new Error("Zielbenutzer nicht gefunden oder nicht im selben Unternehmen");
          }
          if (!targetUser.isActive) {
            throw new Error("Benutzer muss erst aktiviert werden, bevor er zum Administrator gemacht werden kann");
          }
          const [updatedUser] = await db.update(users).set({ isCompanyAdmin: isAdmin }).where(eq3(users.id, targetUserId)).returning();
          return updatedUser;
        } catch (error) {
          console.error("Error in updateUserCompanyRole:", error);
          throw error;
        }
      }
      async generateCompanyInviteCode(userId, companyId) {
        try {
          const [currentUser] = await db.select().from(users).where(eq3(users.id, userId));
          if (!currentUser || !currentUser.companyId || !currentUser.isCompanyAdmin) {
            throw new Error("Nur Unternehmensadministratoren k\xF6nnen Einladungscodes generieren");
          }
          if (currentUser.companyId !== companyId) {
            throw new Error("Sie k\xF6nnen nur f\xFCr Ihr eigenes Unternehmen Einladungscodes generieren");
          }
          const inviteCode = Math.random().toString(36).substring(2, 10).toUpperCase();
          const [updatedCompany] = await db.update(companies).set({ inviteCode }).where(eq3(companies.id, companyId)).returning();
          return updatedCompany.inviteCode;
        } catch (error) {
          console.error("Error in generateCompanyInviteCode:", error);
          throw error;
        }
      }
      async joinCompanyWithInviteCode(userId, inviteCode) {
        try {
          const [company] = await db.select().from(companies).where(eq3(companies.inviteCode, inviteCode));
          if (!company) {
            throw new Error("Ung\xFCltiger Einladungscode");
          }
          const [updatedUser] = await db.update(users).set({ companyId: company.id }).where(eq3(users.id, userId)).returning();
          return company;
        } catch (error) {
          console.error("Error in joinCompanyWithInviteCode:", error);
          throw error;
        }
      }
      async createCompany(userId, companyData) {
        try {
          const [user] = await db.select().from(users).where(eq3(users.id, userId));
          if (!user) {
            throw new Error("Benutzer nicht gefunden");
          }
          if (user.subscriptionTier === "free") {
            throw new Error("Die Erstellung eines Unternehmens erfordert mindestens ein Basic-Abonnement");
          }
          if (user.companyId) {
            throw new Error("Sie sind bereits Mitglied eines Unternehmens");
          }
          const inviteCode = Math.random().toString(36).substring(2, 10).toUpperCase();
          const [company] = await db.insert(companies).values({
            name: companyData.name,
            description: companyData.description || null,
            inviteCode: inviteCode || companyData.inviteCode
          }).returning();
          if (!company) {
            throw new Error("Fehler beim Erstellen des Unternehmens");
          }
          await db.update(users).set({
            companyId: company.id,
            isCompanyAdmin: true
          }).where(eq3(users.id, userId)).execute();
          return company;
        } catch (error) {
          console.error("Error in createCompany:", error);
          throw error;
        }
      }
      // Meeting Protocol operations
      async getMeetingProtocolsByTeam(userId, teamId) {
        try {
          console.log(`Fetching meeting protocols for team ${teamId} and user ${userId}`);
          if (!await this.permissionService.canAccessTeam(userId, teamId)) {
            throw new Error(`Team ${teamId} not found or unauthorized access`);
          }
          const protocolResults = await db.select().from(meetingProtocols).where(eq3(meetingProtocols.teamId, teamId)).orderBy(desc2(meetingProtocols.date));
          const processedProtocols = await Promise.all(protocolResults.map(async (protocol) => {
            const [creator] = await db.select({
              id: users.id,
              username: users.username,
              email: users.email,
              avatarUrl: users.avatarUrl
            }).from(users).where(eq3(users.id, protocol.creatorId));
            let participants = [];
            if (protocol.participants && protocol.participants.length > 0) {
              const participantIds = protocol.participants.map((p) => parseInt(p));
              participants = await db.select({
                id: users.id,
                username: users.username,
                email: users.email,
                avatarUrl: users.avatarUrl
              }).from(users).where(inArray3(users.id, participantIds));
            }
            let teamParticipantDetails = [];
            if (protocol.teamParticipants && protocol.teamParticipants.length > 0) {
              teamParticipantDetails = await db.select({
                id: teams.id,
                name: teams.name,
                description: teams.description
              }).from(teams).where(inArray3(teams.id, protocol.teamParticipants));
            }
            return {
              ...protocol,
              creator,
              participantDetails: participants,
              teamParticipantDetails
            };
          }));
          return processedProtocols;
        } catch (error) {
          console.error("Error in getMeetingProtocolsByTeam:", error);
          throw error;
        }
      }
      async getMeetingProtocolsByProject(userId, projectId) {
        try {
          console.log(`Fetching meeting protocols for project ${projectId} and user ${userId}`);
          if (!await this.permissionService.canAccessProject(userId, projectId)) {
            throw new Error(`Project ${projectId} not found or unauthorized access`);
          }
          const protocolResults = await db.select().from(meetingProtocols).where(eq3(meetingProtocols.projectId, projectId)).orderBy(desc2(meetingProtocols.date));
          const processedProtocols = await Promise.all(protocolResults.map(async (protocol) => {
            const [creator] = await db.select({
              id: users.id,
              username: users.username,
              email: users.email,
              avatarUrl: users.avatarUrl
            }).from(users).where(eq3(users.id, protocol.creatorId));
            let participants = [];
            if (protocol.participants && protocol.participants.length > 0) {
              const participantIds = protocol.participants.map((p) => parseInt(p));
              participants = await db.select({
                id: users.id,
                username: users.username,
                email: users.email,
                avatarUrl: users.avatarUrl
              }).from(users).where(inArray3(users.id, participantIds));
            }
            let teamParticipantDetails = [];
            if (protocol.teamParticipants && protocol.teamParticipants.length > 0) {
              teamParticipantDetails = await db.select({
                id: teams.id,
                name: teams.name,
                description: teams.description
              }).from(teams).where(inArray3(teams.id, protocol.teamParticipants));
            }
            return {
              ...protocol,
              creator,
              participantDetails: participants,
              teamParticipantDetails
            };
          }));
          return processedProtocols;
        } catch (error) {
          console.error("Error in getMeetingProtocolsByProject:", error);
          throw error;
        }
      }
      async getMeetingProtocolsByObjective(userId, objectiveId) {
        try {
          console.log(`Fetching meeting protocols for objective ${objectiveId} and user ${userId}`);
          if (!await this.permissionService.canAccessObjective(userId, objectiveId)) {
            throw new Error(`Objective ${objectiveId} not found or unauthorized access`);
          }
          const protocolResults = await db.select().from(meetingProtocols).where(eq3(meetingProtocols.objectiveId, objectiveId)).orderBy(desc2(meetingProtocols.date));
          const processedProtocols = await Promise.all(protocolResults.map(async (protocol) => {
            const [creator] = await db.select({
              id: users.id,
              username: users.username,
              email: users.email,
              avatarUrl: users.avatarUrl
            }).from(users).where(eq3(users.id, protocol.creatorId));
            let participants = [];
            if (protocol.participants && protocol.participants.length > 0) {
              const participantIds = protocol.participants.map((p) => parseInt(p));
              participants = await db.select({
                id: users.id,
                username: users.username,
                email: users.email,
                avatarUrl: users.avatarUrl
              }).from(users).where(inArray3(users.id, participantIds));
            }
            let teamParticipantDetails = [];
            if (protocol.teamParticipants && protocol.teamParticipants.length > 0) {
              teamParticipantDetails = await db.select({
                id: teams.id,
                name: teams.name,
                description: teams.description
              }).from(teams).where(inArray3(teams.id, protocol.teamParticipants));
            }
            return {
              ...protocol,
              creator,
              participantDetails: participants,
              teamParticipantDetails
            };
          }));
          return processedProtocols;
        } catch (error) {
          console.error("Error in getMeetingProtocolsByObjective:", error);
          throw error;
        }
      }
      async getMeetingProtocol(userId, id) {
        try {
          console.log(`Fetching meeting protocol ${id} for user ${userId}`);
          const [protocol] = await db.select().from(meetingProtocols).where(eq3(meetingProtocols.id, id));
          if (!protocol) {
            throw new Error(`Meeting protocol ${id} not found`);
          }
          let hasAccess = false;
          if (protocol.teamId) {
            hasAccess = await this.permissionService.canAccessTeam(userId, protocol.teamId);
          } else if (protocol.projectId) {
            hasAccess = await this.permissionService.canAccessProject(userId, protocol.projectId);
          } else if (protocol.objectiveId) {
            hasAccess = await this.permissionService.canAccessObjective(userId, protocol.objectiveId);
          }
          if (!hasAccess) {
            throw new Error(`Unauthorized access to meeting protocol ${id}`);
          }
          const [creator] = await db.select({
            id: users.id,
            username: users.username,
            email: users.email,
            avatarUrl: users.avatarUrl
          }).from(users).where(eq3(users.id, protocol.creatorId));
          let participants = [];
          if (protocol.participants && protocol.participants.length > 0) {
            const participantIds = protocol.participants.map((p) => parseInt(p));
            participants = await db.select({
              id: users.id,
              username: users.username,
              email: users.email,
              avatarUrl: users.avatarUrl
            }).from(users).where(inArray3(users.id, participantIds));
          }
          let teamParticipantDetails = [];
          if (protocol.teamParticipants && protocol.teamParticipants.length > 0) {
            teamParticipantDetails = await db.select({
              id: teams.id,
              name: teams.name,
              description: teams.description
            }).from(teams).where(inArray3(teams.id, protocol.teamParticipants));
          }
          return {
            ...protocol,
            creator,
            participantDetails: participants,
            teamParticipantDetails
          };
        } catch (error) {
          console.error("Error in getMeetingProtocol:", error);
          throw error;
        }
      }
      async createMeetingProtocol(userId, protocol) {
        try {
          console.log(`Creating meeting protocol for user ${userId}`);
          if (protocol.teamId && !await this.permissionService.canAccessTeam(userId, protocol.teamId)) {
            throw new Error(`Team ${protocol.teamId} not found or unauthorized access`);
          } else if (protocol.projectId && !await this.permissionService.canAccessProject(userId, protocol.projectId)) {
            throw new Error(`Project ${protocol.projectId} not found or unauthorized access`);
          } else if (protocol.objectiveId && !await this.permissionService.canAccessObjective(userId, protocol.objectiveId)) {
            throw new Error(`Objective ${protocol.objectiveId} not found or unauthorized access`);
          }
          const protocolData = {
            ...protocol,
            creatorId: userId
          };
          const [newProtocol] = await db.insert(meetingProtocols).values(protocolData).returning();
          return this.getMeetingProtocol(userId, newProtocol.id);
        } catch (error) {
          console.error("Error in createMeetingProtocol:", error);
          throw error;
        }
      }
      async updateMeetingProtocol(userId, id, updateData) {
        try {
          console.log(`Updating meeting protocol ${id} for user ${userId}`);
          const [protocol] = await db.select().from(meetingProtocols).where(eq3(meetingProtocols.id, id));
          if (!protocol) {
            throw new Error(`Meeting protocol ${id} not found`);
          }
          if (protocol.creatorId !== userId) {
            let hasAdminAccess = false;
            if (protocol.teamId) {
              const [teamMember] = await db.select().from(teamMembers).where(and3(
                eq3(teamMembers.teamId, protocol.teamId),
                eq3(teamMembers.userId, userId),
                eq3(teamMembers.role, "admin")
              ));
              hasAdminAccess = !!teamMember;
            } else if (protocol.projectId) {
              const [project] = await db.select().from(projects).where(and3(
                eq3(projects.id, protocol.projectId),
                eq3(projects.creator_id, userId)
              ));
              hasAdminAccess = !!project;
            } else if (protocol.objectiveId) {
              const [objective] = await db.select().from(objectives).where(and3(
                eq3(objectives.id, protocol.objectiveId),
                eq3(objectives.creatorId, userId)
              ));
              hasAdminAccess = !!objective;
            }
            if (!hasAdminAccess) {
              throw new Error(`Unauthorized to update meeting protocol ${id}`);
            }
          }
          const [updatedProtocol] = await db.update(meetingProtocols).set(updateData).where(eq3(meetingProtocols.id, id)).returning();
          return this.getMeetingProtocol(userId, updatedProtocol.id);
        } catch (error) {
          console.error("Error in updateMeetingProtocol:", error);
          throw error;
        }
      }
      async deleteMeetingProtocol(userId, id) {
        try {
          console.log(`Deleting meeting protocol ${id} for user ${userId}`);
          const [protocol] = await db.select().from(meetingProtocols).where(eq3(meetingProtocols.id, id));
          if (!protocol) {
            throw new Error(`Meeting protocol ${id} not found`);
          }
          if (protocol.creatorId !== userId) {
            let hasAdminAccess = false;
            if (protocol.teamId) {
              const [teamMember] = await db.select().from(teamMembers).where(and3(
                eq3(teamMembers.teamId, protocol.teamId),
                eq3(teamMembers.userId, userId),
                eq3(teamMembers.role, "admin")
              ));
              hasAdminAccess = !!teamMember;
            } else if (protocol.projectId) {
              const [project] = await db.select().from(projects).where(and3(
                eq3(projects.id, protocol.projectId),
                eq3(projects.creator_id, userId)
              ));
              hasAdminAccess = !!project;
            } else if (protocol.objectiveId) {
              const [objective] = await db.select().from(objectives).where(and3(
                eq3(objectives.id, protocol.objectiveId),
                eq3(objectives.creatorId, userId)
              ));
              hasAdminAccess = !!objective;
            }
            if (!hasAdminAccess) {
              throw new Error(`Unauthorized to delete meeting protocol ${id}`);
            }
          }
          await db.delete(meetingProtocols).where(eq3(meetingProtocols.id, id));
        } catch (error) {
          console.error("Error in deleteMeetingProtocol:", error);
          throw error;
        }
      }
    };
    storage = new DatabaseStorage();
  }
});

// server/middleware/auth.ts
import { eq as eq4 } from "drizzle-orm";
var requireAuth, optionalAuth, requireHyperAdmin, requireCompanyAdmin;
var init_auth = __esm({
  "server/middleware/auth.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_permissions();
    requireAuth = async (req, res, next) => {
      try {
        if (!req.session || !req.session.userId) {
          console.log(`[AUTH] Unauthentifizierter Zugriff auf ${req.method} ${req.path}`);
          return res.status(401).json({ message: "Nicht authentifiziert" });
        }
        const [user] = await db.select().from(users).where(eq4(users.id, req.session.userId));
        if (!user) {
          console.log(`[AUTH] Benutzer mit ID ${req.session.userId} nicht gefunden`);
          return res.status(401).json({ message: "Benutzer nicht gefunden" });
        }
        if (user.isPaused === true) {
          console.log(`[AUTH] Zugriff verweigert: Benutzer ${user.username} (ID: ${user.id}) ist pausiert`);
          return res.status(403).json({
            message: "Ihr Konto wurde pausiert",
            reason: user.pauseReason || "Kein Grund angegeben",
            isPaused: true
          });
        }
        req.user = user;
        req.userId = user.id;
        console.log(`[AUTH] Authentifizierter Zugriff: Benutzer ${user.username} (ID: ${user.id}) auf ${req.method} ${req.path}`);
        const alwaysAllowedPaths = [
          "/api/user-profile",
          // Eigenes Profil
          "/api/auth/logout",
          // Abmelden
          "/api/dashboard",
          // Dashboard
          "/api/subscription",
          // Abonnement-Verwaltung
          "/api/subscription/update-user",
          // Benutzer-Abonnement-Update (neuer Endpunkt)
          "/api/subscription-plans",
          // Abonnement-Pläne
          "/api/auth/check",
          // Auth-Check
          "/api/notifications",
          // Benachrichtigungen
          "/api/user-tasks",
          // Persönliche Aufgaben
          "/api/all-tasks",
          // Aufgabenliste für Dashboard
          "/api/projects",
          // Projekte für Dashboard
          "/api/key-results",
          // Key Results für Dashboard
          "/api/objectives",
          // Objectives für Dashboard
          "/api/activity",
          // Aktivitäten für Dashboard
          "/api/productivity/metrics",
          // Produktivitätsmetriken für Dashboard
          "/api/user"
          // Benutzerinformationen
        ];
        const activationPendingPaths = [
          "/api/user-profile",
          "/api/auth/logout",
          "/api/auth/check",
          "/api/subscription",
          "/api/subscription/update-user",
          // Benutzer-Abonnement-Update
          "/api/subscription-plans",
          "/api/notifications",
          "/api/dashboard",
          "/api/user"
          // Notwendig für Benutzerinformationen
        ];
        const isPaymentPath = req.path.startsWith("/api/payment") || req.path.startsWith("/api/stripe");
        const isAllowedPath = alwaysAllowedPaths.some(
          (path6) => req.path === path6 || req.path.startsWith(`${path6}/`)
        );
        if (isAllowedPath || isPaymentPath) {
          return next();
        }
        const hasCompanyId = user.companyId !== null && user.companyId !== void 0;
        if (!user.isActive && hasCompanyId) {
          const isActivationPendingAllowedPath = activationPendingPaths.some(
            (path6) => req.path === path6 || req.path.startsWith(`${path6}/`)
          );
          if (isActivationPendingAllowedPath) {
            return next();
          }
          console.log(`[AUTH] Zugriff verweigert: Benutzer ${user.username} (ID: ${user.id}) hat eine Firma aber ist noch nicht aktiviert`);
          return res.status(403).json({
            message: "Ihr Konto wurde noch nicht von einem Administrator aktiviert.",
            awaitingActivation: true
          });
        }
        next();
      } catch (error) {
        console.error("Auth middleware error:", error);
        res.status(500).json({ message: "Interner Server-Fehler" });
      }
    };
    optionalAuth = async (req, res, next) => {
      try {
        if (req.session && req.session.userId) {
          const [user] = await db.select().from(users).where(eq4(users.id, req.session.userId));
          if (user) {
            if (user.isPaused === true) {
              console.log(`[AUTH-OPTIONAL] Benutzer ${user.username} (ID: ${user.id}) ist pausiert`);
              req.user = { ...user, isPaused: true };
            } else {
              req.user = user;
            }
            req.userId = user.id;
            console.log(`[AUTH-OPTIONAL] Authentifizierter Benutzer ${user.username} (ID: ${user.id}) auf ${req.method} ${req.path}`);
          } else {
            console.log(`[AUTH-OPTIONAL] Ung\xFCltige Benutzer-ID in Session: ${req.session.userId}`);
          }
        } else {
          console.log(`[AUTH-OPTIONAL] Keine Benutzer-Session f\xFCr ${req.method} ${req.path}`);
        }
        next();
      } catch (error) {
        console.error("Optional auth middleware error:", error);
        next();
      }
    };
    requireHyperAdmin = async (req, res, next) => {
      try {
        if (!req.session || !req.session.userId) {
          console.log(`[HYPER-ADMIN-AUTH] Unauthentifizierter Zugriff auf ${req.method} ${req.path}`);
          return res.status(401).json({ message: "Nicht authentifiziert" });
        }
        const [user] = await db.select().from(users).where(eq4(users.id, req.session.userId));
        if (!user) {
          console.log(`[HYPER-ADMIN-AUTH] Benutzer mit ID ${req.session.userId} nicht gefunden`);
          return res.status(401).json({ message: "Benutzer nicht gefunden" });
        }
        req.user = user;
        req.userId = user.id;
        const isHyperAdmin = await permissionService.isHyperAdmin(req.userId);
        if (!isHyperAdmin) {
          console.log(`[HYPER-ADMIN-AUTH] Zugriff verweigert: Benutzer ${user.username} (ID: ${user.id}) ist kein Hyper-Admin`);
          return res.status(403).json({ message: "Zugriff verweigert. Hyper-Admin-Rechte erforderlich." });
        }
        console.log(`[HYPER-ADMIN-AUTH] Erfolgreicher Zugriff: Hyper-Admin ${user.username} (ID: ${user.id}) auf ${req.method} ${req.path}`);
        next();
      } catch (error) {
        console.error("Hyper-Admin auth middleware error:", error);
        res.status(500).json({ message: "Interner Server-Fehler" });
      }
    };
    requireCompanyAdmin = async (req, res, next) => {
      try {
        if (!req.session || !req.session.userId) {
          console.log(`[COMPANY-ADMIN-AUTH] Unauthentifizierter Zugriff auf ${req.method} ${req.path}`);
          return res.status(401).json({ message: "Nicht authentifiziert" });
        }
        const [user] = await db.select().from(users).where(eq4(users.id, req.session.userId));
        if (!user) {
          console.log(`[COMPANY-ADMIN-AUTH] Benutzer mit ID ${req.session.userId} nicht gefunden`);
          return res.status(401).json({ message: "Benutzer nicht gefunden" });
        }
        req.user = user;
        req.userId = user.id;
        if (!user.isActive) {
          console.log(`[COMPANY-ADMIN-AUTH] Zugriff verweigert: Benutzer ${user.username} (ID: ${user.id}) ist nicht aktiv`);
          return res.status(403).json({ message: "Ihr Konto ist noch nicht aktiviert." });
        }
        if (!user.isCompanyAdmin) {
          console.log(`[COMPANY-ADMIN-AUTH] Zugriff verweigert: Benutzer ${user.username} (ID: ${user.id}) ist kein Admin`);
          return res.status(403).json({ message: "Zugriff verweigert. Admin-Rechte erforderlich." });
        }
        console.log(`[COMPANY-ADMIN-AUTH] Erfolgreicher Zugriff: Admin ${user.username} (ID: ${user.id}) auf ${req.method} ${req.path}`);
        next();
      } catch (error) {
        console.error("Company Admin auth middleware error:", error);
        res.status(500).json({ message: "Interner Server-Fehler" });
      }
    };
  }
});

// server/okrRoutes.ts
var okrRoutes_exports = {};
__export(okrRoutes_exports, {
  registerOkrRoutes: () => registerOkrRoutes
});
import { eq as eq6, and as and4 } from "drizzle-orm";
function registerOkrRoutes(app2) {
  app2.patch("/api/objectives/:id/favorite", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Ung\xFCltige Objective-ID" });
    }
    try {
      const userId = req.userId;
      console.log(`Toggling favorite for objective ${id} by user ${userId}`);
      const objective = await storage.toggleObjectiveFavorite(userId, id);
      await storage.createActivityLog({
        action: objective.isFavorite ? "favorite" : "unfavorite",
        details: objective.isFavorite ? "Objective als Favorit markiert" : "Objective aus Favoriten entfernt",
        userId,
        objectiveId: id,
        taskId: null,
        boardId: null,
        projectId: null,
        teamId: null,
        targetUserId: null
      });
      res.json(objective);
    } catch (error) {
      console.error("Error toggling objective favorite:", error);
      res.status(500).json({ message: "Fehler beim \xC4ndern des Favoriten-Status" });
    }
  });
  app2.get("/api/objectives/:id", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Ung\xFCltige Objective-ID" });
    }
    try {
      const userId = req.userId;
      console.log(`Fetching objective with ID: ${id} for user: ${userId}`);
      const hasAccess = await storage.permissionService.canAccessObjective(userId, id);
      if (!hasAccess) {
        console.log(`User ${userId} does not have permission to access objective ${id}`);
        return res.status(403).json({ message: "Keine Berechtigung f\xFCr dieses Objective" });
      }
      const [objective] = await db.select().from(objectives).where(eq6(objectives.id, id));
      if (!objective) {
        console.log(`No objective found with ID: ${id}`);
        return res.status(404).json({ message: "Objective nicht gefunden" });
      }
      const favorites = await db.select().from(userFavoriteObjectives).where(and4(
        eq6(userFavoriteObjectives.userId, userId),
        eq6(userFavoriteObjectives.objectiveId, objective.id)
      ));
      const isFavorite = favorites.length > 0;
      const objectiveWithFavorite = {
        ...objective,
        isFavorite
      };
      let cycle = null;
      if (objective.cycleId) {
        [cycle] = await db.select().from(okrCycles).where(eq6(okrCycles.id, objective.cycleId));
      }
      const objectiveKeyResults = await db.select().from(keyResults).where(eq6(keyResults.objectiveId, id));
      let progress = 0;
      if (objectiveKeyResults.length > 0) {
        const totalProgress = objectiveKeyResults.reduce((acc, kr) => {
          const krProgress = Math.min((kr.currentValue || 0) / (kr.targetValue || 100) * 100, 100);
          return acc + krProgress;
        }, 0);
        progress = Math.round(totalProgress / objectiveKeyResults.length);
        progress = Math.min(progress, 100);
      }
      const response = {
        ...objectiveWithFavorite,
        cycle,
        progress,
        keyResults: objectiveKeyResults
      };
      console.log(`Successfully fetched objective and calculated progress: ${progress}%`);
      res.json(response);
    } catch (error) {
      console.error("Error fetching objective:", error);
      res.status(500).json({ message: "Fehler beim Abrufen des Objectives" });
    }
  });
  app2.get("/api/objectives", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      console.log(`Fetching objectives for user: ${userId}`);
      const user = await db.query.users.findFirst({
        where: eq6(users.id, req.userId)
      });
      if (user && ["free", "freelancer"].includes(user.subscriptionTier?.toLowerCase() || "free")) {
        return res.json([]);
      }
      const allObjectives = await db.select().from(objectives);
      const accessibleObjectivesPromises = allObjectives.map(async (objective) => {
        const hasAccess = await storage.permissionService.canAccessObjective(userId, objective.id);
        return hasAccess ? objective : null;
      });
      const accessibleObjectives = (await Promise.all(accessibleObjectivesPromises)).filter((objective) => objective !== null);
      console.log(`User ${userId} has access to ${accessibleObjectives.length} of ${allObjectives.length} objectives`);
      const objectivesWithData = await Promise.all(
        accessibleObjectives.map(async (objective) => {
          const objectiveKeyResults = await db.select().from(keyResults).where(eq6(keyResults.objectiveId, objective.id));
          const cycle = objective.cycleId ? await db.query.okrCycles.findFirst({
            where: (cycles, { eq: eq13 }) => eq13(cycles.id, objective.cycleId)
          }) : null;
          const favorites = await db.select().from(userFavoriteObjectives).where(and4(
            eq6(userFavoriteObjectives.userId, userId),
            eq6(userFavoriteObjectives.objectiveId, objective.id)
          ));
          const isFavorite = favorites.length > 0;
          let progress = 0;
          if (objectiveKeyResults.length > 0) {
            const totalProgress = objectiveKeyResults.reduce((acc, kr) => {
              const krProgress = Math.min((kr.currentValue || 0) / (kr.targetValue || 100) * 100, 100);
              return acc + krProgress;
            }, 0);
            progress = Math.round(totalProgress / objectiveKeyResults.length);
            progress = Math.min(progress, 100);
          }
          return {
            ...objective,
            cycle,
            progress,
            isFavorite,
            keyResults: objectiveKeyResults
          };
        })
      );
      res.json(objectivesWithData);
    } catch (error) {
      console.error("Error fetching objectives:", error);
      res.status(500).json({ message: "Fehler beim Abrufen der Objectives" });
    }
  });
  app2.get("/api/okr-cycles", requireAuth, async (req, res) => {
    try {
      const user = await db.query.users.findFirst({
        where: eq6(users.id, req.userId)
      });
      if (user && ["free", "freelancer"].includes(user.subscriptionTier?.toLowerCase() || "free")) {
        return res.json([]);
      }
      const cycles = await db.query.okrCycles.findMany({
        orderBy: (cycles2, { desc: desc6 }) => [desc6(cycles2.startDate)]
      });
      res.json(cycles);
    } catch (error) {
      console.error("Fehler beim Abrufen der OKR-Zyklen:", error);
      res.status(500).json({ message: "Fehler beim Abrufen der OKR-Zyklen" });
    }
  });
  app2.post("/api/okr-cycles", requireAuth, async (req, res) => {
    console.log("Received cycle data:", req.body);
    const result = insertOkrCycleSchema.safeParse(req.body);
    if (!result.success) {
      console.error("Validation error:", result.error);
      return res.status(400).json({ message: result.error.message });
    }
    try {
      const userId = req.userId;
      const user = await db.query.users.findFirst({
        where: eq6(users.id, userId)
      });
      if (user && ["free", "freelancer"].includes(user.subscriptionTier?.toLowerCase() || "free")) {
        return res.status(403).json({
          message: "OKR-Funktion nicht verf\xFCgbar",
          details: "OKRs sind nur in h\xF6heren Abonnementpaketen verf\xFCgbar. Bitte upgraden Sie Ihr Abonnement, um OKRs zu erstellen."
        });
      }
      if (user && user.companyId) {
        const hasReachedLimit = await storage.subscriptionService.hasReachedOkrLimit(user.companyId);
        if (hasReachedLimit) {
          return res.status(403).json({
            message: "OKR-Limit erreicht",
            details: "Das OKR-Limit f\xFCr Ihr Abonnement wurde erreicht. Bitte upgraden Sie Ihr Abonnement, um weitere OKRs zu erstellen."
          });
        }
      }
      const data = {
        ...result.data,
        startDate: new Date(result.data.startDate),
        endDate: new Date(result.data.endDate)
      };
      console.log("Processed cycle data:", data);
      const [cycle] = await db.insert(okrCycles).values(data).returning({
        id: okrCycles.id,
        title: okrCycles.title,
        startDate: okrCycles.startDate,
        endDate: okrCycles.endDate,
        status: okrCycles.status
      });
      console.log("Created cycle:", cycle);
      if (!cycle || !cycle.id) {
        console.error("No cycle or cycle ID returned from database");
        return res.status(500).json({ message: "Fehler beim Erstellen des OKR-Zyklus: Keine ID zur\xFCckgegeben" });
      }
      res.status(201).json(cycle);
    } catch (error) {
      console.error("Fehler beim Erstellen des OKR-Zyklus:", error);
      res.status(500).json({ message: "Fehler beim Erstellen des OKR-Zyklus" });
    }
  });
  app2.post("/api/objectives", requireAuth, async (req, res) => {
    const result = insertObjectiveSchema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({ message: result.error.message });
    }
    try {
      const userId = req.userId;
      const user = await db.query.users.findFirst({
        where: eq6(users.id, userId)
      });
      if (user && ["free", "freelancer"].includes(user.subscriptionTier?.toLowerCase() || "free")) {
        return res.status(403).json({
          message: "OKR-Funktion nicht verf\xFCgbar",
          details: "OKRs sind nur in h\xF6heren Abonnementpaketen verf\xFCgbar. Bitte upgraden Sie Ihr Abonnement, um OKRs zu erstellen."
        });
      }
      if (user && user.companyId) {
        const hasReachedLimit = await storage.subscriptionService.hasReachedOkrLimit(user.companyId);
        if (hasReachedLimit) {
          return res.status(403).json({
            message: "OKR-Limit erreicht",
            details: "Das OKR-Limit f\xFCr Ihr Abonnement wurde erreicht. Bitte upgraden Sie Ihr Abonnement, um weitere OKRs zu erstellen."
          });
        }
      }
      const userData = { ...result.data };
      if (!userData.userIds) {
        userData.userIds = [];
      }
      if (!userData.userIds.includes(userId)) {
        userData.userIds.push(userId);
      }
      const [objective] = await db.insert(objectives).values(userData).returning();
      const objectiveKeyResults = await db.select().from(keyResults).where(eq6(keyResults.objectiveId, objective.id));
      let cycle = null;
      if (objective.cycleId) {
        [cycle] = await db.select().from(okrCycles).where(eq6(okrCycles.id, objective.cycleId));
      }
      let progress = 0;
      if (objectiveKeyResults.length > 0) {
        const totalProgress = objectiveKeyResults.reduce((acc, kr) => {
          const krProgress = Math.min((kr.currentValue || 0) / (kr.targetValue || 100) * 100, 100);
          return acc + krProgress;
        }, 0);
        progress = Math.round(totalProgress / objectiveKeyResults.length);
        progress = Math.min(progress, 100);
      }
      const response = {
        ...objective,
        cycle,
        progress,
        keyResults: objectiveKeyResults
      };
      const activityLog = await storage.createActivityLog({
        action: "create",
        details: "Neues OKR erstellt",
        userId: objective.creatorId,
        objectiveId: objective.id,
        projectId: objective.projectId || null,
        boardId: null,
        taskId: null,
        requiresNotification: true,
        notificationType: "okr_create"
      });
      if (objective.userIds && Array.isArray(objective.userIds)) {
        for (const assignedUserId of objective.userIds) {
          if (assignedUserId === objective.creatorId) continue;
          await storage.createActivityLog({
            action: "assign",
            details: `Sie wurden dem OKR "${objective.title}" zugewiesen`,
            userId: objective.creatorId,
            targetUserId: assignedUserId,
            objectiveId: objective.id,
            projectId: objective.projectId || null,
            requiresNotification: true,
            notificationType: "assignment"
          });
        }
      }
      if (objective.userIds && Array.isArray(objective.userIds) && objective.userIds.length > 0) {
        try {
          const objectiveTitle = objective.title;
          for (const assignedUserId of objective.userIds) {
            if (assignedUserId === objective.creatorId) continue;
            await storage.createActivityLog({
              action: "assign",
              details: `Sie wurden dem OKR "${objectiveTitle}" zugewiesen`,
              userId: objective.creatorId,
              // Wer hat die Zuweisung vorgenommen
              targetUserId: assignedUserId,
              // Wer wurde zugewiesen
              objectiveId: objective.id,
              projectId: objective.projectId || null,
              requiresNotification: true,
              notificationType: "assignment"
            });
          }
        } catch (error) {
          console.error("Fehler beim Erstellen der Zuweisungsbenachrichtigungen:", error);
        }
      }
      res.status(201).json(response);
    } catch (error) {
      console.error("Fehler beim Erstellen des Objective:", error);
      res.status(500).json({ message: "Fehler beim Erstellen des Objective" });
    }
  });
  app2.patch("/api/objectives/:id", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Ung\xFCltige Objective-ID" });
    }
    try {
      const userId = req.userId;
      console.log(`Updating objective with ID: ${id} by user: ${userId}`);
      const hasAccess = await storage.permissionService.canAccessObjective(userId, id);
      if (!hasAccess) {
        console.log(`User ${userId} does not have permission to update objective ${id}`);
        return res.status(403).json({ message: "Keine Berechtigung zum Aktualisieren dieses Objectives" });
      }
      const prevObjective = await db.select().from(objectives).where(eq6(objectives.id, id));
      const updated = await db.update(objectives).set(req.body).where(eq6(objectives.id, id)).returning();
      if (updated.length === 0) {
        return res.status(404).json({ message: "Objective nicht gefunden" });
      }
      await storage.createActivityLog({
        action: "update",
        details: "OKR aktualisiert",
        userId,
        objectiveId: id,
        requiresNotification: true,
        notificationType: "okr_update"
      });
      if (req.body.userIds && Array.isArray(req.body.userIds)) {
        const prevUserIds = prevObjective[0]?.userIds || [];
        const newUserIds = [];
        for (const uid of req.body.userIds) {
          if (!prevUserIds.includes(uid) && uid !== userId) {
            newUserIds.push(uid);
          }
        }
        const objectiveTitle = updated[0].title;
        for (const newUserId of newUserIds) {
          await storage.createActivityLog({
            action: "assign",
            details: `Sie wurden dem OKR "${objectiveTitle}" zugewiesen`,
            userId,
            // Wer hat die Zuweisung vorgenommen
            targetUserId: newUserId,
            // Wer wurde zugewiesen
            objectiveId: id,
            projectId: updated[0].projectId || null,
            requiresNotification: true,
            notificationType: "assignment"
          });
        }
      }
      res.json(updated[0]);
    } catch (error) {
      console.error("Fehler beim Aktualisieren des Objective:", error);
      res.status(500).json({ message: "Fehler beim Aktualisieren des Objective" });
    }
  });
  app2.delete("/api/objectives/:id", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Ung\xFCltige Objective-ID" });
    }
    try {
      const userId = req.userId;
      console.log(`Deleting objective with ID: ${id} by user: ${userId}`);
      const hasAccess = await storage.permissionService.canAccessObjective(userId, id);
      if (!hasAccess) {
        console.log(`User ${userId} does not have permission to delete objective ${id}`);
        return res.status(403).json({ message: "Keine Berechtigung zum L\xF6schen dieses Objectives" });
      }
      const objective = await db.select().from(objectives).where(eq6(objectives.id, id));
      if (objective.length > 0) {
        const objectiveTitle = objective[0].title;
        const userIds = objective[0].userIds || [];
        await db.delete(objectives).where(eq6(objectives.id, id));
        await storage.createActivityLog({
          action: "delete",
          details: "Objective gel\xF6scht",
          userId,
          objectiveId: id,
          taskId: null,
          boardId: null,
          projectId: null,
          requiresNotification: true,
          notificationType: "okr_delete"
        });
        for (const assignedUserId of userIds) {
          if (assignedUserId === userId) continue;
          await storage.createActivityLog({
            action: "delete",
            details: `Das OKR "${objectiveTitle}" wurde gel\xF6scht`,
            userId,
            targetUserId: assignedUserId,
            requiresNotification: true,
            notificationType: "okr_delete"
          });
        }
      } else {
        await db.delete(objectives).where(eq6(objectives.id, id));
      }
      res.status(204).send();
    } catch (error) {
      console.error("Fehler beim L\xF6schen des Objective:", error);
      res.status(500).json({ message: "Fehler beim L\xF6schen des Objective" });
    }
  });
  app2.get("/api/objectives/:objectiveId/key-results", requireAuth, async (req, res) => {
    const objectiveId = parseInt(req.params.objectiveId);
    if (isNaN(objectiveId)) {
      return res.status(400).json({ message: "Ung\xFCltige Objective-ID" });
    }
    try {
      const userId = req.userId;
      console.log(`Fetching key results for objective: ${objectiveId} by user: ${userId}`);
      const hasAccess = await storage.permissionService.canAccessObjective(userId, objectiveId);
      if (!hasAccess) {
        console.log(`User ${userId} does not have permission to access objective ${objectiveId}'s key results`);
        return res.status(403).json({ message: "Keine Berechtigung f\xFCr diese Key Results" });
      }
      const krs = await db.select().from(keyResults).where(eq6(keyResults.objectiveId, objectiveId));
      const processedKrs = krs.map((kr) => ({
        ...kr,
        checklistItems: kr.checklistItems ? kr.checklistItems.map((item) => JSON.parse(item)) : []
      }));
      res.json(processedKrs);
    } catch (error) {
      console.error("Fehler beim Abrufen der Key Results:", error);
      res.status(500).json({ message: "Fehler beim Abrufen der Key Results" });
    }
  });
  app2.post("/api/objectives/:objectiveId/key-results", requireAuth, async (req, res) => {
    const objectiveId = parseInt(req.params.objectiveId);
    if (isNaN(objectiveId)) {
      return res.status(400).json({ message: "Ung\xFCltige Objective-ID" });
    }
    const payload = { ...req.body, objectiveId };
    const result = insertKeyResultSchema.safeParse(payload);
    if (!result.success) {
      return res.status(400).json({ message: result.error.message });
    }
    try {
      const user = await db.query.users.findFirst({
        where: eq6(users.id, req.userId)
      });
      if (user && ["free", "freelancer"].includes(user.subscriptionTier?.toLowerCase() || "free")) {
        return res.status(403).json({
          message: "Key Results nicht verf\xFCgbar",
          details: "Key Results sind nur in h\xF6heren Abonnementpaketen verf\xFCgbar. Bitte upgraden Sie Ihr Abonnement, um Key Results zu erstellen."
        });
      }
      if (user && user.companyId) {
        const hasReachedLimit = await storage.subscriptionService.hasReachedOkrLimit(user.companyId);
        if (hasReachedLimit) {
          return res.status(403).json({
            message: "OKR-Limit erreicht",
            details: "Das OKR-Limit f\xFCr Ihr Abonnement wurde erreicht. Bitte upgraden Sie Ihr Abonnement, um weitere Key Results zu erstellen."
          });
        }
      }
      let data = { ...result.data };
      console.log(`Verarbeite Key Result vom Typ: ${data.type}`);
      console.log("Eingangsdaten:", JSON.stringify(data, null, 2));
      if (data.type === "checkbox") {
        console.log("Workaround: Konvertiere Checkbox-Typ zu Checklist-Typ mit einem Element");
        const isChecked = (data.currentValue || 0) > 0;
        const title = data.title || "Erledigt";
        data.type = "checklist";
        const itemString = JSON.stringify({ title, completed: isChecked });
        data.checklistItems = [{ title, completed: isChecked }];
        console.log("Konvertierte Daten:", JSON.stringify(data, null, 2));
      } else if (data.type === "checklist") {
        console.log("Verarbeite Checklist-Typ");
        if (!Array.isArray(data.checklistItems)) {
          console.log("checklistItems ist kein Array, setze leeres Array");
          data.checklistItems = [];
        }
        const checklistStrings = (data.checklistItems || []).filter((item) => item && item.title && item.title.trim() !== "").map((item) => {
          const validItem = {
            title: item.title || "Unbenanntes Element",
            completed: !!item.completed
            // Sicherstellen, dass es ein Boolean ist
          };
          return JSON.stringify(validItem);
        });
        data.checklistItems = checklistStrings.map((str) => {
          try {
            return JSON.parse(str);
          } catch (e) {
            return { title: "Parsing-Fehler", completed: false };
          }
        });
        console.log(`Verarbeitete Checklist mit ${data.checklistItems?.length || 0} g\xFCltigen Items`);
      } else {
        console.log("Setze leeres checklistItems-Array f\xFCr Typ:", data.type);
        data.checklistItems = [];
      }
      console.log("Processed key result data:", data);
      const insertData = {
        title: data.title,
        objectiveId: data.objectiveId,
        type: data.type,
        targetValue: data.targetValue,
        status: data.status,
        description: data.description,
        currentValue: data.currentValue || 0,
        checklistItems: data.checklistItems || []
      };
      const insertQuery = `
        INSERT INTO key_results (
          title, objective_id, type, target_value, status, description, 
          current_value, checklist_items
        ) VALUES (
          $1, $2, $3, $4, $5, $6, $7, $8
        ) RETURNING 
          id, title, description, objective_id as "objectiveId", current_value as "currentValue", 
          target_value as "targetValue", checklist_items as "checklistItems", 
          created_at as "createdAt", type, status
      `;
      const insertResult = await pool.query(insertQuery, [
        insertData.title,
        insertData.objectiveId,
        insertData.type,
        insertData.targetValue,
        insertData.status,
        insertData.description,
        insertData.currentValue,
        insertData.checklistItems
      ]);
      const keyResult = insertResult.rows[0];
      await storage.createActivityLog({
        action: "create",
        details: "Neues Key Result erstellt",
        userId: req.body.creatorId || 1,
        objectiveId: keyResult.objectiveId,
        taskId: null,
        boardId: null,
        projectId: null
      });
      const response = {
        ...keyResult,
        checklistItems: keyResult.checklistItems?.map((item) => JSON.parse(item)) || []
      };
      res.status(201).json(response);
    } catch (error) {
      console.error("Fehler beim Erstellen des Key Result:", error);
      res.status(500).json({ message: "Fehler beim Erstellen des Key Result" });
    }
  });
  app2.patch("/api/key-results/:id", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Ung\xFCltige Key Result-ID" });
    }
    try {
      console.log("Updating key result with ID:", id);
      console.log("Original request data:", req.body);
      const user = await db.query.users.findFirst({
        where: eq6(users.id, req.userId)
      });
      if (user && ["free", "freelancer"].includes(user.subscriptionTier?.toLowerCase() || "free")) {
        return res.status(403).json({ message: "Keine Berechtigung f\xFCr diese Aktion" });
      }
      const getResult = await pool.query(
        `SELECT * FROM key_results WHERE id = $1`,
        [id]
      );
      if (getResult.rows.length === 0) {
        return res.status(404).json({ message: "Key Result nicht gefunden" });
      }
      const existingKeyResult = getResult.rows[0];
      let setClause = [];
      let params = [];
      let paramCount = 1;
      if (req.body.title !== void 0) {
        setClause.push(`title = $${paramCount}`);
        params.push(req.body.title);
        paramCount++;
      }
      if (req.body.description !== void 0) {
        setClause.push(`description = $${paramCount}`);
        params.push(req.body.description);
        paramCount++;
      }
      if (req.body.targetValue !== void 0) {
        setClause.push(`target_value = $${paramCount}`);
        params.push(req.body.targetValue);
        paramCount++;
      }
      if (req.body.currentValue !== void 0) {
        setClause.push(`current_value = $${paramCount}`);
        params.push(req.body.currentValue);
        paramCount++;
      }
      if (req.body.type !== void 0) {
        setClause.push(`type = $${paramCount}`);
        params.push(req.body.type);
        paramCount++;
      }
      if (req.body.status !== void 0) {
        setClause.push(`status = $${paramCount}`);
        params.push(req.body.status);
        paramCount++;
      }
      if (req.body.type === "checkbox") {
        console.log("PATCH: Workaround f\xFCr Checkbox-Typ");
        setClause.push(`type = $${paramCount}`);
        params.push("checklist");
        paramCount++;
        const isChecked = (req.body.currentValue || 0) > 0;
        const title = req.body.title || existingKeyResult.title || "Erledigt";
        const checklistItem = { title, completed: isChecked };
        setClause.push(`checklist_items = $${paramCount}`);
        params.push([JSON.stringify(checklistItem)]);
        paramCount++;
        console.log("Checkbox konvertiert zu Checklist mit Item:", checklistItem);
      } else if (req.body.checklistItems !== void 0) {
        try {
          console.log("Checklist-Items vom Frontend erhalten:", req.body.checklistItems);
          let itemArray = req.body.checklistItems;
          if (!Array.isArray(itemArray)) {
            console.log("checklistItems ist kein Array, setze leeres Array:", itemArray);
            itemArray = [];
          }
          const checklistItemsJson = itemArray.map((item) => {
            try {
              if (typeof item === "string") {
                try {
                  const parsed = JSON.parse(item);
                  return JSON.stringify({
                    title: typeof parsed.title === "string" ? parsed.title : "Unnamed Item",
                    completed: Boolean(parsed.completed)
                  });
                } catch (e) {
                  return JSON.stringify({
                    title: String(item),
                    completed: false
                  });
                }
              } else if (typeof item === "object" && item !== null) {
                return JSON.stringify({
                  title: typeof item.title === "string" ? item.title : "Unnamed Item",
                  completed: Boolean(item.completed)
                });
              }
              return JSON.stringify({
                title: "Unnamed Item",
                completed: false
              });
            } catch (parseError) {
              console.error("Fehler bei der Verarbeitung eines Checklist-Items:", parseError);
              return JSON.stringify({
                title: "Fehler beim Verarbeiten",
                completed: false
              });
            }
          }).filter(Boolean);
          console.log("Verarbeitete checklistItems (vor DB-Update):", checklistItemsJson);
          setClause.push(`checklist_items = $${paramCount}`);
          params.push(checklistItemsJson);
          paramCount++;
        } catch (error) {
          console.error("Schwerwiegender Fehler bei der Verarbeitung der checklistItems:", error);
          console.error("Original checklistItems:", req.body.checklistItems);
          setClause.push(`checklist_items = $${paramCount}`);
          params.push([]);
          paramCount++;
        }
      }
      if (setClause.length === 0) {
        const response2 = {
          ...existingKeyResult,
          checklistItems: existingKeyResult.checklist_items ? existingKeyResult.checklist_items.map((item) => {
            try {
              return JSON.parse(item);
            } catch (e) {
              console.error("Fehler beim Parsen des Checklist-Items in der existingKeyResult:", e);
              return { title: "Fehler beim Laden", completed: false };
            }
          }) : []
        };
        return res.json(response2);
      }
      console.log("Update SET clause:", setClause.join(", "));
      console.log("Update params:", params);
      params.push(id);
      const updateQuery = `
        UPDATE key_results 
        SET ${setClause.join(", ")} 
        WHERE id = $${paramCount}
        RETURNING *
      `;
      const updateResult = await pool.query(updateQuery, params);
      const updated = updateResult.rows[0];
      await storage.createActivityLog({
        action: "update",
        details: "Key Result aktualisiert",
        userId: req.userId,
        objectiveId: updated.objective_id,
        taskId: null,
        boardId: null,
        projectId: null,
        teamId: null,
        targetUserId: null,
        requiresNotification: true,
        notificationType: "okr_update"
      });
      const response = {
        id: updated.id,
        title: updated.title,
        description: updated.description,
        objectiveId: updated.objective_id,
        currentValue: updated.current_value,
        targetValue: updated.target_value,
        type: updated.type,
        status: updated.status,
        createdAt: updated.created_at,
        checklistItems: updated.checklist_items ? updated.checklist_items.map((item) => {
          try {
            return JSON.parse(item);
          } catch (e) {
            console.error("Fehler beim Parsen des Checklist-Items in der Antwort:", e);
            return { title: "Fehler beim Laden", completed: false };
          }
        }) : []
      };
      res.json(response);
    } catch (error) {
      console.error("Fehler beim Aktualisieren des Key Result:", error);
      res.status(500).json({ message: "Fehler beim Aktualisieren des Key Result" });
    }
  });
  app2.delete("/api/key-results/:id", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Ung\xFCltige Key Result-ID" });
    }
    try {
      const user = await db.query.users.findFirst({
        where: eq6(users.id, req.userId)
      });
      if (user && ["free", "freelancer"].includes(user.subscriptionTier?.toLowerCase() || "free")) {
        return res.status(403).json({ message: "Keine Berechtigung f\xFCr diese Aktion" });
      }
      const getResult = await pool.query(
        `SELECT * FROM key_results WHERE id = $1`,
        [id]
      );
      const keyResult = getResult.rows[0];
      if (keyResult) {
        await pool.query(
          `DELETE FROM key_results WHERE id = $1`,
          [id]
        );
        await storage.createActivityLog({
          action: "delete",
          details: "Key Result gel\xF6scht",
          userId: req.userId || req.body.deletedBy || 1,
          objectiveId: keyResult.objective_id,
          taskId: null,
          boardId: null,
          projectId: null,
          teamId: null,
          targetUserId: null,
          requiresNotification: true,
          notificationType: "okr_delete"
        });
      }
      res.status(204).send();
    } catch (error) {
      console.error("Fehler beim L\xF6schen des Key Result:", error);
      res.status(500).json({ message: "Fehler beim L\xF6schen des Key Result" });
    }
  });
  app2.get("/api/okr-comments", requireAuth, async (req, res) => {
    const { objectiveId, keyResultId } = req.query;
    try {
      let result;
      if (objectiveId && keyResultId) {
        result = await pool.query(
          `SELECT * FROM okr_comments WHERE objective_id = $1 AND key_result_id = $2`,
          [Number(objectiveId), Number(keyResultId)]
        );
      } else if (objectiveId) {
        result = await pool.query(
          `SELECT * FROM okr_comments WHERE objective_id = $1`,
          [Number(objectiveId)]
        );
      } else if (keyResultId) {
        result = await pool.query(
          `SELECT * FROM okr_comments WHERE key_result_id = $1`,
          [Number(keyResultId)]
        );
      } else {
        result = await pool.query(`SELECT * FROM okr_comments`);
      }
      res.json(result.rows || []);
    } catch (error) {
      console.error("Fehler beim Abrufen der Kommentare:", error);
      res.status(500).json({ message: "Fehler beim Abrufen der Kommentare" });
    }
  });
  app2.post("/api/okr-comments", requireAuth, async (req, res) => {
    const result = insertOkrCommentSchema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({ message: result.error.message });
    }
    try {
      const user = await db.query.users.findFirst({
        where: eq6(users.id, req.userId)
      });
      if (user && ["free", "freelancer"].includes(user.subscriptionTier?.toLowerCase() || "free")) {
        return res.status(403).json({ message: "Keine Berechtigung f\xFCr diese Aktion" });
      }
      const { authorId, objectiveId, keyResultId, content } = result.data;
      const query = `
        INSERT INTO okr_comments (author_id, objective_id, key_result_id, content, created_at)
        VALUES ($1, $2, $3, $4, NOW())
        RETURNING *
      `;
      const commentResult = await pool.query(query, [
        authorId,
        objectiveId || null,
        keyResultId || null,
        content
      ]);
      const comment = commentResult.rows?.[0];
      if (!comment) {
        throw new Error("Kommentar konnte nicht erstellt werden");
      }
      await storage.createActivityLog({
        action: "comment",
        details: "Neuer OKR-Kommentar hinzugef\xFCgt",
        userId: authorId,
        objectiveId: objectiveId || null,
        requiresNotification: true,
        notificationType: "okr_comment"
      });
      res.status(201).json(comment);
    } catch (error) {
      console.error("Fehler beim Erstellen des Kommentars:", error);
      res.status(500).json({ message: "Fehler beim Erstellen des Kommentars" });
    }
  });
  app2.get("/api/key-results", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      console.log(`Fetching all key results for user: ${userId}`);
      const user = await db.query.users.findFirst({
        where: eq6(users.id, req.userId)
      });
      if (user && ["free", "freelancer"].includes(user.subscriptionTier?.toLowerCase() || "free")) {
        return res.json([]);
      }
      const keyResultsQuery = await pool.query(`
        SELECT kr.*, o.creator_id
        FROM key_results kr
        JOIN objectives o ON kr.objective_id = o.id
      `);
      const allKeyResults = keyResultsQuery.rows || [];
      console.log(`Found ${allKeyResults.length} total key results`);
      const accessibleKeyResultsPromises = allKeyResults.map(async (kr) => {
        const hasAccess = await storage.permissionService.canAccessObjective(userId, kr.objective_id);
        return hasAccess ? kr : null;
      });
      const accessibleKeyResults = (await Promise.all(accessibleKeyResultsPromises)).filter((kr) => kr !== null);
      console.log(`User ${userId} has access to ${accessibleKeyResults.length} of ${allKeyResults.length} key results`);
      const processedKrs = accessibleKeyResults.map((kr) => ({
        id: kr.id,
        title: kr.title,
        description: kr.description,
        objectiveId: kr.objective_id,
        currentValue: kr.current_value,
        targetValue: kr.target_value,
        createdAt: kr.created_at,
        type: kr.type,
        status: kr.status,
        checklistItems: kr.checklist_items ? kr.checklist_items.map((item) => {
          try {
            return JSON.parse(item);
          } catch (e) {
            console.error("Fehler beim Parsen des Checklist-Items in der Liste aller Key Results:", e);
            return { title: "Fehler beim Laden", completed: false };
          }
        }) : []
      }));
      res.json(processedKrs);
    } catch (error) {
      console.error("Fehler beim Abrufen der Key Results:", error);
      res.status(500).json({ message: "Fehler beim Abrufen der Key Results" });
    }
  });
}
var init_okrRoutes = __esm({
  "server/okrRoutes.ts"() {
    "use strict";
    init_db();
    init_storage();
    init_schema();
    init_auth();
    init_schema();
  }
});

// server/index.ts
import express2 from "express";

// server/routes.ts
init_storage();
init_schema();
import bcrypt from "bcryptjs";
import multer from "multer";
import path2 from "path";

// server/productivityRoutes.ts
init_storage();
init_schema();
init_auth();
import { subDays, startOfDay } from "date-fns";
function registerProductivityRoutes(app2) {
  app2.get("/api/productivity/metrics/:userId", requireAuth, async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const days = parseInt(req.query.days) || 7;
      if (isNaN(userId)) {
        return res.status(400).json({ message: "Invalid user ID" });
      }
      const metrics = await storage.getUserProductivityMetrics(userId, days);
      const filledMetrics = [];
      const endDate = /* @__PURE__ */ new Date();
      let currentDate = subDays(endDate, days - 1);
      while (currentDate <= endDate) {
        const existingMetric = metrics.find(
          (m) => startOfDay(new Date(m.date)).getTime() === startOfDay(currentDate).getTime()
        );
        filledMetrics.push(
          existingMetric || {
            date: currentDate.toISOString(),
            tasksCompleted: 0,
            tasksCreated: 0,
            timeSpentMinutes: 0,
            objectivesAchieved: 0
          }
        );
        currentDate = new Date(currentDate.setDate(currentDate.getDate() + 1));
      }
      res.json(filledMetrics);
    } catch (error) {
      console.error("Failed to fetch productivity metrics:", error);
      res.status(500).json({ message: "Failed to fetch productivity metrics" });
    }
  });
  app2.get("/api/productivity/task-distribution/:userId", requireAuth, async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      if (isNaN(userId)) {
        return res.status(400).json({ message: "Invalid user ID" });
      }
      const distribution = await storage.getTaskDistribution(userId);
      res.json(distribution);
    } catch (error) {
      console.error("Failed to fetch task distribution:", error);
      res.status(500).json({ message: "Failed to fetch task distribution" });
    }
  });
  app2.get("/api/productivity/project-activities/:userId", requireAuth, async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      if (isNaN(userId)) {
        return res.status(400).json({ message: "Invalid user ID" });
      }
      const activities = await storage.getProjectActivities(userId);
      res.json(activities);
    } catch (error) {
      console.error("Failed to fetch project activities:", error);
      res.status(500).json({ message: "Failed to fetch project activities" });
    }
  });
  app2.post("/api/productivity/time-entries", requireAuth, async (req, res) => {
    try {
      const result = insertTaskTimeEntrySchema.safeParse(req.body);
      if (!result.success) {
        return res.status(400).json({ message: result.error.message });
      }
      const timeEntry = await storage.createTaskTimeEntry(result.data);
      res.status(201).json(timeEntry);
    } catch (error) {
      console.error("Failed to create time entry:", error);
      res.status(500).json({ message: "Failed to create time entry" });
    }
  });
  app2.patch("/api/productivity/time-entries/:id", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const endTime = new Date(req.body.endTime);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid time entry ID" });
      }
      if (isNaN(endTime.getTime())) {
        return res.status(400).json({ message: "Invalid end time" });
      }
      const timeEntry = await storage.updateTaskTimeEntry(id, endTime);
      res.json(timeEntry);
    } catch (error) {
      console.error("Failed to update time entry:", error);
      res.status(500).json({ message: "Failed to update time entry" });
    }
  });
  app2.post("/api/productivity/state-changes", requireAuth, async (req, res) => {
    try {
      const result = insertTaskStateChangeSchema.safeParse(req.body);
      if (!result.success) {
        return res.status(400).json({ message: result.error.message });
      }
      const stateChange = await storage.createTaskStateChange(result.data);
      res.status(201).json(stateChange);
    } catch (error) {
      console.error("Failed to create state change:", error);
      res.status(500).json({ message: "Failed to create state change" });
    }
  });
}

// server/adminRoutes.ts
init_auth();
init_schema();
init_db();
import { eq as eq5 } from "drizzle-orm";
function setupAdminRoutes(app2, dbInstance) {
  app2.get("/api/admin/companies", requireHyperAdmin, async (req, res) => {
    try {
      const allCompanies = await db.query.companies.findMany({
        orderBy: (companies3, { desc: desc6 }) => [desc6(companies3.id)]
      });
      res.json(allCompanies);
    } catch (error) {
      console.error("Fehler beim Abrufen der Unternehmen:", error);
      res.status(500).json({ message: "Fehler beim Abrufen der Unternehmen" });
    }
  });
  app2.post("/api/admin/companies", requireHyperAdmin, async (req, res) => {
    try {
      const { name, description, inviteCode } = req.body;
      if (!name || !inviteCode) {
        return res.status(400).json({ message: "Name und Einladungscode sind erforderlich" });
      }
      const existingCompany = await db.query.companies.findFirst({
        where: eq5(companies.inviteCode, inviteCode)
      });
      if (existingCompany) {
        return res.status(400).json({ message: "Dieser Einladungscode wird bereits verwendet" });
      }
      const newCompany = await db.insert(companies).values({
        name,
        description,
        inviteCode,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date(),
        is_paused: false
      }).returning();
      res.status(201).json(newCompany[0]);
    } catch (error) {
      console.error("Fehler beim Erstellen des Unternehmens:", error);
      res.status(500).json({ message: "Fehler beim Erstellen des Unternehmens" });
    }
  });
  app2.patch("/api/admin/companies/:id", requireHyperAdmin, async (req, res) => {
    try {
      const companyId = parseInt(req.params.id);
      const { name, description, inviteCode } = req.body;
      if (!name || !inviteCode) {
        return res.status(400).json({ message: "Name und Einladungscode sind erforderlich" });
      }
      const existingCompany = await db.query.companies.findFirst({
        where: eq5(companies.id, companyId)
      });
      if (!existingCompany) {
        return res.status(404).json({ message: "Unternehmen nicht gefunden" });
      }
      if (inviteCode !== existingCompany.inviteCode) {
        const codeExists = await db.query.companies.findFirst({
          where: eq5(companies.inviteCode, inviteCode)
        });
        if (codeExists) {
          return res.status(400).json({ message: "Dieser Einladungscode wird bereits verwendet" });
        }
      }
      const updatedCompany = await db.update(companies).set({
        name,
        description,
        inviteCode,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq5(companies.id, companyId)).returning();
      res.json(updatedCompany[0]);
    } catch (error) {
      console.error("Fehler beim Aktualisieren des Unternehmens:", error);
      res.status(500).json({ message: "Fehler beim Aktualisieren des Unternehmens" });
    }
  });
  app2.post("/api/admin/companies/:id/pause", requireHyperAdmin, async (req, res) => {
    try {
      const companyId = parseInt(req.params.id);
      const { pauseReason } = req.body;
      console.log("Pausierungsanfrage f\xFCr Unternehmen:", companyId, "mit Begr\xFCndung:", pauseReason);
      if (!pauseReason) {
        return res.status(400).json({ message: "Eine Begr\xFCndung f\xFCr die Pausierung ist erforderlich" });
      }
      const existingCompany = await db.query.companies.findFirst({
        where: eq5(companies.id, companyId)
      });
      if (!existingCompany) {
        return res.status(404).json({ message: "Unternehmen nicht gefunden" });
      }
      const pausedCompany = await db.update(companies).set({
        isPaused: true,
        pauseReason,
        pausedAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq5(companies.id, companyId)).returning();
      await db.update(users).set({
        isPaused: true,
        pauseReason: `Unternehmen pausiert: ${pauseReason}`,
        pausedAt: /* @__PURE__ */ new Date()
      }).where(eq5(users.companyId, companyId));
      res.json(pausedCompany[0]);
    } catch (error) {
      console.error("Fehler beim Pausieren des Unternehmens:", error);
      res.status(500).json({ message: "Fehler beim Pausieren des Unternehmens" });
    }
  });
  app2.post("/api/admin/companies/:id/resume", requireHyperAdmin, async (req, res) => {
    try {
      const companyId = parseInt(req.params.id);
      console.log("Fortsetzungsanfrage f\xFCr Unternehmen:", companyId);
      const existingCompany = await db.query.companies.findFirst({
        where: eq5(companies.id, companyId)
      });
      if (!existingCompany) {
        return res.status(404).json({ message: "Unternehmen nicht gefunden" });
      }
      const resumedCompany = await db.update(companies).set({
        isPaused: false,
        pauseReason: null,
        pausedAt: null,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq5(companies.id, companyId)).returning();
      await db.update(users).set({
        isPaused: false,
        pauseReason: null,
        pausedAt: null
      }).where(eq5(users.companyId, companyId));
      res.json(resumedCompany[0]);
    } catch (error) {
      console.error("Fehler beim Fortsetzen des Unternehmens:", error);
      res.status(500).json({ message: "Fehler beim Fortsetzen des Unternehmens" });
    }
  });
  app2.get("/api/admin/users", requireHyperAdmin, async (req, res) => {
    try {
      const allUsers = await db.query.users.findMany({
        orderBy: (users2, { desc: desc6 }) => [desc6(users2.id)]
      });
      const userCompanyMap = /* @__PURE__ */ new Map();
      const userIds = allUsers.map((user) => user.companyId).filter((id) => id !== null);
      if (userIds.length > 0) {
        const companies3 = await db.query.companies.findMany();
        const companyMap = new Map(companies3.map((company) => [company.id, company]));
        const usersWithCompanies = allUsers.map((user) => {
          const company = user.companyId ? companyMap.get(user.companyId) : null;
          return {
            ...user,
            company
          };
        });
        res.json(usersWithCompanies);
      } else {
        res.json(allUsers);
      }
    } catch (error) {
      console.error("Fehler beim Abrufen der Benutzer:", error);
      res.status(500).json({ message: "Fehler beim Abrufen der Benutzer" });
    }
  });
  app2.post("/api/admin/users/:id/pause", requireHyperAdmin, async (req, res) => {
    try {
      const userId = parseInt(req.params.id);
      const { pauseReason } = req.body;
      console.log("Pausierungsanfrage f\xFCr Benutzer:", userId, "mit Begr\xFCndung:", pauseReason);
      if (!pauseReason) {
        return res.status(400).json({ message: "Eine Begr\xFCndung f\xFCr die Pausierung ist erforderlich" });
      }
      const existingUser = await db.query.users.findFirst({
        where: eq5(users.id, userId)
      });
      if (!existingUser) {
        return res.status(404).json({ message: "Benutzer nicht gefunden" });
      }
      const pausedUser = await db.update(users).set({
        isPaused: true,
        pauseReason,
        pausedAt: /* @__PURE__ */ new Date()
      }).where(eq5(users.id, userId)).returning();
      res.json(pausedUser[0]);
    } catch (error) {
      console.error("Fehler beim Pausieren des Benutzers:", error);
      res.status(500).json({ message: "Fehler beim Pausieren des Benutzers" });
    }
  });
  app2.post("/api/admin/users/:id/resume", requireHyperAdmin, async (req, res) => {
    try {
      const userId = parseInt(req.params.id);
      console.log("Fortsetzungsanfrage f\xFCr Benutzer:", userId);
      const existingUser = await db.query.users.findFirst({
        where: eq5(users.id, userId)
      });
      if (!existingUser) {
        return res.status(404).json({ message: "Benutzer nicht gefunden" });
      }
      const resumedUser = await db.update(users).set({
        isPaused: false,
        pauseReason: null,
        pausedAt: null
      }).where(eq5(users.id, userId)).returning();
      res.json(resumedUser[0]);
    } catch (error) {
      console.error("Fehler beim Fortsetzen des Benutzers:", error);
      res.status(500).json({ message: "Fehler beim Fortsetzen des Benutzers" });
    }
  });
}

// server/utils.ts
import fetch2 from "node-fetch";
import * as fs from "fs";
import * as path from "path";
import * as crypto from "crypto";
function ensureDirectoryExists(directory) {
  if (!directory) return;
  if (!fs.existsSync(directory)) {
    fs.mkdirSync(directory, { recursive: true });
  }
}
function generateSecureFilename(originalname) {
  const ext = path.extname(originalname).toLowerCase();
  const randomString = crypto.randomBytes(16).toString("hex");
  const sanitizedName = originalname.replace(/[^a-zA-Z0-9]/g, "_").toLowerCase().substring(0, 32);
  return `${sanitizedName}-${randomString}${ext}`;
}

// server/routes.ts
init_auth();
init_permissions();
init_db();
import { eq as eq7 } from "drizzle-orm";

// server/notification-service.ts
init_db();
var NotificationService = class {
  /**
   * Erstellt eine Benachrichtigung für einen Benutzer
   */
  async createNotification(userId, title, message, type, link) {
    try {
      const validTypes = [
        // Aufgaben
        "task",
        "task_update",
        "task_delete",
        "task_comment",
        // Protokolle
        "protocol",
        "protocol_update",
        "protocol_delete",
        "protocol_comment",
        // Boards
        "board",
        "board_update",
        // Projekte
        "project",
        "project_update",
        // Teams 
        "team",
        "team_update",
        // OKRs
        "okr",
        "okr_update",
        "okr_delete",
        "okr_comment",
        // Allgemein
        "approval",
        "mention",
        "assignment",
        "comment",
        "general"
      ];
      const validatedType = validTypes.includes(type) ? type : "general";
      const result = await pool.query(
        `INSERT INTO notifications 
        (user_id, title, message, type, link, read, created_at) 
        VALUES ($1, $2, $3, $4, $5, $6, $7) 
        RETURNING id`,
        [userId, title, message, validatedType, link, false, /* @__PURE__ */ new Date()]
      );
      const notificationId = result.rows[0].id;
      console.log(`Created notification ${notificationId} for user ${userId} of type ${validatedType}`);
      return notificationId;
    } catch (error) {
      console.error("Failed to create notification:", error);
      throw error;
    }
  }
  /**
   * Erstellt Benachrichtigungen basierend auf Aktivitätslogs
   */
  async processActivityLog(activityLogId) {
    try {
      const activityLogResult = await pool.query(
        `SELECT a.*, 
                b.title as board_title, 
                p.title as project_title,
                o.title as objective_title,
                t.title as task_title,
                tm.name as team_title,
                u.username, 
                u.company_id
         FROM activity_logs a
         LEFT JOIN boards b ON a.board_id = b.id
         LEFT JOIN projects p ON a.project_id = p.id
         LEFT JOIN objectives o ON a.objective_id = o.id
         LEFT JOIN tasks t ON a.task_id = t.id
         LEFT JOIN teams tm ON a.team_id = tm.id
         LEFT JOIN users u ON a.user_id = u.id
         WHERE a.id = $1`,
        [activityLogId]
      );
      if (activityLogResult.rows.length === 0) {
        console.log(`Kein Aktivit\xE4tslog mit ID ${activityLogId} gefunden.`);
        return;
      }
      const activityLog = activityLogResult.rows[0];
      const activity = {
        id: activityLog.id,
        userId: activityLog.user_id,
        action: activityLog.action,
        details: activityLog.details,
        boardId: activityLog.board_id,
        projectId: activityLog.project_id,
        objectiveId: activityLog.objective_id,
        taskId: activityLog.task_id,
        teamId: activityLog.team_id,
        targetUserId: activityLog.target_user_id,
        commentId: activityLog.comment_id,
        keyResultId: activityLog.key_result_id,
        requiresNotification: activityLog.requires_notification,
        notificationSent: activityLog.notification_sent,
        notificationType: activityLog.notification_type,
        visibleToUsers: activityLog.visible_to_users || [],
        // Zusätzliche Informationen für bessere Benachrichtigungen
        boardTitle: activityLog.board_title,
        projectTitle: activityLog.project_title,
        objectiveTitle: activityLog.objective_title,
        taskTitle: activityLog.task_title,
        teamTitle: activityLog.team_title,
        username: activityLog.username,
        companyId: activityLog.company_id
      };
      if (activity.notificationSent) {
        return;
      }
      const recipientUserIds = /* @__PURE__ */ new Set();
      if (activity.targetUserId) {
        recipientUserIds.add(activity.targetUserId);
      }
      if (activity.visibleToUsers && activity.visibleToUsers.length > 0) {
        activity.visibleToUsers.forEach((userId) => recipientUserIds.add(userId));
      }
      try {
        const companyId = activity.companyId || 0;
        if (companyId <= 0) {
          await pool.query(
            `UPDATE activity_logs SET notification_sent = true WHERE id = $1`,
            [activity.id]
          );
          return;
        }
        if (activity.taskId) {
          const taskUsersResult = await pool.query(`
            SELECT assigned_user_ids FROM tasks 
            WHERE id = $1
          `, [activity.taskId]);
          if (taskUsersResult.rows.length > 0 && taskUsersResult.rows[0].assigned_user_ids) {
            const assignedUserIds = taskUsersResult.rows[0].assigned_user_ids;
            assignedUserIds.forEach((userId) => {
              if (userId) recipientUserIds.add(userId);
            });
          }
          if (activity.boardId) {
            const boardMembersResult = await pool.query(`
              SELECT user_id FROM board_members WHERE board_id = $1
            `, [activity.boardId]);
            boardMembersResult.rows.forEach((row) => {
              recipientUserIds.add(row.user_id);
            });
          }
        } else if (activity.boardId) {
          const boardMembersResult = await pool.query(`
            SELECT bm.user_id
            FROM board_members bm
            JOIN users u ON bm.user_id = u.id
            WHERE bm.board_id = $1 AND u.company_id = $2
          `, [activity.boardId, companyId]);
          boardMembersResult.rows.forEach((row) => {
            recipientUserIds.add(row.user_id);
          });
          const boardCreatorResult = await pool.query(`
            SELECT creator_id FROM boards WHERE id = $1
          `, [activity.boardId]);
          if (boardCreatorResult.rows.length > 0 && boardCreatorResult.rows[0].creator_id) {
            recipientUserIds.add(boardCreatorResult.rows[0].creator_id);
          }
          const boardProjectResult = await pool.query(`
            SELECT project_id FROM boards WHERE id = $1 AND project_id IS NOT NULL
          `, [activity.boardId]);
          if (boardProjectResult.rows.length > 0 && boardProjectResult.rows[0].project_id) {
            const projectId = boardProjectResult.rows[0].project_id;
            const projectTeamMembersResult = await pool.query(`
              SELECT tm.user_id
              FROM project_teams pt
              JOIN team_members tm ON pt.team_id = tm.team_id
              JOIN users u ON tm.user_id = u.id
              WHERE pt.project_id = $1 AND u.company_id = $2
            `, [projectId, companyId]);
            projectTeamMembersResult.rows.forEach((row) => {
              recipientUserIds.add(row.user_id);
            });
          }
        } else if (activity.projectId) {
          const projectTeamMembersResult = await pool.query(`
            SELECT tm.user_id
            FROM project_teams pt
            JOIN team_members tm ON pt.team_id = tm.team_id
            JOIN users u ON tm.user_id = u.id
            WHERE pt.project_id = $1 AND u.company_id = $2
          `, [activity.projectId, companyId]);
          projectTeamMembersResult.rows.forEach((row) => {
            recipientUserIds.add(row.user_id);
          });
          const projectCreatorResult = await pool.query(`
            SELECT creator_id FROM projects WHERE id = $1
          `, [activity.projectId]);
          if (projectCreatorResult.rows.length > 0 && projectCreatorResult.rows[0].creator_id) {
            recipientUserIds.add(projectCreatorResult.rows[0].creator_id);
          }
        } else if (activity.objectiveId) {
          const objectiveMembersResult = await pool.query(`
            SELECT om.user_id
            FROM objective_members om
            JOIN users u ON om.user_id = u.id
            WHERE om.objective_id = $1 AND u.company_id = $2
          `, [activity.objectiveId, companyId]);
          objectiveMembersResult.rows.forEach((row) => {
            recipientUserIds.add(row.user_id);
          });
          const objectiveCreatorResult = await pool.query(`
            SELECT creator_id FROM objectives WHERE id = $1
          `, [activity.objectiveId]);
          if (objectiveCreatorResult.rows.length > 0 && objectiveCreatorResult.rows[0].creator_id) {
            recipientUserIds.add(objectiveCreatorResult.rows[0].creator_id);
          }
        } else if (activity.protocolId) {
          const protocolParticipantsResult = await pool.query(`
            SELECT participant_ids, team_participant_ids
            FROM meeting_protocols 
            WHERE id = $1
          `, [activity.protocolId]);
          if (protocolParticipantsResult.rows.length > 0) {
            const participantIds = protocolParticipantsResult.rows[0].participant_ids || [];
            participantIds.forEach((userId) => {
              if (userId) recipientUserIds.add(userId);
            });
            const teamIds = protocolParticipantsResult.rows[0].team_participant_ids || [];
            if (teamIds.length > 0) {
              const teamMembersResult = await pool.query(`
                SELECT DISTINCT tm.user_id
                FROM team_members tm
                WHERE tm.team_id = ANY($1)
              `, [teamIds]);
              teamMembersResult.rows.forEach((row) => {
                recipientUserIds.add(row.user_id);
              });
            }
          }
        } else if (activity.teamId) {
          const teamMembersResult = await pool.query(`
            SELECT tm.user_id
            FROM team_members tm
            JOIN users u ON tm.user_id = u.id
            WHERE tm.team_id = $1 AND u.company_id = $2
          `, [activity.teamId, companyId]);
          teamMembersResult.rows.forEach((row) => {
            recipientUserIds.add(row.user_id);
          });
        }
        if (activity.action === "comment" && activity.commentId) {
          if (activity.taskId) {
            const taskResult = await pool.query(`
              SELECT assigned_user_ids, board_id FROM tasks WHERE id = $1
            `, [activity.taskId]);
            if (taskResult.rows.length > 0) {
              if (taskResult.rows[0].board_id) {
                activity.boardId = taskResult.rows[0].board_id;
              }
              if (taskResult.rows[0].assigned_user_ids) {
                const assignedUserIds = taskResult.rows[0].assigned_user_ids;
                assignedUserIds.forEach((userId) => {
                  if (userId) recipientUserIds.add(userId);
                });
              }
            }
          } else if (activity.objectiveId) {
            const objectiveCreatorResult = await pool.query(`
              SELECT creator_id FROM objectives WHERE id = $1
            `, [activity.objectiveId]);
            if (objectiveCreatorResult.rows.length > 0 && objectiveCreatorResult.rows[0].creator_id) {
              recipientUserIds.add(objectiveCreatorResult.rows[0].creator_id);
            }
          }
        }
      } catch (error) {
        console.error("Fehler beim Ermitteln der Benachrichtigungsempf\xE4nger:", error);
      }
      if (activity.userId && recipientUserIds.has(activity.userId)) {
        recipientUserIds.delete(activity.userId);
      }
      if (recipientUserIds.size === 0) {
        console.log(`Keine Empf\xE4nger f\xFCr Aktivit\xE4t ${activity.id} gefunden.`);
        await pool.query(
          `UPDATE activity_logs SET notification_sent = true WHERE id = $1`,
          [activity.id]
        );
        return;
      }
      let title = "Neue Benachrichtigung";
      let message = "Es gibt eine neue Aktivit\xE4t f\xFCr Sie.";
      let link = "/";
      let type = activity.notificationType || "general";
      if (!type || type === "general") {
        switch (activity.action) {
          case "assign":
            type = "assignment";
            break;
          case "mention":
            type = "mention";
            break;
          case "approval":
            type = "approval";
            break;
        }
      }
      if (activity.notificationType) {
        switch (activity.notificationType) {
          // Aufgaben-Benachrichtigungen
          case "task":
            title = "Aufgabenaktualisierung";
            message = activity.details || "Eine Aufgabe wurde aktualisiert.";
            break;
          case "task_update":
            title = "Aufgabenaktualisierung";
            message = activity.details || "Eine Aufgabe wurde aktualisiert.";
            break;
          case "task_delete":
            title = "Aufgabe gel\xF6scht";
            message = activity.details || "Eine Aufgabe wurde gel\xF6scht.";
            break;
          case "task_comment":
            title = "Neuer Kommentar zur Aufgabe";
            message = activity.details || "Es gibt einen neuen Kommentar zu einer Aufgabe.";
            break;
          // Board-Benachrichtigungen
          case "board":
            title = "Board-Aktualisierung";
            message = activity.details || "Ein Board wurde aktualisiert.";
            break;
          case "board_update":
            title = "Board-Update";
            message = activity.details || "Ein Board wurde aktualisiert.";
            break;
          // Protokoll-Benachrichtigungen
          case "protocol":
            title = "Neues Protokoll";
            message = activity.details || "Ein neues Protokoll wurde erstellt.";
            break;
          case "protocol_update":
            title = "Protokoll aktualisiert";
            message = activity.details || "Ein Protokoll wurde aktualisiert.";
            break;
          case "protocol_delete":
            title = "Protokoll gel\xF6scht";
            message = activity.details || "Ein Protokoll wurde gel\xF6scht.";
            break;
          case "protocol_comment":
            title = "Neuer Protokoll-Kommentar";
            message = activity.details || "Es gibt einen neuen Kommentar zu einem Protokoll.";
            break;
          // Projekt-Benachrichtigungen
          case "project":
            title = "Projekt-Aktualisierung";
            message = activity.details || "Ein Projekt wurde aktualisiert.";
            break;
          case "project_update":
            title = "Projekt-Update";
            message = activity.details || "Ein Projekt wurde aktualisiert.";
            break;
          // Team-Benachrichtigungen
          case "team":
            title = "Team-Aktualisierung";
            message = activity.details || "Ein Team wurde aktualisiert.";
            break;
          case "team_update":
            title = "Team-Update";
            message = activity.details || "Ein Team wurde aktualisiert.";
            break;
          // OKR-Benachrichtigungen
          case "okr":
            title = "OKR-Aktualisierung";
            message = activity.details || "Ein OKR wurde aktualisiert.";
            break;
          case "okr_update":
            title = "OKR-Update";
            message = activity.details || "Ein Key Result wurde aktualisiert.";
            break;
          case "okr_delete":
            title = "OKR gel\xF6scht";
            message = activity.details || "Ein Key Result wurde gel\xF6scht.";
            break;
          case "okr_comment":
            title = "Neuer OKR-Kommentar";
            message = activity.details || "Es gibt einen neuen Kommentar zu einem OKR.";
            break;
          // Allgemeine Benachrichtigungen
          case "comment":
            title = "Neuer Kommentar";
            message = activity.details || "Es gibt einen neuen Kommentar.";
            break;
          case "assignment":
            title = "Neue Zuweisung";
            message = activity.details || "Ihnen wurde ein Element zugewiesen.";
            break;
          case "mention":
            title = "Erw\xE4hnung";
            message = activity.details || "Sie wurden in einem Kommentar erw\xE4hnt.";
            break;
          case "approval":
            title = "Freigabeanfrage";
            message = activity.details || "Eine Freigabe wird ben\xF6tigt.";
            break;
          default:
            switch (activity.action) {
              case "create":
                title = "Neues Element erstellt";
                message = activity.details || "Ein neues Element wurde erstellt.";
                break;
              case "update":
                title = "Element aktualisiert";
                message = activity.details || "Ein Element wurde aktualisiert.";
                break;
              case "delete":
                title = "Element gel\xF6scht";
                message = activity.details || "Ein Element wurde gel\xF6scht.";
                break;
              case "assign":
                title = "Zuweisung";
                message = activity.details || "Ein Element wurde Ihnen zugewiesen.";
                break;
              case "mention":
                title = "Erw\xE4hnung";
                message = activity.details || "Sie wurden in einem Kommentar erw\xE4hnt.";
                break;
              case "comment":
                title = "Neuer Kommentar";
                message = activity.details || "Es gibt einen neuen Kommentar.";
                break;
              case "approval":
                title = "Freigabeanfrage";
                message = activity.details || "Eine Freigabe wird ben\xF6tigt.";
                break;
            }
        }
      } else {
        switch (activity.action) {
          case "create":
            title = "Neues Element erstellt";
            message = activity.details || "Ein neues Element wurde erstellt.";
            break;
          case "update":
            title = "Element aktualisiert";
            message = activity.details || "Ein Element wurde aktualisiert.";
            break;
          case "delete":
            title = "Element gel\xF6scht";
            message = activity.details || "Ein Element wurde gel\xF6scht.";
            break;
          case "assign":
            title = "Zuweisung";
            message = activity.details || "Ein Element wurde Ihnen zugewiesen.";
            break;
          case "mention":
            title = "Erw\xE4hnung";
            message = activity.details || "Sie wurden in einem Kommentar erw\xE4hnt.";
            break;
          case "comment":
            title = "Neuer Kommentar";
            message = activity.details || "Es gibt einen neuen Kommentar.";
            break;
          case "approval":
            title = "Freigabeanfrage";
            message = activity.details || "Eine Freigabe wird ben\xF6tigt.";
            break;
        }
      }
      if (activity.taskId) {
        if (!activity.boardId) {
          try {
            const boardResult = await pool.query(
              "SELECT board_id FROM tasks WHERE id = $1",
              [activity.taskId]
            );
            if (boardResult.rows.length > 0 && boardResult.rows[0].board_id) {
              activity.boardId = boardResult.rows[0].board_id;
            }
          } catch (error) {
            console.error(`Failed to get board_id for task ${activity.taskId}:`, error);
          }
        }
        if (activity.boardId) {
          link = `/boards/${activity.boardId}`;
          if (type === "general") type = "task";
        } else {
          link = "/";
          console.warn(`Warning: No board_id found for task ${activity.taskId}, using home page as fallback link`);
        }
      } else if (activity.boardId) {
        link = `/boards/${activity.boardId}`;
        if (type === "general") type = "board";
      } else if (activity.projectId) {
        link = `/projects/${activity.projectId}`;
        if (type === "general") type = "project";
      } else if (activity.objectiveId) {
        link = `/all-okrs/${activity.objectiveId}`;
        if (type === "general") type = "okr";
      } else if (activity.protocolId) {
        if (activity.projectId) {
          link = `/projects/${activity.projectId}/protocols/${activity.protocolId}`;
        } else if (activity.teamId) {
          link = `/teams/${activity.teamId}/protocols/${activity.protocolId}`;
        } else {
          link = `/protocols/${activity.protocolId}`;
        }
        if (type === "general") type = "protocol";
      } else {
        link = "/";
      }
      const uniqueRecipientIds = Array.from(new Set(recipientUserIds));
      for (const recipientId of uniqueRecipientIds) {
        if (recipientId === activity.userId) continue;
        await this.createNotification(recipientId, title, message, type, link);
      }
      await pool.query(
        `UPDATE activity_logs SET notification_sent = true WHERE id = $1`,
        [activityLogId]
      );
    } catch (error) {
      console.error("Failed to process activity log for notifications:", error);
    }
  }
  /**
   * Erstellt Benachrichtigungen für alle unverarbeiteten Aktivitätslogs
   * Optimiert für Serverstart: Verzögert die Verarbeitung und begrenzt die Anzahl 
   */
  async processAllPendingActivityLogs() {
    try {
      console.log("Notification processing optimiert: Server startet schneller");
      setTimeout(async () => {
        try {
          const checkColumnsExist = async () => {
            try {
              const result = await pool.query(`
                SELECT column_name FROM information_schema.columns 
                WHERE table_name = 'activity_logs' 
                AND column_name IN ('requires_notification', 'notification_sent')
              `);
              return result.rows.length === 2;
            } catch (error) {
              console.warn("Activity logs notification columns may not exist yet:", error);
              return false;
            }
          };
          if (await checkColumnsExist()) {
            const pendingLogsResult = await pool.query(`
              SELECT id FROM activity_logs 
              WHERE requires_notification = true AND notification_sent = false
              ORDER BY id DESC LIMIT 20
            `);
            console.log(`Verarbeite ${pendingLogsResult.rows.length} neueste unverarbeitete Benachrichtigungen`);
            await pool.query(`
              UPDATE activity_logs 
              SET notification_sent = true 
              WHERE requires_notification = true 
              AND notification_sent = false 
              AND id NOT IN (
                SELECT id FROM activity_logs 
                WHERE requires_notification = true AND notification_sent = false
                ORDER BY id DESC LIMIT 20
              )
            `);
            for (const log2 of pendingLogsResult.rows) {
              await this.processActivityLog(log2.id);
            }
          } else {
            console.log("Skipping notification processing, columns not ready");
          }
        } catch (error) {
          console.error("Failed to process pending activity logs in background:", error);
        }
      }, 1e4);
      console.log("Benachrichtigungsverarbeitung wird verz\xF6gert f\xFCr schnelleren Serverstart");
    } catch (error) {
      console.error("Failed to setup delayed notification processing:", error);
    }
  }
};
var notificationService = new NotificationService();

// server/routes.ts
init_subscription_service();

// server/taskLimitMiddleware.ts
init_subscription_service();
init_storage();
init_db();
import { sql as sql4 } from "drizzle-orm";
async function checkTaskLimit(req, res, next) {
  try {
    const userId = req.userId;
    const user = await storage.getUser(userId, userId);
    if (!user.companyId) {
      const taskCountResult = await db.execute(
        sql4`SELECT COUNT(*) as count FROM tasks WHERE assigned_user_ids && ARRAY[${userId}]`
      );
      const taskCount = parseInt(String(taskCountResult.rows[0]?.count) || "0");
      if (taskCount >= 10) {
        return res.status(403).json({
          message: "Aufgaben-Limit erreicht",
          details: "Das Aufgaben-Limit (10) f\xFCr Ihr kostenloses Abonnement wurde erreicht. Bitte upgraden Sie Ihr Abonnement, um weitere Aufgaben zu erstellen.",
          limitReached: true,
          currentPlan: "free"
        });
      }
    } else {
      const hasReachedLimit = await subscriptionService.hasReachedTaskLimit(user.companyId);
      if (hasReachedLimit) {
        const plan = await subscriptionService.getCurrentSubscriptionName(user.companyId);
        return res.status(403).json({
          message: "Aufgaben-Limit erreicht",
          details: "Das Aufgaben-Limit f\xFCr Ihr Abonnement wurde erreicht. Bitte upgraden Sie Ihr Abonnement, um weitere Aufgaben zu erstellen.",
          limitReached: true,
          currentPlan: plan || "free"
        });
      }
    }
    next();
  } catch (error) {
    console.error("Error checking task limit:", error);
    next();
  }
}

// server/routes.ts
var avatarUpload = multer({
  storage: multer.diskStorage({
    destination: "./uploads/avatars",
    filename: (req, file, cb) => {
      const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
      cb(null, file.fieldname + "-" + uniqueSuffix + path2.extname(file.originalname));
    }
  }),
  fileFilter: (req, file, cb) => {
    const allowedTypes = ["image/jpeg", "image/png", "image/gif"];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error("Invalid file type. Only JPEG, PNG and GIF are allowed."));
    }
  },
  limits: {
    fileSize: 5 * 1024 * 1024
    // 5MB
  }
});
var fileUpload = multer({
  storage: multer.diskStorage({
    destination: (req, file, cb) => {
      const type = req.body.type || "general";
      let uploadDir = "./uploads/attachments";
      switch (type) {
        case "task":
          uploadDir = "./uploads/attachments/tasks";
          break;
        case "objective":
          uploadDir = "./uploads/attachments/objectives";
          break;
        case "keyResult":
          uploadDir = "./uploads/attachments/key-results";
          break;
        case "comment":
          uploadDir = "./uploads/attachments/comments";
          break;
        default:
          uploadDir = "./uploads/attachments";
      }
      ensureDirectoryExists(uploadDir);
      cb(null, uploadDir);
    },
    filename: (req, file, cb) => {
      const secureFilename = generateSecureFilename(file.originalname);
      cb(null, secureFilename);
    }
  }),
  fileFilter: (req, file, cb) => {
    const allowedTypes = [
      // Bilder
      "image/jpeg",
      "image/png",
      "image/gif",
      "image/webp",
      "image/svg+xml",
      // Dokumente
      "application/pdf",
      "application/msword",
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      "application/vnd.ms-excel",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      "application/vnd.ms-powerpoint",
      "application/vnd.openxmlformats-officedocument.presentationml.presentation",
      // Text
      "text/plain",
      "text/csv",
      "text/html",
      // Archiv
      "application/zip",
      "application/x-rar-compressed"
    ];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error("Dateityp nicht erlaubt. Erlaubte Typen sind Bilder, Dokumente, und Archivdateien."));
    }
  },
  limits: {
    fileSize: 25 * 1024 * 1024
    // 25MB
  }
});
ensureDirectoryExists("./uploads/avatars");
ensureDirectoryExists("./uploads/attachments");
ensureDirectoryExists("./uploads/attachments/tasks");
ensureDirectoryExists("./uploads/attachments/objectives");
ensureDirectoryExists("./uploads/attachments/key-results");
ensureDirectoryExists("./uploads/attachments/comments");
async function registerRoutes(app2, db5) {
  app2.get("/api/health", (_req, res) => {
    res.json({ status: "ok" });
  });
  app2.get("/api/auth/current-user", optionalAuth, async (req, res) => {
    try {
      if (!req.userId) {
        return res.json(null);
      }
      const user = await storage.getUser(req.userId, req.userId);
      if (!user) {
        return res.json(null);
      }
      const { passwordHash: _, ...userWithoutPassword } = user;
      res.json(userWithoutPassword);
    } catch (error) {
      console.error("Error fetching current user:", error);
      res.status(500).json({ message: "Fehler beim Abrufen des aktuellen Benutzers" });
    }
  });
  app2.post("/api/auth/register", async (req, res) => {
    const result = insertUserSchema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({ message: result.error.message });
    }
    try {
      const existingUser = await storage.getUserByEmail(0, result.data.email);
      if (existingUser) {
        return res.status(400).json({ message: "Benutzer existiert bereits" });
      }
      let subscriptionPackageId = null;
      if (req.body.subscriptionPackageId) {
        if (typeof req.body.subscriptionPackageId === "number") {
          subscriptionPackageId = req.body.subscriptionPackageId;
        } else if (typeof req.body.subscriptionPackageId === "string") {
          subscriptionPackageId = parseInt(req.body.subscriptionPackageId, 10);
        }
      }
      if (subscriptionPackageId === null && result.data.subscriptionPackageId) {
        if (typeof result.data.subscriptionPackageId === "number") {
          subscriptionPackageId = result.data.subscriptionPackageId;
        } else if (typeof result.data.subscriptionPackageId === "string") {
          subscriptionPackageId = parseInt(result.data.subscriptionPackageId, 10);
        }
      }
      console.log("\u2705 Empfangene subscriptionPackageId:", subscriptionPackageId, typeof subscriptionPackageId);
      console.log("\u2705 Raw request body:", req.body);
      const receivedFreelancerPackage = subscriptionPackageId === 2;
      if (receivedFreelancerPackage) {
        console.log("\u2705\u2705\u2705 FREELANCER PACKAGE DIREKT ERKANNT IN REQUEST DATEN! ID=2");
      }
      const packageQuery = await pool.query(
        "SELECT * FROM subscription_packages WHERE id = $1",
        [subscriptionPackageId]
      );
      const requiresCompany = packageQuery.rowCount > 0 && packageQuery.rows[0].requires_company;
      let companyInfo = null;
      const isRegistrationWithCompanyInvite = result.data.inviteCode && result.data.inviteCode !== "auto-generated";
      const inviteCode = result.data.inviteCode;
      const companyData = req.body.company;
      console.log("\u{1F3E2} Empfangene Unternehmensdaten:", companyData);
      if (companyData && packageQuery.rowCount && packageQuery.rowCount > 0 && packageQuery.rows[0].requires_company) {
        try {
          console.log("\u{1F3E2} Erstelle neues Unternehmen mit Daten:", companyData);
          const randomCode = Math.random().toString(36).substring(2, 8).toUpperCase();
          const companyInsertResult = await pool.query(
            `INSERT INTO companies 
            (name, address, city, zip, country, invite_code, is_active, created_at, updated_at) 
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
            RETURNING *`,
            [
              companyData.name,
              companyData.address,
              companyData.city,
              companyData.zip,
              companyData.country,
              randomCode,
              true,
              /* @__PURE__ */ new Date(),
              /* @__PURE__ */ new Date()
            ]
          );
          if (companyInsertResult.rowCount > 0) {
            companyInfo = companyInsertResult.rows[0];
            console.log("\u{1F3E2} Unternehmen erfolgreich erstellt:", {
              id: companyInfo.id,
              name: companyInfo.name
            });
          } else {
            console.error("Fehler beim Erstellen des Unternehmens - keine Daten zur\xFCckgegeben");
          }
        } catch (error) {
          console.error("Fehler beim Erstellen des Unternehmens:", error);
          return res.status(500).json({ message: "Fehler beim Erstellen des Unternehmens" });
        }
      } else if (isRegistrationWithCompanyInvite) {
        if (!inviteCode || inviteCode.length < 6) {
          return res.status(400).json({ message: "G\xFCltiger Einladungscode ist erforderlich f\xFCr Einladungen" });
        }
        const companyQuery = await pool.query(
          "SELECT * FROM companies WHERE invite_code = $1",
          [inviteCode]
        );
        console.log("Company database query result:", {
          rowCount: companyQuery.rowCount,
          rows: companyQuery.rows.map((r) => ({ id: r.id, name: r.name }))
        });
        if (companyQuery.rowCount === 0) {
          return res.status(400).json({ message: "Ung\xFCltiger Einladungscode" });
        }
        companyInfo = companyQuery.rows[0];
        console.log("G\xFCltiger Firmencode gefunden. Firma zugewiesen:", {
          id: companyInfo.id,
          name: companyInfo.name
        });
      }
      if (!isRegistrationWithCompanyInvite) {
        result.data.inviteCode = null;
      }
      let subscriptionTier = "free";
      let needsPayment = false;
      let packageInfo = null;
      if (subscriptionPackageId) {
        const packageResult = await pool.query(
          "SELECT * FROM subscription_packages WHERE id = $1",
          [subscriptionPackageId]
        );
        console.log("\u2757\u2757\u2757 DIAGNOSE PAKET-ABFRAGE BEGINN \u2757\u2757\u2757");
        console.log("Paket-SQL-Abfrage f\xFCr ID", subscriptionPackageId, "hat", packageResult.rowCount, "Ergebnisse");
        console.log("Vollst\xE4ndiges SQL-Ergebnis:", JSON.stringify(packageResult.rows, null, 2));
        if (packageResult.rowCount > 0) {
          packageInfo = packageResult.rows[0];
          console.log("Ausgew\xE4hltes Paket Details:", {
            id: packageInfo.id,
            name: packageInfo.name,
            price: packageInfo.price,
            priceType: typeof packageInfo.price,
            priceLength: String(packageInfo.price).length,
            priceValue: String(packageInfo.price),
            subscriptionPackageId
          });
          subscriptionTier = packageInfo.name;
          if (packageInfo.id === 2 || receivedFreelancerPackage) {
            console.log("\u{1F534}\u{1F534}\u{1F534} ABSOLUT KRITISCHER SPEZIELLER FALL: FREELANCER-PAKET ERKANNT (ID 2)");
            subscriptionTier = "freelancer";
            needsPayment = true;
            console.log("\u{1F534}\u{1F534}\u{1F534} WERTE GESETZT: subscriptionTier='freelancer', needsPayment=true");
          } else {
            const priceString = String(packageInfo.price).trim();
            const packagePrice = parseInt(priceString, 10);
            console.log("Preis-Analyse:", {
              priceString,
              priceStringLength: priceString.length,
              packagePrice,
              packagePriceType: typeof packagePrice,
              comparison: packagePrice > 0,
              test1200: 1200 > 0,
              priceChars: [...priceString].map((c) => c.charCodeAt(0))
            });
            needsPayment = packagePrice > 0;
          }
          console.log(
            "needsPayment wurde gesetzt auf:",
            needsPayment,
            "basierend auf Paket:",
            {
              id: packageInfo.id,
              name: packageInfo.name,
              preis: packageInfo.price
            }
          );
        } else {
          console.error("Keine Paketinformationen gefunden f\xFCr ID:", subscriptionPackageId);
        }
        console.log("\u2757\u2757\u2757 DIAGNOSE PAKET-ABFRAGE ENDE \u2757\u2757\u2757");
      }
      const salt = await bcrypt.genSalt(10);
      const passwordHash = await bcrypt.hash(result.data.password, salt);
      let isFreelancerPackage = packageInfo && packageInfo.id === 2 || receivedFreelancerPackage;
      let isActive = subscriptionTier === "organisation" || subscriptionTier === "enterprise";
      console.log("\u{1F525}\u{1F525}\u{1F525} FINAL PRE-INSERT WERTE:", {
        username: result.data.username,
        email: result.data.email,
        companyId: companyInfo?.id,
        subscriptionTier,
        subscriptionPackageId,
        needsPayment,
        isFreelancerPackage
      });
      if (isFreelancerPackage) {
        subscriptionTier = "freelancer";
        needsPayment = true;
        isActive = false;
        console.log("\u{1F525}\u{1F525}\u{1F525} FREELANCER PAKET ERKANNT - Setze subscriptionTier=freelancer, needsPayment=true");
      }
      const finalSubscriptionTier = packageInfo && packageInfo.id === 2 || receivedFreelancerPackage ? "freelancer" : subscriptionTier;
      const userResult = await pool.query(
        `INSERT INTO users 
        (username, email, password_hash, company_id, is_active, is_company_admin, subscription_tier) 
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING *`,
        [
          result.data.username,
          result.data.email,
          passwordHash,
          companyInfo?.id || null,
          isActive || false,
          false,
          // is_company_admin
          finalSubscriptionTier
          // Verwende den korrekten subscription_tier
        ]
      );
      if (userResult.rowCount === 0) {
        throw new Error("Fehler beim Erstellen des Benutzers - keine Daten zur\xFCckgegeben");
      }
      const user = userResult.rows[0];
      let subscriptionId = isFreelancerPackage ? -1 : null;
      if (isFreelancerPackage) {
        needsPayment = true;
        console.log("\u{1F525}\u{1F525}\u{1F525} FINAL FREELANCER CONFIRMATION AFTER USER INSERT - SETTING needsPayment=true!");
      }
      if (needsPayment && packageInfo || isFreelancerPackage) {
        console.log("\u{1F534} Erstelle vorl\xE4ufiges Abonnement f\xFCr Benutzer:", user.id, "mit Paket:", subscriptionPackageId);
        console.log("\u{1F534} needsPayment ist:", needsPayment, "isFreelancerPackage:", isFreelancerPackage);
        if (isFreelancerPackage) {
          console.log("\u{1F534}\u{1F534}\u{1F534} ABSOLUT KRITISCHER FALL: ERSTELLE SPEZIAL-ABONNEMENT F\xDCR FREELANCER");
        }
        try {
          console.log("Versuche direkten SQL-Eintrag f\xFCr Subscription...");
          const subscriptionDirectInsert = await pool.query(
            `INSERT INTO subscriptions (user_id, package_id, status, created_at, updated_at)
             VALUES ($1, $2, $3, $4, $5)
             RETURNING id`,
            [user.id, subscriptionPackageId, "pending", /* @__PURE__ */ new Date(), /* @__PURE__ */ new Date()]
          );
          if (subscriptionDirectInsert.rows && subscriptionDirectInsert.rows.length > 0) {
            subscriptionId = subscriptionDirectInsert.rows[0].id;
            console.log("\u{1F534} Subscription via DirectSQL erfolgreich erstellt mit ID:", subscriptionId);
          } else {
            console.log("\u{1F534} DirectSQL-Einf\xFCgung ergab keine ID, setze Fallback-ID");
            subscriptionId = -1;
          }
        } catch (error) {
          console.error("Fehler beim Erstellen der Subscription:", error);
          subscriptionId = -1;
        }
      } else {
        console.log("Kein kostenpflichtiges Paket oder keine Paketinformationen - keine Subscription erstellt", {
          needsPayment,
          packageId: packageInfo?.id
        });
      }
      const userResponse = {
        id: user.id,
        username: user.username,
        email: user.email,
        avatarUrl: user.avatar_url,
        companyId: user.company_id,
        isCompanyAdmin: user.is_company_admin,
        isActive: user.is_active,
        createdAt: user.created_at,
        needsPayment: isFreelancerPackage ? true : needsPayment,
        // Erzwinge true für Freelancer
        subscriptionId,
        // Subscription ID für Checkout
        subscriptionTier,
        // Wir geben das Subscription Tier explizit zurück
        isFreelancerPackage
        // Extra Information für das Frontend
      };
      console.log("========== FINALER REGISTRIERUNGSSTAND ==========");
      console.log("Ausgew\xE4hltes Paket, Parameter:", subscriptionPackageId);
      console.log("Paket-Info:", {
        name: packageInfo?.name,
        preis: packageInfo?.price,
        preisTyp: typeof packageInfo?.price,
        id: packageInfo?.id
      });
      console.log("needsPayment:", needsPayment, "| subscriptionId:", subscriptionId);
      console.log("User response:", userResponse);
      console.log("===============================================");
      res.status(201).json(userResponse);
    } catch (error) {
      console.error("Failed to create user:", error);
      res.status(500).json({ message: "Benutzerregistrierung fehlgeschlagen" });
    }
  });
  app2.post("/api/auth/login", async (req, res) => {
    try {
      console.log("Login attempt with data:", {
        email: req.body.email,
        passwordProvided: !!req.body.password
      });
      const { email, password } = req.body;
      if (!email || !password) {
        console.log("Missing credentials:", { email: !!email, password: !!password });
        return res.status(400).json({ message: "E-Mail und Passwort sind erforderlich" });
      }
      const userQuery = await pool.query(
        `SELECT * FROM users WHERE email = $1 LIMIT 1`,
        [email]
      );
      console.log("User lookup SQL result:", {
        rowCount: userQuery.rowCount,
        userFound: userQuery.rowCount > 0
      });
      if (userQuery.rowCount === 0) {
        return res.status(400).json({ message: "Ung\xFCltige Anmeldedaten" });
      }
      const user = userQuery.rows[0];
      console.log("Found user:", {
        id: user.id,
        username: user.username,
        email: user.email,
        companyId: user.company_id,
        hasPasswordHash: !!user.password_hash
      });
      const passwordHash = user.password_hash;
      console.log("Password comparison:", {
        password,
        hash: passwordHash,
        hashType: typeof passwordHash,
        hashLength: passwordHash?.length
      });
      const isValid = await bcrypt.compare(password, passwordHash);
      console.log("Password verification result:", { isValid });
      if (!isValid) {
        return res.status(400).json({ message: "Ung\xFCltige Anmeldedaten" });
      }
      if (user.subscription_tier !== "free" && user.subscription_tier !== "freelancer" && user.subscription_tier !== "organisation" && user.subscription_tier !== "enterprise" && user.is_active === false) {
        return res.status(403).json({
          message: "Ihr Konto wurde noch nicht aktiviert. Bitte warten Sie auf die Aktivierung durch einen Administrator.",
          isActive: false
        });
      }
      if (user.subscription_tier === "freelancer") {
        console.log("\u{1F525}\u{1F525}\u{1F525} FREELANCER LOGIN ERFOLGREICH \u{1F525}\u{1F525}\u{1F525}", {
          tier: user.subscription_tier,
          isActive: user.is_active
        });
      }
      if (user.is_paused) {
        return res.status(403).json({
          message: `Ihr Konto wurde pausiert. Grund: ${user.pause_reason || "Kein Grund angegeben."}`,
          isPaused: true
        });
      }
      if (user.company_id) {
        const companyQuery = await pool.query(
          `SELECT * FROM companies WHERE id = $1 LIMIT 1`,
          [user.company_id]
        );
        if (companyQuery.rowCount > 0) {
          const companyInfo = companyQuery.rows[0];
          if (companyInfo.is_paused) {
            return res.status(403).json({
              message: `Ihr Unternehmen wurde pausiert. Grund: ${companyInfo.pause_reason || "Kein Grund angegeben."}`,
              isCompanyPaused: true
            });
          }
        }
      }
      if (req.session) {
        req.session.userId = user.id;
        try {
          await pool.query(
            `UPDATE users SET last_login_at = NOW() WHERE id = $1`,
            [user.id]
          );
          console.log("Updated last login timestamp for user:", user.id);
        } catch (updateError) {
          console.error("Failed to update last login timestamp:", updateError);
        }
        console.log("Session set for user:", user.id);
      } else {
        console.log("No session object available");
      }
      const userResponse = {
        id: user.id,
        username: user.username,
        email: user.email,
        avatarUrl: user.avatar_url,
        companyId: user.company_id,
        isCompanyAdmin: user.is_company_admin,
        isActive: user.is_active,
        lastLoginAt: user.last_login_at,
        subscriptionTier: user.subscription_tier,
        subscriptionExpiresAt: user.subscription_expires_at,
        createdAt: user.created_at
      };
      res.json(userResponse);
    } catch (error) {
      console.error("Login error:", error);
      res.status(500).json({ message: "Anmeldefehler" });
    }
  });
  app2.patch("/api/companies/:companyId/users/:userId/activate", requireAuth, async (req, res) => {
    try {
      const companyId = parseInt(req.params.companyId);
      const targetUserId = parseInt(req.params.userId);
      const adminUserId = req.userId;
      const { activate = true } = req.body;
      if (isNaN(companyId) || isNaN(targetUserId)) {
        return res.status(400).json({ message: "Ung\xFCltige Benutzer- oder Unternehmens-ID" });
      }
      const adminQuery = await pool.query(
        "SELECT * FROM users WHERE id = $1",
        [adminUserId]
      );
      if (adminQuery.rowCount === 0) {
        return res.status(404).json({ message: "Admin-Benutzer nicht gefunden" });
      }
      const admin = adminQuery.rows[0];
      if (!admin.company_id || !admin.is_company_admin || admin.company_id !== companyId) {
        return res.status(403).json({
          message: "Sie haben keine Berechtigung, Benutzer zu aktivieren oder zu deaktivieren"
        });
      }
      const targetUserQuery = await pool.query(
        "SELECT * FROM users WHERE id = $1",
        [targetUserId]
      );
      if (targetUserQuery.rowCount === 0) {
        return res.status(404).json({ message: "Zielbenutzer nicht gefunden" });
      }
      const targetUser = targetUserQuery.rows[0];
      if (targetUser.company_id !== companyId) {
        return res.status(404).json({
          message: "Benutzer nicht gefunden oder nicht in Ihrem Unternehmen"
        });
      }
      const companyPaymentInfoQuery = await pool.query(`
        SELECT * FROM company_payment_info WHERE company_id = $1
      `, [companyId]);
      const companyQuery = await pool.query(`
        SELECT * FROM companies WHERE id = $1
      `, [companyId]);
      let subscriptionTier = "free";
      if (companyQuery.rowCount > 0 && companyQuery.rows[0].subscription_tier) {
        subscriptionTier = companyQuery.rows[0].subscription_tier;
        console.log(`Unternehmen ${companyId} hat Abonnement-Tier (aus companies-Tabelle): ${subscriptionTier}`);
      } else if (companyPaymentInfoQuery.rowCount > 0) {
        subscriptionTier = companyPaymentInfoQuery.rows[0].subscription_tier;
        console.log(`Unternehmen ${companyId} hat Abonnement-Tier (aus payment_info): ${subscriptionTier}`);
      } else {
        subscriptionTier = "enterprise";
        console.log(`Keine Zahlungsinformationen f\xFCr Unternehmen ${companyId} gefunden, verwende Standard-Tier: ${subscriptionTier}`);
      }
      const result = await pool.query(`
        UPDATE users 
        SET is_active = $1, subscription_tier = $2
        WHERE id = $3
        RETURNING *
      `, [activate, subscriptionTier, targetUserId]);
      if (result.rowCount === 0) {
        return res.status(500).json({ message: "Fehler beim Aktualisieren des Benutzerstatus" });
      }
      const updatedUser = result.rows[0];
      console.log(`Benutzer ${targetUserId} wurde ${activate ? "aktiviert" : "deaktiviert"} und erh\xE4lt Abonnement-Tier: ${subscriptionTier}`);
      const actionDetails = activate ? `Benutzer ${targetUser.username} aktiviert` : `Benutzer ${targetUser.username} deaktiviert`;
      try {
        await pool.query(`
          INSERT INTO activity_logs (action, details, user_id)
          VALUES ($1, $2, $3)
        `, ["update", actionDetails, adminUserId]);
      } catch (error) {
        console.error("Fehler beim Erstellen des Aktivit\xE4tslogs:", error);
      }
      const userResponse = {
        id: updatedUser.id,
        username: updatedUser.username,
        email: updatedUser.email,
        avatarUrl: updatedUser.avatar_url,
        companyId: updatedUser.company_id,
        isCompanyAdmin: updatedUser.is_company_admin,
        isActive: updatedUser.is_active,
        createdAt: updatedUser.created_at,
        subscriptionTier: updatedUser.subscription_tier
        // Wichtig: Abonnement-Tier hinzufügen
      };
      res.json(userResponse);
    } catch (error) {
      console.error("Fehler beim \xC4ndern des Benutzerstatus:", error);
      res.status(500).json({ message: "Fehler beim \xC4ndern des Benutzerstatus" });
    }
  });
  app2.get("/api/companies/:companyId/users/pending", requireAuth, async (req, res) => {
    try {
      const companyId = parseInt(req.params.companyId);
      const adminUserId = req.userId;
      if (isNaN(companyId)) {
        return res.status(400).json({ message: "Ung\xFCltige Unternehmens-ID" });
      }
      const adminQuery = await pool.query(
        "SELECT * FROM users WHERE id = $1",
        [adminUserId]
      );
      if (adminQuery.rowCount === 0) {
        return res.status(404).json({ message: "Admin-Benutzer nicht gefunden" });
      }
      const admin = adminQuery.rows[0];
      if (!admin.company_id || !admin.is_company_admin || admin.company_id !== companyId) {
        return res.status(403).json({
          message: "Sie haben keine Berechtigung, ausstehende Benutzer zu sehen"
        });
      }
      const pendingUsersQuery = await pool.query(
        `SELECT id, username, email, avatar_url, created_at, subscription_tier 
         FROM users 
         WHERE company_id = $1 AND is_active = false`,
        [companyId]
      );
      const pendingUsers = pendingUsersQuery.rows.map((user) => ({
        id: user.id,
        username: user.username,
        email: user.email,
        avatarUrl: user.avatar_url,
        createdAt: user.created_at,
        subscriptionTier: user.subscription_tier
        // Wichtig: Abonnement-Tier hinzufügen
      }));
      res.json(pendingUsers);
    } catch (error) {
      console.error("Fehler beim Abrufen ausstehender Benutzer:", error);
      res.status(500).json({ message: "Fehler beim Abrufen ausstehender Benutzer" });
    }
  });
  app2.get("/api/users", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      const userResult = await pool.query(
        "SELECT company_id FROM users WHERE id = $1",
        [userId]
      );
      if (userResult.rows.length === 0 || !userResult.rows[0].company_id) {
        return res.json([]);
      }
      const companyId = userResult.rows[0].company_id;
      const companyUsers = await pool.query(
        `SELECT id, username, email, avatar_url, company_id, 
         is_company_admin, is_active, created_at, subscription_tier
         FROM users WHERE company_id = $1 AND is_active = TRUE`,
        [companyId]
      );
      const users2 = companyUsers.rows.map((user) => ({
        id: user.id,
        username: user.username,
        email: user.email,
        avatarUrl: user.avatar_url,
        companyId: user.company_id,
        isCompanyAdmin: user.is_company_admin,
        isActive: user.is_active,
        createdAt: user.created_at,
        subscriptionTier: user.subscription_tier
        // Wichtig: Abonnement-Tier hinzufügen
      }));
      res.json(users2);
    } catch (error) {
      console.error("Failed to fetch users:", error);
      res.status(500).json({ message: "Failed to fetch users" });
    }
  });
  app2.get("/api/users/:id", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    try {
      const userId = req.userId;
      const user = await storage.getUser(userId, id);
      const { passwordHash: _, ...userWithoutPassword } = user;
      res.json(userWithoutPassword);
    } catch (error) {
      console.error("Failed to fetch user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });
  app2.patch("/api/profile", requireAuth, async (req, res) => {
    try {
      const userId = req.body.userId;
      const { username, email, currentPassword, newPassword } = req.body;
      if (currentPassword && newPassword) {
        const user = await storage.getUser(userId);
        if (!user) {
          return res.status(404).json({ message: "User not found" });
        }
        const isValid = await bcrypt.compare(currentPassword, user.passwordHash);
        if (!isValid) {
          return res.status(400).json({ message: "Current password is incorrect" });
        }
        const salt = await bcrypt.genSalt(10);
        const passwordHash = await bcrypt.hash(newPassword, salt);
        await storage.updateUserPassword(userId, passwordHash);
      }
      if (username || email) {
        const updateData = {};
        if (username) updateData.username = username;
        if (email) {
          try {
            await storage.updateUserEmail(userId, email);
          } catch (error) {
            return res.status(400).json({ message: error.message });
          }
        }
        if (Object.keys(updateData).length > 0) {
          const updatedUser = await storage.updateUser(userId, updateData);
          const { passwordHash: _, ...userWithoutPassword } = updatedUser;
          return res.json(userWithoutPassword);
        }
      }
      res.json({ message: "Profile updated successfully" });
    } catch (error) {
      console.error("Failed to update profile:", error);
      res.status(500).json({ message: "Failed to update profile" });
    }
  });
  app2.get("/api/projects", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      const projects3 = await storage.getProjects(userId);
      res.json(projects3);
    } catch (error) {
      console.error("Failed to fetch projects:", error);
      res.status(500).json({ message: "Failed to fetch projects" });
    }
  });
  app2.get("/api/projects/:id", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Invalid project ID" });
    }
    try {
      const userId = req.userId;
      const project = await storage.getProject(userId, id);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      res.json(project);
    } catch (error) {
      console.error("Failed to fetch project:", error);
      res.status(500).json({ message: "Failed to fetch project" });
    }
  });
  app2.post("/api/projects", requireAuth, async (req, res) => {
    console.log("POST /api/projects aufgerufen");
    const result = insertProjectSchema.safeParse(req.body);
    if (!result.success) {
      console.log("Fehler bei der Validierung des Projekts:", result.error.message);
      return res.status(400).json({ message: result.error.message });
    }
    try {
      const userId = req.userId;
      if (!userId) {
        console.log("Keine Benutzer-ID gefunden in der Anfrage");
        return res.status(400).json({ message: "User ID is required" });
      }
      console.log("Projekt-Erstellung f\xFCr Benutzer-ID:", userId);
      const user = await storage.getUser(userId, userId);
      console.log("Projekt-Erstellung: Benutzer gefunden:", {
        userId,
        username: user.username,
        companyId: user.companyId,
        subscriptionTier: user.subscriptionTier || "free"
      });
      let hasReachedLimit = false;
      if (!user.companyId) {
        result.data.companyId = null;
        console.log("Setze companyId auf null f\xFCr Benutzer ohne Firma");
      }
      if (user.companyId) {
        const projectCountResult = await pool.query(
          "SELECT COUNT(*) as count FROM projects WHERE company_id = $1 AND archived = false",
          [user.companyId]
        );
        const projectCount = parseInt(String(projectCountResult.rows?.[0]?.count) || "0");
        console.log(`DIREKTE Z\xC4HLUNG: Unternehmen ${user.companyId} hat ${projectCount} Projekte`);
        hasReachedLimit = await subscriptionService.hasReachedProjectLimit(user.companyId);
        console.log("Projektlimit-Pr\xFCfung (Firma):", {
          companyId: user.companyId,
          hasReachedLimit,
          subscriptionTier: user.subscriptionTier || "free"
        });
      } else {
        const projectCountResult = await pool.query(
          "SELECT COUNT(*) as count FROM projects WHERE creator_id = $1 AND company_id IS NULL AND archived = false",
          [userId]
        );
        const projectCount = parseInt(String(projectCountResult.rows?.[0]?.count) || "0");
        console.log(`DIREKTE Z\xC4HLUNG: Benutzer ${userId} hat ${projectCount} pers\xF6nliche Projekte`);
        const subscriptionTier = user.subscriptionTier || "free";
        const maxProjects = subscriptionTier === "free" ? 1 : subscriptionTier === "freelancer" ? 3 : 10;
        hasReachedLimit = projectCount >= maxProjects;
        console.log("Projektlimit-Pr\xFCfung (Einzelbenutzer):", {
          userId,
          projectCount,
          maxProjects,
          subscriptionTier,
          hasReachedLimit
        });
      }
      if (hasReachedLimit) {
        console.log("Projektlimit erreicht! Anfrage wird mit 403 abgelehnt.");
        return res.status(403).json({
          message: "Projektlimit erreicht",
          details: "Das Projektlimit f\xFCr Ihr Abonnement wurde erreicht. Bitte upgraden Sie Ihr Abonnement, um weitere Projekte zu erstellen."
        });
      } else {
        console.log("Projektlimit nicht erreicht, Erstellung wird fortgesetzt");
      }
      const project = await storage.createProject(userId, result.data);
      await storage.createActivityLog({
        action: "create",
        details: "Neues Projekt erstellt",
        userId,
        // Use consistent userId field
        projectId: project.id
      });
      res.json(project);
    } catch (error) {
      console.error("Failed to create project:", error);
      res.status(500).json({ message: "Failed to create project" });
    }
  });
  app2.patch("/api/projects/:id", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Invalid project ID" });
    }
    const result = updateProjectSchema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({ message: result.error.message });
    }
    try {
      const userId = req.userId;
      const project = await storage.updateProject(userId, id, result.data);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      await storage.createActivityLog({
        action: "update",
        details: "Projekt aktualisiert",
        userId,
        projectId: id
      });
      res.json(project);
    } catch (error) {
      console.error("Failed to update project:", error);
      res.status(500).json({ message: "Failed to update project" });
    }
  });
  app2.patch("/api/projects/:id/members", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Ung\xFCltige Projekt-ID" });
    }
    const { memberIds } = req.body;
    if (!Array.isArray(memberIds)) {
      return res.status(400).json({ message: "memberIds muss ein Array sein" });
    }
    try {
      const userId = req.userId;
      const updatedProject = await storage.updateProject(userId, id, {
        memberIds
      });
      await storage.createActivityLog({
        action: "update",
        details: "Projektmitglieder aktualisiert",
        userId,
        projectId: id,
        requiresNotification: true,
        notificationType: "project"
      });
      res.json(updatedProject);
    } catch (error) {
      console.error("Fehler beim Aktualisieren der Projektmitglieder:", error);
      res.status(500).json({
        message: "Fehler beim Aktualisieren der Projektmitglieder",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });
  app2.delete("/api/projects/:id", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Invalid project ID" });
    }
    try {
      const userId = req.userId;
      await storage.createActivityLog({
        action: "delete",
        details: "Projekt gel\xF6scht",
        user_id: userId,
        project_id: id
      });
      await storage.deleteProject(userId, id);
      res.status(204).send();
    } catch (error) {
      console.error("Failed to delete project:", error);
      res.status(500).json({ message: "Failed to delete project" });
    }
  });
  app2.patch("/api/projects/:id/archive", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Ung\xFCltige Projekt-ID" });
    }
    try {
      const userId = req.userId;
      const project = await storage.archiveProject(userId, id);
      res.json(project);
    } catch (error) {
      console.error("Failed to archive project:", error);
      res.status(500).json({ message: "Fehler beim Archivieren des Projekts" });
    }
  });
  app2.patch("/api/projects/:id/unarchive", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Ung\xFCltige Projekt-ID" });
    }
    try {
      const userId = req.userId;
      const project = await storage.unarchiveProject(userId, id);
      res.json(project);
    } catch (error) {
      console.error("Failed to unarchive project:", error);
      res.status(500).json({ message: "Fehler beim Wiederherstellen des Projekts" });
    }
  });
  app2.get("/api/projects/:projectId/boards", requireAuth, async (req, res) => {
    const projectId = parseInt(req.params.projectId);
    if (isNaN(projectId)) {
      return res.status(400).json({ message: "Invalid project ID" });
    }
    try {
      const userId = req.userId;
      const boards4 = await storage.getBoardsByProject(userId, projectId);
      res.json(boards4);
    } catch (error) {
      console.error("Failed to fetch boards:", error);
      res.status(500).json({ message: "Failed to fetch boards" });
    }
  });
  app2.post("/api/boards", requireAuth, async (req, res) => {
    try {
      console.log("Received board creation request:", req.body);
      const result = insertBoardSchema.safeParse(req.body);
      if (!result.success) {
        console.error("Board validation failed:", result.error.errors);
        return res.status(400).json({
          message: "Invalid board data",
          errors: result.error.errors
        });
      }
      const userId = req.userId;
      const user = await storage.getUser(userId, userId);
      console.log("Board-Erstellung: Benutzer gefunden:", {
        userId,
        username: user.username,
        companyId: user.companyId,
        subscriptionTier: user.subscriptionTier || "free"
      });
      let hasReachedLimit = false;
      if (user.companyId) {
        hasReachedLimit = await subscriptionService.hasReachedBoardLimit(user.companyId);
        console.log("Boardlimit-Pr\xFCfung (Firma):", {
          companyId: user.companyId,
          hasReachedLimit,
          subscriptionTier: user.subscriptionTier || "free"
        });
        if (hasReachedLimit) {
          console.log("Boardlimit erreicht! Anfrage wird mit 403 abgelehnt.");
          return res.status(403).json({
            message: "Board-Limit erreicht",
            details: "Das Board-Limit f\xFCr Ihr Abonnement wurde erreicht. Bitte upgraden Sie Ihr Abonnement, um weitere Boards zu erstellen."
          });
        }
      } else {
        const boardCountResult = await pool.query(
          "SELECT COUNT(*) as count FROM boards WHERE creator_id = $1 AND archived = false",
          [userId]
        );
        const boardCount = parseInt(String(boardCountResult.rows?.[0]?.count) || "0");
        console.log(`DIREKTE Z\xC4HLUNG: Benutzer ${userId} hat ${boardCount} pers\xF6nliche Boards`);
        const subscriptionTier = user.subscriptionTier || "free";
        const maxBoards = subscriptionTier === "free" ? 1 : subscriptionTier === "freelancer" ? 5 : 20;
        hasReachedLimit = boardCount >= maxBoards;
        console.log("Boardlimit-Pr\xFCfung (Einzelbenutzer):", {
          userId,
          boardCount,
          maxBoards,
          subscriptionTier,
          hasReachedLimit
        });
        if (hasReachedLimit) {
          console.log("Boardlimit erreicht! Anfrage wird mit 403 abgelehnt.");
          return res.status(403).json({
            message: "Board-Limit erreicht",
            details: "Das Board-Limit f\xFCr Ihr Abonnement wurde erreicht. Bitte upgraden Sie Ihr Abonnement, um weitere Boards zu erstellen."
          });
        }
      }
      if ((user.subscriptionTier === "free" || user.subscriptionTier === "freelancer") && (result.data.team_ids?.length > 0 || result.data.assigned_user_ids?.length > 0)) {
        return res.status(403).json({
          message: "Funktion nicht verf\xFCgbar",
          details: "In Ihrem Abonnement (Free/Freelancer) k\xF6nnen keine Teams oder zus\xE4tzliche Benutzer hinzugef\xFCgt werden. Bitte upgraden Sie Ihr Abonnement f\xFCr diese Funktion."
        });
      }
      const boardData = {
        ...result.data,
        team_ids: Array.isArray(result.data.team_ids) ? result.data.team_ids : [],
        assigned_user_ids: Array.isArray(result.data.assigned_user_ids) ? result.data.assigned_user_ids : [],
        is_favorite: result.data.is_favorite || false,
        archived: false
        // Explizit auf false setzen, damit die Limit-Checks funktionieren
      };
      console.log("Creating board with data:", boardData);
      const board = await storage.createBoard(req.userId, boardData);
      console.log("Board created:", board);
      await storage.createActivityLog({
        action: "create",
        details: "Neues Board erstellt",
        userId: req.userId,
        boardId: board.id
      });
      res.status(201).json(board);
    } catch (error) {
      console.error("Failed to create board:", error);
      res.status(500).json({
        message: error instanceof Error ? error.message : "Failed to create board",
        error
      });
    }
  });
  app2.get("/api/boards", requireAuth, async (req, res) => {
    try {
      console.log("Starting boards fetch...");
      const userId = req.userId;
      const boards4 = await storage.getBoards(userId);
      console.log(`Successfully retrieved ${boards4.length} boards:`, boards4);
      res.json(boards4);
    } catch (error) {
      console.error("Failed to fetch boards:", error);
      res.status(500).json({
        message: "Failed to fetch boards",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });
  app2.get("/api/boards/:id", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      console.error("Invalid board ID received:", req.params.id);
      return res.status(400).json({ message: "Invalid board ID" });
    }
    try {
      const userId = req.userId;
      console.log(`[GET /api/boards/${id}] Fetching board for user ${userId}...`);
      const board = await storage.getBoard(userId, id);
      if (!board) {
        console.log(`[GET /api/boards/${id}] Board not found or user doesn't have access`);
        return res.status(404).json({ message: "Board not found or you don't have access" });
      }
      console.log(`[GET /api/boards/${id}] Successfully fetched board:`, board);
      const columns2 = await storage.getColumns(userId, id);
      const tasks2 = await storage.getTasks(userId, id);
      console.log(`[GET /api/boards/${id}] Found ${columns2.length} columns and ${tasks2.length} tasks`);
      res.json({
        ...board,
        columns: columns2,
        tasks: tasks2
      });
    } catch (error) {
      console.error(`[GET /api/boards/${id}] Error fetching board:`, error);
      res.status(500).json({
        message: "Failed to fetch board",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });
  app2.patch("/api/boards/:id", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Invalid board ID" });
    }
    const result = updateBoardSchema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({
        message: "Invalid board data",
        errors: result.error.errors
      });
    }
    try {
      const userId = req.userId;
      const updatedBoard = await storage.updateBoard(userId, id, result.data);
      await storage.createActivityLog({
        action: "update",
        details: "Board aktualisiert",
        user_id: userId,
        board_id: id
      });
      res.json(updatedBoard);
    } catch (error) {
      console.error("Failed to update board:", error);
      res.status(500).json({
        message: error instanceof Error ? error.message : "Failed to update board"
      });
    }
  });
  app2.delete("/api/boards/:id", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Invalid board ID" });
    }
    try {
      const userId = req.userId;
      await storage.createActivityLog({
        action: "delete",
        details: "Board gel\xF6scht",
        user_id: userId,
        board_id: id
      });
      await storage.deleteBoard(userId, id);
      res.status(204).send();
    } catch (error) {
      res.status(404).json({ message: error.message });
    }
  });
  app2.patch("/api/boards/:id/archive", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Ung\xFCltige Board-ID" });
    }
    try {
      const userId = req.userId;
      const board = await storage.archiveBoard(userId, id);
      res.json(board);
    } catch (error) {
      console.error("Failed to archive board:", error);
      res.status(500).json({ message: "Fehler beim Archivieren des Boards" });
    }
  });
  app2.patch("/api/boards/:id/unarchive", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Ung\xFCltige Board-ID" });
    }
    try {
      const userId = req.userId;
      const board = await storage.unarchiveBoard(userId, id);
      res.json(board);
    } catch (error) {
      console.error("Failed to unarchive board:", error);
      res.status(500).json({ message: "Fehler beim Wiederherstellen des Boards" });
    }
  });
  app2.get("/api/boards/:boardId/tasks", requireAuth, async (req, res) => {
    const boardId = parseInt(req.params.boardId);
    if (isNaN(boardId)) {
      return res.status(400).json({ message: "Invalid board ID" });
    }
    try {
      const userId = req.userId;
      console.log(`Fetching tasks for board ${boardId} for user ${userId}`);
      const tasks2 = await storage.getTasks(userId, boardId);
      console.log(`Found ${tasks2.length} tasks:`, tasks2);
      res.json(tasks2);
    } catch (error) {
      console.error(`Failed to fetch tasks for board ${boardId}:`, error);
      res.status(500).json({ message: "Failed to fetch tasks" });
    }
  });
  app2.get("/api/all-tasks", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      const boards4 = await storage.getBoards(userId);
      const allTasks = {};
      for (const board of boards4) {
        try {
          const tasks2 = await storage.getTasks(userId, board.id);
          allTasks[board.id] = tasks2;
        } catch (error) {
          console.error(`Failed to fetch tasks for board ${board.id}:`, error);
          allTasks[board.id] = [];
        }
      }
      res.json(allTasks);
    } catch (error) {
      console.error("Failed to fetch all tasks:", error);
      res.status(500).json({ message: "Failed to fetch all tasks" });
    }
  });
  app2.get("/api/user/tasks/assigned", requireAuth, async (req, res) => {
    try {
      console.log("Fetching assigned tasks for user", req.userId);
      const userId = req.userId;
      const tasks2 = await storage.getUserAssignedTasks(userId);
      console.log(`Found ${tasks2.length} tasks assigned to user ${userId}`);
      res.json(tasks2);
    } catch (error) {
      console.error("Error fetching assigned tasks:", error);
      res.status(500).json({ message: error.message });
    }
  });
  app2.get("/api/user-tasks", requireAuth, async (req, res) => {
    try {
      console.log("Fetching dashboard tasks for user", req.userId);
      const userId = req.userId;
      const tasks2 = await storage.getUserAssignedTasks(userId);
      console.log(`Found ${tasks2.length} tasks for dashboard for user ${userId}`);
      res.json(tasks2);
    } catch (error) {
      console.error("Error fetching dashboard tasks:", error);
      res.status(500).json({ message: error.message });
    }
  });
  app2.patch("/api/user/tasks/:id", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Ung\xFCltige Aufgaben-ID" });
    }
    const result = updateTaskSchema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({
        message: result.error.message,
        details: result.error.errors
      });
    }
    try {
      const userId = req.userId;
      console.log(`Aktualisiere pers\xF6nliche Aufgabe ${id} f\xFCr Benutzer ${userId}`, result.data);
      const updateData = {
        ...result.data,
        boardId: null,
        columnId: null
      };
      const task = await storage.updateTask(userId, id, updateData);
      if (result.data.status === "done") {
        await storage.updateOrCreateDailyProductivityMetrics(userId, {
          tasksCompleted: 1
        });
      }
      const activityLog = await storage.createActivityLog({
        action: "update",
        details: "Pers\xF6nliche Aufgabe aktualisiert",
        userId,
        taskId: id,
        requiresNotification: true,
        notificationType: "task"
      });
      await notificationService.processActivityLog(activityLog.id);
      res.json(task);
    } catch (error) {
      console.error("Fehler beim Aktualisieren der pers\xF6nlichen Aufgabe:", error);
      res.status(500).json({
        message: "Fehler beim Aktualisieren der pers\xF6nlichen Aufgabe",
        details: error instanceof Error ? error.message : String(error)
      });
    }
  });
  app2.post("/api/user/tasks", requireAuth, checkTaskLimit, async (req, res) => {
    try {
      const userId = req.userId;
      const user = await storage.getUser(userId, userId);
      const canAssignOthers = await subscriptionService.canAssignTeams(userId);
      const assignedUserIdsFromRequest = req.body.assignedUserIds || [];
      const hasOtherAssignees = assignedUserIdsFromRequest.some((id) => id !== userId);
      if (!canAssignOthers && (req.body.assignedTeamId || hasOtherAssignees)) {
        return res.status(403).json({
          message: "Funktion nicht verf\xFCgbar",
          details: "In Ihrem Abonnement (Free/Freelancer) k\xF6nnen keine Teams oder zus\xE4tzliche Benutzer hinzugef\xFCgt werden. Bitte upgraden Sie Ihr Abonnement f\xFCr diese Funktion."
        });
      }
      const assignedUserIds = [userId];
      const taskData = {
        ...req.body,
        assignedUserIds,
        creatorId: userId,
        // Standardwerte für persönliche Tasks
        status: req.body.status || "todo",
        order: req.body.order || 0,
        // Für persönliche Tasks explizit null setzen
        boardId: null,
        columnId: null
      };
      console.log("Creating personal task with data:", taskData);
      const result = insertTaskSchema.safeParse(taskData);
      if (!result.success) {
        console.error("Task validation failed:", result.error.errors);
        return res.status(400).json({
          message: "Ung\xFCltige Task-Daten",
          errors: result.error.errors
        });
      }
      console.log("Creating personal task:", result.data);
      const task = await storage.createTask(userId, result.data);
      await storage.updateOrCreateDailyProductivityMetrics(userId, {
        tasksCreated: 1
      });
      const activityLog = await storage.createActivityLog({
        action: "create",
        details: "Pers\xF6nliche Aufgabe erstellt",
        userId,
        taskId: task.id,
        requiresNotification: true,
        notificationType: "task"
      });
      await notificationService.processActivityLog(activityLog.id);
      res.status(201).json(task);
    } catch (error) {
      console.error("Fehler beim Erstellen der pers\xF6nlichen Aufgabe:", error);
      res.status(500).json({ message: "Fehler beim Erstellen der pers\xF6nlichen Aufgabe" });
    }
  });
  app2.post("/api/boards/:boardId/tasks", requireAuth, checkTaskLimit, async (req, res) => {
    const boardId = parseInt(req.params.boardId);
    if (isNaN(boardId)) {
      return res.status(400).json({ message: "Invalid board ID" });
    }
    const userId = req.userId;
    const user = await storage.getUser(userId, userId);
    if (user.companyId) {
      const hasReachedLimit = await subscriptionService.hasReachedTaskLimit(user.companyId);
      if (hasReachedLimit) {
        return res.status(403).json({
          message: "Aufgaben-Limit erreicht",
          details: "Das Aufgaben-Limit f\xFCr Ihr Abonnement wurde erreicht. Bitte upgraden Sie Ihr Abonnement, um weitere Aufgaben zu erstellen."
        });
      }
    }
    const canAssignOthers = await subscriptionService.canAssignTeams(userId);
    const assignedUserIdsFromRequest = req.body.assignedUserIds || [];
    const hasOtherAssignees = assignedUserIdsFromRequest.some((id) => id !== userId);
    if (!canAssignOthers && (req.body.assignedTeamId || hasOtherAssignees)) {
      return res.status(403).json({
        message: "Funktion nicht verf\xFCgbar",
        details: "In Ihrem Abonnement (Free/Freelancer) k\xF6nnen keine Teams oder zus\xE4tzliche Benutzer hinzugef\xFCgt werden. Bitte upgraden Sie Ihr Abonnement f\xFCr diese Funktion."
      });
    }
    const assignedUserIds = [userId];
    const result = insertTaskSchema.safeParse({
      ...req.body,
      boardId,
      creatorId: userId,
      assignedUserIds
    });
    if (!result.success) {
      return res.status(400).json({
        message: "Invalid task data",
        errors: result.error.errors
      });
    }
    try {
      const task = await storage.createTask(userId, {
        ...result.data
      });
      res.status(201).json(task);
      try {
        await storage.updateOrCreateDailyProductivityMetrics(userId, {
          tasksCreated: 1
        });
      } catch (metricError) {
        console.error("Failed to update metrics, but task was created:", metricError);
      }
      try {
        await storage.createActivityLog({
          action: "create",
          details: "Neue Aufgabe erstellt",
          userId,
          boardId,
          taskId: task.id,
          requiresNotification: false,
          // Keine Benachrichtigung für den Ersteller selbst
          notificationType: "task"
        });
      } catch (logError) {
        console.error("Failed to create activity log, but task was created:", logError);
      }
    } catch (error) {
      console.error("Failed to create task:", error);
      res.status(500).json({ message: error.message });
    }
  });
  app2.patch("/api/tasks/:id", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Invalid task ID" });
    }
    const result = updateTaskSchema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({
        message: result.error.message,
        details: result.error.errors
      });
    }
    try {
      const userId = req.userId;
      const user = await storage.getUser(userId, userId);
      const canAssignOthers = await subscriptionService.canAssignTeams(userId);
      const assignedUserIdsFromRequest = result.data.assignedUserIds || [];
      const hasOtherAssignees = assignedUserIdsFromRequest.some((id2) => id2 !== userId);
      if (!canAssignOthers && (result.data.assignedTeamId || hasOtherAssignees)) {
        return res.status(403).json({
          message: "Funktion nicht verf\xFCgbar",
          details: "In Ihrem Abonnement (Free/Freelancer) k\xF6nnen keine Teams oder zus\xE4tzliche Benutzer hinzugef\xFCgt werden. Bitte upgraden Sie Ihr Abonnement f\xFCr diese Funktion."
        });
      }
      const task = await storage.updateTask(userId, id, result.data);
      if (result.data.status === "done") {
        await storage.updateOrCreateDailyProductivityMetrics(userId, {
          tasksCompleted: 1
        });
      }
      const activityLogData = {
        action: "update",
        details: "Aufgabe aktualisiert",
        userId,
        taskId: id,
        requiresNotification: true,
        // Benachrichtigung für Zuweisungen und Updates
        notificationType: "task"
      };
      if (task.boardId) {
        activityLogData.boardId = task.boardId;
      }
      const activityLog = await storage.createActivityLog(activityLogData);
      await notificationService.processActivityLog(activityLog.id);
      res.json(task);
    } catch (error) {
      console.error("Failed to update task:", error);
      res.status(404).json({ message: error.message });
    }
  });
  app2.get("/api/tasks/:taskId/comments", requireAuth, async (req, res) => {
    const taskId = parseInt(req.params.taskId);
    if (isNaN(taskId)) {
      return res.status(400).json({ message: "Invalid task ID" });
    }
    try {
      const userId = req.userId;
      const comments2 = await storage.getComments(userId, taskId);
      res.json(comments2);
    } catch (error) {
      res.status(500).json({ message: error.message });
    }
  });
  app2.post("/api/tasks/:taskId/comments", requireAuth, async (req, res) => {
    const taskId = parseInt(req.params.taskId);
    if (isNaN(taskId)) {
      return res.status(400).json({ message: "Invalid task ID" });
    }
    console.log("Received comment creation request:", {
      body: req.body,
      taskId
    });
    const result = insertCommentSchema.safeParse({ ...req.body, taskId });
    if (!result.success) {
      console.error("Comment validation failed:", result.error);
      return res.status(400).json({
        message: "Invalid comment data",
        errors: result.error.errors
      });
    }
    try {
      console.log("Validated comment data:", result.data);
      const userId = req.userId;
      const comment = await storage.createComment(userId, result.data);
      const activityLog = await storage.createActivityLog({
        action: "comment",
        details: "Neuer Kommentar hinzugef\xFCgt",
        userId,
        taskId: result.data.taskId,
        requiresNotification: true,
        notificationType: "comment"
      });
      await notificationService.processActivityLog(activityLog.id);
      console.log("Created comment:", comment);
      res.status(201).json(comment);
    } catch (error) {
      console.error("Failed to create comment:", error);
      res.status(500).json({ message: error.message });
    }
  });
  app2.delete("/api/comments/:id", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Invalid comment ID" });
    }
    try {
      const userId = req.userId;
      const comment = await pool.query(
        "SELECT * FROM comments WHERE id = $1",
        [id]
      );
      if (comment.rows.length === 0) {
        return res.status(404).json({ message: "Kommentar nicht gefunden" });
      }
      if (comment.rows[0].author_id !== userId) {
        return res.status(403).json({ message: "Keine Berechtigung zum L\xF6schen des Kommentars" });
      }
      await pool.query("DELETE FROM comments WHERE id = $1", [id]);
      res.status(204).send();
    } catch (error) {
      console.error("Failed to delete comment:", error);
      res.status(500).json({ message: "Fehler beim L\xF6schen des Kommentars" });
    }
  });
  app2.get("/api/tasks/:taskId/checklist", requireAuth, async (req, res) => {
    const taskId = parseInt(req.params.taskId);
    if (isNaN(taskId)) {
      return res.status(400).json({ message: "Invalid task ID" });
    }
    try {
      const userId = req.userId;
      const items = await storage.getChecklistItems(userId, taskId);
      res.json(items);
    } catch (error) {
      res.status(500).json({ message: error.message });
    }
  });
  app2.post("/api/tasks/:taskId/checklist", requireAuth, async (req, res) => {
    const taskId = parseInt(req.params.taskId);
    if (isNaN(taskId)) {
      return res.status(400).json({ message: "Invalid task ID" });
    }
    console.log("Received checklist item creation request:", {
      body: req.body,
      taskId
    });
    const result = insertChecklistItemSchema.safeParse({ ...req.body, taskId });
    if (!result.success) {
      console.error("Checklist item validation failed:", result.error);
      return res.status(400).json({
        message: "Invalid checklist item data",
        errors: result.error.errors
      });
    }
    try {
      console.log("Validated checklist item data:", result.data);
      const userId = req.userId;
      const item = await storage.createChecklistItem(userId, result.data);
      console.log("Created checklist item:", item);
      res.status(201).json(item);
    } catch (error) {
      console.error("Failed to create checklist item:", error);
      res.status(500).json({ message: error.message });
    }
  });
  app2.patch("/api/checklist/:id", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Invalid checklist item ID" });
    }
    try {
      const userId = req.userId;
      const item = await storage.updateChecklistItem(userId, id, req.body);
      res.json(item);
    } catch (error) {
      res.status(404).json({ message: error.message });
    }
  });
  app2.delete("/api/checklist/:id", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Invalid checklist item ID" });
    }
    try {
      const userId = req.userId;
      await storage.deleteChecklistItem(userId, id);
      res.status(204).send();
    } catch (error) {
      res.status(404).json({ message: error.message });
    }
  });
  app2.get("/api/dashboard/activity", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      console.log(`[DASHBOARD_ACTIVITY] Fetching activity logs for dashboard, user ID: ${userId}`);
      const limit = req.query.limit ? parseInt(req.query.limit) : 30;
      const result = await pool.query(`
        WITH user_boards AS (
          SELECT DISTINCT b.id 
          FROM boards b
          LEFT JOIN board_members bm ON b.id = bm.board_id
          WHERE b.creator_id = $1 OR bm.user_id = $1
        ),
        user_projects AS (
          SELECT DISTINCT p.id
          FROM projects p
          WHERE p.creator_id = $1
        ),
        user_teams AS (
          SELECT DISTINCT t.id
          FROM teams t
          LEFT JOIN team_members tm ON t.id = tm.team_id
          WHERE tm.user_id = $1
        ),
        user_tasks AS (
          SELECT DISTINCT t.id
          FROM tasks t
          WHERE t.assigned_user_ids && ARRAY[$1]
        )
        SELECT a.*, 
               u.username, 
               u.avatar_url,
               b.title as board_title,
               p.title as project_title,
               o.title as objective_title,
               t.title as task_title,
               tm.name as team_title
        FROM activity_logs a
        JOIN users u ON a.user_id = u.id
        LEFT JOIN boards b ON a.board_id = b.id
        LEFT JOIN projects p ON a.project_id = p.id
        LEFT JOIN objectives o ON a.objective_id = o.id
        LEFT JOIN tasks t ON a.task_id = t.id
        LEFT JOIN teams tm ON a.team_id = tm.id
        WHERE a.user_id = $1
           OR (a.board_id IN (SELECT id FROM user_boards))
           OR (a.project_id IN (SELECT id FROM user_projects))
           OR (a.team_id IN (SELECT id FROM user_teams))
           OR (a.task_id IN (SELECT id FROM user_tasks))
        ORDER BY a.created_at DESC
        LIMIT $2
      `, [userId, limit]);
      console.log(`[DASHBOARD_ACTIVITY] Found ${result.rows.length} activities for dashboard`);
      return res.json(result.rows);
    } catch (error) {
      console.error("[DASHBOARD_ACTIVITY] Error:", error);
      return res.status(500).json({
        message: "Failed to fetch dashboard activities",
        details: error instanceof Error ? error.message : String(error)
      });
    }
  });
  app2.get("/api/activity", requireAuth, async (req, res) => {
    try {
      console.log(`[ACTIVITY_DEBUG] Fetching activity logs with filters:`, req.query);
      const userId = req.userId;
      console.log(`[ACTIVITY_DEBUG] Requesting user ID: ${userId}`);
      const teamId = req.query.teamId ? parseInt(req.query.teamId) : void 0;
      const projectId = req.query.projectId ? parseInt(req.query.projectId) : void 0;
      const objectiveId = req.query.objectiveId ? parseInt(req.query.objectiveId) : void 0;
      const limit = req.query.limit ? parseInt(req.query.limit) : 50;
      console.log(`[ACTIVITY_DEBUG] Extracted params: teamId=${teamId}, projectId=${projectId}, objectiveId=${objectiveId}, limit=${limit}`);
      const isHyperAdmin = await permissionService.isHyperAdmin(userId);
      console.log(`[ACTIVITY_DEBUG] User ${userId} is Hyper-Admin: ${isHyperAdmin}`);
      if (isHyperAdmin) {
        console.log("User is a Hyper-Admin and can see all activity logs");
        let whereConditions = [];
        let params = [];
        let paramIndex = 1;
        if (objectiveId) {
          whereConditions.push(`a.objective_id = $${paramIndex}`);
          params.push(objectiveId);
          paramIndex++;
        }
        if (teamId) {
          whereConditions.push(`a.team_id = $${paramIndex}`);
          params.push(teamId);
          paramIndex++;
        }
        if (projectId) {
          whereConditions.push(`a.project_id = $${paramIndex}`);
          params.push(projectId);
          paramIndex++;
        }
        const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(" AND ")}` : "";
        const result = await pool.query(`
          SELECT a.*, 
                 b.title as board_title, 
                 p.title as project_title,
                 o.title as objective_title,
                 t.title as task_title,
                 tm.name as team_title,
                 u.username, 
                 u.avatar_url,
                 tu.username as target_username
          FROM activity_logs a
          LEFT JOIN boards b ON a.board_id = b.id
          LEFT JOIN projects p ON a.project_id = p.id
          LEFT JOIN objectives o ON a.objective_id = o.id
          LEFT JOIN tasks t ON a.task_id = t.id
          LEFT JOIN teams tm ON a.team_id = tm.id
          LEFT JOIN users u ON a.user_id = u.id
          LEFT JOIN users tu ON a.target_user_id = tu.id
          ${whereClause}
          ORDER BY a.created_at DESC
          LIMIT $${paramIndex}
        `, [...params, limit]);
        console.log(`Admin query found ${result.rows.length} activity logs`);
        return res.json(result.rows);
      }
      if (objectiveId) {
        console.log(`Using direct query for objectiveId: ${objectiveId}`);
        const hasAccess = await permissionService.canAccessObjective(userId, objectiveId);
        if (!hasAccess) {
          console.log(`User ${userId} has no access to objective ${objectiveId}`);
          return res.json([]);
        }
        const result = await pool.query(`
          SELECT a.*, 
                 u.username, 
                 u.avatar_url,
                 o.title as objective_title
          FROM activity_logs a
          LEFT JOIN users u ON a.user_id = u.id
          LEFT JOIN objectives o ON a.objective_id = o.id
          WHERE a.objective_id = $1
          ORDER BY a.created_at DESC
          LIMIT $2
        `, [objectiveId, limit]);
        console.log(`Found ${result.rows.length} activity logs for objective ${objectiveId}`);
        return res.json(result.rows);
      }
      const enhancedTaskBoardQuery = await pool.query(`
        WITH accessible_boards AS (
          SELECT DISTINCT b.id 
          FROM boards b
          LEFT JOIN board_members bm ON b.id = bm.board_id
          LEFT JOIN teams t ON (b.team_ids IS NOT NULL AND b.team_ids && ARRAY[t.id])
          LEFT JOIN team_members tm ON t.id = tm.team_id
          WHERE 
            b.creator_id = $1 OR 
            bm.user_id = $1 OR 
            tm.user_id = $1 OR
            (b.assigned_user_ids IS NOT NULL AND $1 = ANY(b.assigned_user_ids))
        )
        SELECT DISTINCT a.*, 
               b.title as board_title, 
               t.title as task_title,
               u.username, 
               u.avatar_url
        FROM activity_logs a
        JOIN tasks t ON a.task_id = t.id
        JOIN boards b ON t.board_id = b.id
        JOIN accessible_boards ab ON b.id = ab.id
        JOIN users u ON a.user_id = u.id
        WHERE 
          a.action = 'create' OR a.action = 'update' OR a.action = 'comment'
        ORDER BY a.created_at DESC
        LIMIT $2
      `, [userId, limit]);
      console.log(`[ACTIVITY_DEBUG] Enhanced task-board query found ${enhancedTaskBoardQuery.rows.length} activity logs`);
      console.log(`[ACTIVITY_DEBUG] Task-board sample:`, enhancedTaskBoardQuery.rows.length > 0 ? JSON.stringify(enhancedTaskBoardQuery.rows[0]) : "No results");
      let logs = await permissionService.getVisibleActivityLogs(userId);
      console.log(`[ACTIVITY_DEBUG] getVisibleActivityLogs returned ${logs.length} logs`);
      logs = [...logs, ...enhancedTaskBoardQuery.rows];
      logs = logs.filter(
        (log2, index, self) => index === self.findIndex((l) => l.id === log2.id)
      );
      if (teamId) {
        console.log(`Filtering logs by teamId: ${teamId}`);
        logs = logs.filter((log2) => log2.teamId === teamId || log2.team_id === teamId);
      }
      if (projectId) {
        console.log(`Filtering logs by projectId: ${projectId}`);
        logs = logs.filter((log2) => log2.projectId === projectId || log2.project_id === projectId);
      }
      logs = logs.sort((a, b) => {
        const dateA = new Date(a.created_at || a.createdAt);
        const dateB = new Date(b.created_at || b.createdAt);
        return dateB.getTime() - dateA.getTime();
      }).slice(0, limit);
      console.log(`[ACTIVITY_DEBUG] Activity logs final result: ${logs.length} items after filtering and sorting`);
      if (logs.length > 0) {
        console.log(`[ACTIVITY_DEBUG] Sample activity log:`, JSON.stringify(logs[0]));
      } else {
        console.log(`[ACTIVITY_DEBUG] NO ACTIVITY LOGS FOUND for user ${userId}`);
      }
      res.json(logs);
    } catch (error) {
      console.error("Failed to fetch activity logs:", error);
      res.status(500).json({
        message: "Failed to fetch activity logs",
        details: error instanceof Error ? error.message : String(error)
      });
    }
  });
  app2.get("/api/dashboard/activity", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      const limit = Number(req.query.limit) || 30;
      const query = `
        SELECT 
          a.id, 
          a.action, 
          a.details, 
          a.user_id AS "userId",
          a.board_id AS "boardId", 
          a.project_id AS "projectId", 
          a.objective_id AS "objectiveId",
          a.task_id AS "taskId",
          a.team_id AS "teamId",
          a.notification_type AS "notificationType",
          a.created_at,
          u.username,
          u.avatar_url,
          b.title AS board_title,
          p.title AS project_title,
          o.title AS objective_title,
          t.name AS team_title
        FROM 
          activity_logs a
        LEFT JOIN 
          users u ON a.user_id = u.id
        LEFT JOIN 
          boards b ON a.board_id = b.id
        LEFT JOIN 
          projects p ON a.project_id = p.id
        LEFT JOIN 
          objectives o ON a.objective_id = o.id
        LEFT JOIN 
          teams t ON a.team_id = t.id
        WHERE 
          a.user_id = $1
          OR (a.requires_notification = true AND a.target_user_id = $1)
          OR EXISTS (
            -- Board Mitgliedschaft
            SELECT 1 FROM board_members bm
            WHERE bm.board_id = a.board_id AND bm.user_id = $1 AND a.board_id IS NOT NULL
          )
          OR EXISTS (
            -- Team Mitgliedschaft 
            SELECT 1 FROM team_members tm
            WHERE tm.team_id = a.team_id AND tm.user_id = $1 AND a.team_id IS NOT NULL
          )
          OR EXISTS (
            -- Tasks direkt dem Benutzer zugewiesen (ohne fehlerhafte task_team_assignments Tabelle)
            SELECT 1 FROM tasks task
            WHERE task.id = a.task_id AND task.assigned_user_ids && ARRAY[$1] AND a.task_id IS NOT NULL
          )
        ORDER BY 
          a.created_at DESC
        LIMIT $2
      `;
      console.log(`[DASHBOARD_ACTIVITY] Querying dashboard activities for user ${userId}`);
      console.log(`[DASHBOARD_ACTIVITY] SQL Query: ${query}`);
      console.log(`[DASHBOARD_ACTIVITY] Params: userId=${userId}, limit=${limit}`);
      const result = await pool.query(query, [userId, limit]);
      console.log(`[DASHBOARD_ACTIVITY] Found ${result.rows.length} activities`);
      const countResult = await pool.query("SELECT COUNT(*) FROM activity_logs");
      console.log(`[DASHBOARD_ACTIVITY] Total activity logs in database: ${countResult.rows[0].count}`);
      res.json(result.rows);
    } catch (error) {
      console.error("Failed to fetch dashboard activity logs:", error);
      res.status(500).json({
        message: "Failed to fetch dashboard activity logs",
        details: error instanceof Error ? error.message : String(error)
      });
    }
  });
  app2.get("/api/notifications", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      const result = await pool.query(`
        SELECT 
          id, 
          user_id AS "userId", 
          title, 
          message, 
          type, 
          link, 
          read, 
          created_at AS "createdAt"
        FROM notifications
        WHERE user_id = $1
        ORDER BY created_at DESC
        LIMIT 30
      `, [userId]);
      res.json(result.rows);
    } catch (error) {
      console.error("Failed to fetch notifications:", error);
      res.status(500).json({
        message: "Benachrichtigungen konnten nicht abgerufen werden",
        details: error instanceof Error ? error.message : String(error)
      });
    }
  });
  app2.patch("/api/notifications/:id/read", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      const notificationId = parseInt(req.params.id);
      const checkResult = await pool.query(
        "SELECT id FROM notifications WHERE id = $1 AND user_id = $2",
        [notificationId, userId]
      );
      if (checkResult.rows.length === 0) {
        return res.status(404).json({ message: "Benachrichtigung nicht gefunden" });
      }
      await pool.query(
        "UPDATE notifications SET read = true WHERE id = $1",
        [notificationId]
      );
      res.json({ message: "Benachrichtigung als gelesen markiert" });
    } catch (error) {
      console.error("Failed to mark notification as read:", error);
      res.status(500).json({
        message: "Benachrichtigung konnte nicht als gelesen markiert werden",
        details: error instanceof Error ? error.message : String(error)
      });
    }
  });
  app2.patch("/api/notifications/read-all", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      await pool.query(
        "UPDATE notifications SET read = true WHERE user_id = $1 AND read = false",
        [userId]
      );
      res.json({ message: "Alle Benachrichtigungen als gelesen markiert" });
    } catch (error) {
      console.error("Failed to mark all notifications as read:", error);
      res.status(500).json({
        message: "Benachrichtigungen konnten nicht als gelesen markiert werden",
        details: error instanceof Error ? error.message : String(error)
      });
    }
  });
  app2.get("/api/notification-settings", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      const result = await pool.query(`
        SELECT 
          id,
          user_id AS "userId",

          -- Aufgaben
          task_assigned AS "taskAssigned",
          task_due AS "taskDue",
          task_updates AS "taskUpdates",
          task_comments AS "taskComments",

          -- Boards
          board_invite AS "boardInvite",
          board_updates AS "boardUpdates",

          -- Teams
          team_invite AS "teamInvite",
          team_updates AS "teamUpdates",

          -- Projekte
          project_update AS "projectUpdate",

          -- OKRs
          okr_progress AS "okrProgress",
          okr_comments AS "okrComments",

          -- Allgemein
          mentions
        FROM notification_settings
        WHERE user_id = $1
        LIMIT 1
      `, [userId]);
      if (result.rows.length === 0) {
        const defaultSettings = {
          userId,
          taskAssigned: true,
          taskDue: true,
          taskUpdates: true,
          taskComments: true,
          boardInvite: true,
          boardUpdates: true,
          teamInvite: true,
          teamUpdates: true,
          projectUpdate: true,
          okrProgress: true,
          okrComments: true,
          mentions: true
        };
        const insertResult = await pool.query(`
          INSERT INTO notification_settings (
            user_id, 
            task_assigned, task_due, task_updates, task_comments,
            board_invite, board_updates,
            team_invite, team_updates,
            project_update,
            okr_progress, okr_comments,
            mentions
          ) VALUES (
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
          ) RETURNING id
        `, [
          userId,
          defaultSettings.taskAssigned,
          defaultSettings.taskDue,
          defaultSettings.taskUpdates,
          defaultSettings.taskComments,
          defaultSettings.boardInvite,
          defaultSettings.boardUpdates,
          defaultSettings.teamInvite,
          defaultSettings.teamUpdates,
          defaultSettings.projectUpdate,
          defaultSettings.okrProgress,
          defaultSettings.okrComments,
          defaultSettings.mentions
        ]);
        defaultSettings.id = insertResult.rows[0].id;
        return res.json(defaultSettings);
      }
      res.json(result.rows[0]);
    } catch (error) {
      console.error("Failed to fetch notification settings:", error);
      res.status(500).json({
        message: "Benachrichtigungseinstellungen konnten nicht abgerufen werden",
        details: error instanceof Error ? error.message : String(error)
      });
    }
  });
  app2.patch("/api/notification-settings", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      const updates = req.body;
      const checkResult = await pool.query(
        "SELECT id FROM notification_settings WHERE user_id = $1",
        [userId]
      );
      if (checkResult.rows.length === 0) {
        return res.status(404).json({ message: "Benachrichtigungseinstellungen nicht gefunden" });
      }
      const settingsId = checkResult.rows[0].id;
      const allowedFields = {
        taskAssigned: "task_assigned",
        taskDue: "task_due",
        taskUpdates: "task_updates",
        taskComments: "task_comments",
        boardInvite: "board_invite",
        boardUpdates: "board_updates",
        teamInvite: "team_invite",
        teamUpdates: "team_updates",
        projectUpdate: "project_update",
        okrProgress: "okr_progress",
        okrComments: "okr_comments",
        mentions: "mentions"
      };
      const updatePairs = [];
      const updateValues = [];
      let paramCounter = 1;
      for (const [key, value] of Object.entries(updates)) {
        if (key in allowedFields && typeof value === "boolean") {
          updatePairs.push(`${allowedFields[key]} = $${paramCounter}`);
          updateValues.push(value);
          paramCounter++;
        }
      }
      if (updatePairs.length > 0) {
        const updateQuery = `
          UPDATE notification_settings 
          SET ${updatePairs.join(", ")} 
          WHERE id = $${paramCounter}
          RETURNING *
        `;
        updateValues.push(settingsId);
        const result = await pool.query(updateQuery, updateValues);
        const updatedSettings = {
          id: result.rows[0].id,
          userId: result.rows[0].user_id,
          taskAssigned: result.rows[0].task_assigned,
          taskDue: result.rows[0].task_due,
          taskUpdates: result.rows[0].task_updates,
          taskComments: result.rows[0].task_comments,
          boardInvite: result.rows[0].board_invite,
          boardUpdates: result.rows[0].board_updates,
          teamInvite: result.rows[0].team_invite,
          teamUpdates: result.rows[0].team_updates,
          projectUpdate: result.rows[0].project_update,
          okrProgress: result.rows[0].okr_progress,
          okrComments: result.rows[0].okr_comments,
          mentions: result.rows[0].mentions
        };
        return res.json(updatedSettings);
      }
      res.status(400).json({ message: "Keine g\xFCltigen Felder zum Aktualisieren gefunden" });
    } catch (error) {
      console.error("Failed to update notification settings:", error);
      res.status(500).json({
        message: "Benachrichtigungseinstellungen konnten nicht aktualisiert werden",
        details: error instanceof Error ? error.message : String(error)
      });
    }
  });
  app2.get("/api/companies/:id", requireAuth, async (req, res) => {
    try {
      const companyId = parseInt(req.params.id);
      if (isNaN(companyId)) {
        return res.status(400).json({ message: "Ung\xFCltige Unternehmens-ID" });
      }
      const canAccess = await permissionService.canAccessCompany(req.userId, companyId);
      if (!canAccess) {
        return res.status(403).json({ message: "Keine Berechtigung zum Zugriff auf dieses Unternehmen" });
      }
      const result = await pool.query(
        "SELECT * FROM companies WHERE id = $1",
        [companyId]
      );
      if (result.rows.length === 0) {
        return res.status(404).json({ message: "Unternehmen nicht gefunden" });
      }
      res.json(result.rows[0]);
    } catch (error) {
      console.error("Error fetching company:", error);
      res.status(500).json({ message: "Fehler beim Abrufen der Unternehmensdaten" });
    }
  });
  app2.get("/api/companies/current", requireAuth, async (req, res) => {
    try {
      console.log(`[COMPANY_DEBUG] Fetching current company for user ID: ${req.userId}`);
      if (!req.userId) {
        console.log("[COMPANY_DEBUG] User not authenticated");
        return res.status(401).json({ message: "Nicht authentifiziert" });
      }
      const company = await storage.getCurrentUserCompany(req.userId);
      console.log("[COMPANY_DEBUG] Company data:", JSON.stringify(company, null, 2));
      return res.json(company);
    } catch (error) {
      console.error("[COMPANY_DEBUG] Unexpected error:", error);
      if (error instanceof Error) {
        if (error.message.includes("not found")) {
          return res.status(404).json({ message: "Benutzer nicht gefunden" });
        } else if (error.message.includes("Ung\xFCltige")) {
          return res.status(400).json({ message: error.message });
        }
      }
      return res.status(500).json({
        message: "Fehler beim Abrufen der Unternehmensdaten",
        details: error instanceof Error ? error.message : String(error)
      });
    }
  });
  app2.get("/api/companies/members/:companyId", requireAuth, async (req, res) => {
    try {
      const companyId = parseInt(req.params.companyId);
      if (isNaN(companyId)) {
        return res.status(400).json({ message: "Ung\xFCltige Unternehmens-ID" });
      }
      const canAccess = await permissionService.canAccessCompany(req.userId, companyId);
      if (!canAccess) {
        return res.status(403).json({ message: "Keine Berechtigung zum Zugriff auf dieses Unternehmen" });
      }
      const result = await pool.query(`
        SELECT 
          id, 
          username, 
          email, 
          avatar_url AS "avatarUrl", 
          is_company_admin AS "isCompanyAdmin"
        FROM users 
        WHERE company_id = $1 AND is_active = true
      `, [companyId]);
      res.json(result.rows);
    } catch (error) {
      console.error("Error fetching company members:", error);
      res.status(500).json({ message: "Fehler beim Abrufen der Unternehmensmitglieder" });
    }
  });
  app2.get("/api/boards/:boardId/columns", requireAuth, async (req, res) => {
    const boardId = parseInt(req.params.boardId);
    if (isNaN(boardId)) {
      return res.status(400).json({ message: "Invalid board ID" });
    }
    try {
      const userId = req.userId;
      const columns2 = await storage.getColumns(userId, boardId);
      res.json(columns2);
    } catch (error) {
      res.status(500).json({ message: error.message });
    }
  });
  app2.post("/api/boards/:boardId/columns", requireAuth, async (req, res) => {
    const boardId = parseInt(req.params.boardId);
    if (isNaN(boardId)) {
      return res.status(400).json({ message: "Invalid board ID" });
    }
    const result = insertColumnSchema.safeParse({ ...req.body, boardId });
    if (!result.success) {
      return res.status(400).json({
        message: "Invalid column data",
        errors: result.error.errors
      });
    }
    try {
      const userId = req.userId;
      const column = await storage.createColumn(userId, result.data);
      res.status(201).json(column);
    } catch (error) {
      res.status(500).json({ message: error.message });
    }
  });
  app2.patch("/api/columns/:id", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Invalid column ID" });
    }
    try {
      const userId = req.userId;
      const column = await storage.updateColumn(userId, id, req.body);
      res.json(column);
    } catch (error) {
      res.status(404).json({ message: error.message });
    }
  });
  app2.delete("/api/columns/:id", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Invalid column ID" });
    }
    try {
      const userId = req.userId;
      await storage.deleteColumn(userId, id);
      res.status(204).send();
    } catch (error) {
      res.status(404).json({ message: error.message });
    }
  });
  app2.post("/api/profile/avatar", requireAuth, avatarUpload.single("avatar"), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      }
      const userId = req.userId;
      const avatarUrl = `/uploads/avatars/${req.file.filename}`;
      const updatedUser = await storage.updateUser(userId, userId, { avatarUrl });
      const { passwordHash: _, ...userWithoutPassword } = updatedUser;
      res.json(userWithoutPassword);
    } catch (error) {
      console.error("Failed to upload avatar:", error);
      res.status(500).json({ message: "Failed to upload avatar" });
    }
  });
  app2.get("/api/teams", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      const userResult = await pool.query(
        "SELECT subscription_tier FROM users WHERE id = $1",
        [userId]
      );
      if (userResult.rows.length === 0) {
        return res.status(404).json({ message: "User not found" });
      }
      const subscriptionTier = userResult.rows[0].subscription_tier?.toLowerCase() || "free";
      if (["free", "freelancer"].includes(subscriptionTier)) {
        return res.json([]);
      }
      const teams2 = await storage.getTeams(userId);
      res.json(teams2);
    } catch (error) {
      console.error("Failed to fetch teams:", error);
      res.status(500).json({ message: "Failed to fetch teams" });
    }
  });
  app2.get("/api/teams/:id", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Invalid team ID" });
    }
    try {
      const userId = req.userId;
      const team = await storage.getTeam(userId, id);
      if (!team) {
        return res.status(404).json({ message: "Team not found" });
      }
      res.json(team);
    } catch (error) {
      console.error("Failed to fetch team:", error);
      res.status(500).json({ message: "Failed to fetch team" });
    }
  });
  app2.post("/api/teams", requireAuth, async (req, res) => {
    const result = insertTeamSchema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({ message: result.error.message });
    }
    try {
      const userId = req.userId;
      const user = await storage.getUser(userId, userId);
      if (user.companyId) {
        const hasReachedLimit = await subscriptionService.hasReachedTeamLimit(user.companyId);
        if (hasReachedLimit) {
          return res.status(403).json({
            message: "Team-Limit erreicht",
            details: "Das Team-Limit f\xFCr Ihr Abonnement wurde erreicht. Bitte upgraden Sie Ihr Abonnement, um weitere Teams zu erstellen."
          });
        }
      }
      const team = await storage.createTeam(userId, result.data);
      res.status(201).json(team);
    } catch (error) {
      console.error("Failed to create team:", error);
      res.status(500).json({ message: "Failed to create team" });
    }
  });
  app2.patch("/api/teams/:id", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Invalid team ID" });
    }
    try {
      console.log("Team update request body:", req.body);
      const teamData = {
        ...req.body,
        member_ids: req.body.member_ids ? Array.isArray(req.body.member_ids) ? req.body.member_ids.map((id2) => id2.toString()) : [req.body.member_ids.toString()] : void 0
      };
      const result = insertTeamSchema.partial().safeParse(teamData);
      if (!result.success) {
        console.error("Team validation error:", result.error.format());
        return res.status(400).json({
          message: "Invalid team data",
          errors: result.error.errors
        });
      }
      const userId = req.userId;
      const team = await storage.updateTeam(userId, id, result.data);
      if (!team) {
        return res.status(404).json({ message: "Team not found" });
      }
      res.json(team);
    } catch (error) {
      console.error("Failed to update team:", error);
      res.status(500).json({ message: "Failed to update team" });
    }
  });
  app2.delete("/api/teams/:id", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Invalid team ID" });
    }
    try {
      const userId = req.userId;
      await storage.deleteTeam(userId, id);
      res.status(204).send();
    } catch (error) {
      console.error("Failed to delete team:", error);
      res.status(500).json({ message: "Failed to delete team" });
    }
  });
  app2.patch("/api/projects/:id/favorite", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Invalid project ID" });
    }
    try {
      const userId = req.userId;
      const project = await storage.toggleProjectFavorite(userId, id);
      res.json(project);
    } catch (error) {
      res.status(500).json({ message: "Failed to toggle favorite status" });
    }
  });
  app2.patch("/api/boards/:id/favorite", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Invalid board ID" });
    }
    try {
      const userId = req.userId;
      const board = await storage.toggleBoardFavorite(userId, id);
      res.json(board);
    } catch (error) {
      res.status(500).json({ message: "Failed to toggle favorite status" });
    }
  });
  app2.patch("/api/objectives/:id/favorite", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Invalid objective ID" });
    }
    try {
      const userId = req.userId;
      const objective = await storage.toggleObjectiveFavorite(userId, id);
      res.json(objective);
    } catch (error) {
      res.status(500).json({ message: "Failed to toggle favorite status" });
    }
  });
  registerProductivityRoutes(app2);
  setupAdminRoutes(app2, db5);
  const { registerOkrRoutes: registerOkrRoutes2 } = await Promise.resolve().then(() => (init_okrRoutes(), okrRoutes_exports));
  app2.get("/api/okrs", requireAuth, async (req, res) => {
    try {
      const user = await db5.query.users.findFirst({
        where: eq7(users.id, req.userId)
      });
      if (user && ["free", "freelancer"].includes(user.subscriptionTier?.toLowerCase() || "free")) {
        return res.json([]);
      }
      const okrs = await storage.getObjectives(req.userId);
      res.json(okrs);
    } catch (error) {
      console.error("Failed to fetch OKRs:", error);
      res.status(500).json({ message: "Failed to fetch OKRs" });
    }
  });
  registerOkrRoutes2(app2);
  app2.get("/api/companies/:companyId/members", requireAuth, async (req, res) => {
    try {
      const companyId = parseInt(req.params.companyId);
      if (isNaN(companyId)) {
        return res.status(400).json({ error: "Ung\xFCltige Unternehmens-ID" });
      }
      const members = await storage.getCompanyMembers(req.userId, companyId);
      res.json(members);
    } catch (error) {
      console.error("Error in GET /api/companies/:companyId/members:", error);
      res.status(500).json({ error: "Fehler beim Abrufen der Unternehmensmitglieder" });
    }
  });
  app2.patch("/api/companies/members/:userId/role", requireAuth, async (req, res) => {
    try {
      const targetUserId = parseInt(req.params.userId);
      if (isNaN(targetUserId)) {
        return res.status(400).json({ error: "Ung\xFCltige Benutzer-ID" });
      }
      const { isAdmin } = req.body;
      if (typeof isAdmin !== "boolean") {
        return res.status(400).json({ error: "isAdmin muss ein boolescher Wert sein" });
      }
      const user = await storage.updateUserCompanyRole(req.userId, targetUserId, isAdmin);
      res.json(user);
    } catch (error) {
      console.error("Error in PATCH /api/companies/members/:userId/role:", error);
      res.status(500).json({ error: "Fehler beim Aktualisieren der Benutzerrolle" });
    }
  });
  app2.post("/api/companies/:companyId/invite", requireAuth, async (req, res) => {
    try {
      const companyId = parseInt(req.params.companyId);
      if (isNaN(companyId)) {
        return res.status(400).json({ error: "Ung\xFCltige Unternehmens-ID" });
      }
      const inviteCode = await storage.generateCompanyInviteCode(req.userId, companyId);
      res.json({ inviteCode });
    } catch (error) {
      console.error("Error in POST /api/companies/:companyId/invite:", error);
      res.status(500).json({ error: "Fehler beim Generieren des Einladungscodes" });
    }
  });
  app2.post("/api/companies/join", requireAuth, async (req, res) => {
    try {
      const { inviteCode } = req.body;
      if (!inviteCode || typeof inviteCode !== "string") {
        return res.status(400).json({ error: "G\xFCltiger Einladungscode erforderlich" });
      }
      const company = await storage.joinCompanyWithInviteCode(req.userId, inviteCode);
      res.json(company);
    } catch (error) {
      console.error("Error in POST /api/companies/join:", error);
      res.status(500).json({ error: "Fehler beim Beitreten zum Unternehmen" });
    }
  });
  app2.post("/api/companies", requireAuth, async (req, res) => {
    try {
      const { name, description } = req.body;
      if (!name || typeof name !== "string") {
        return res.status(400).json({ error: "Unternehmensname ist erforderlich" });
      }
      const companyData = {
        name,
        description: description || null
      };
      const company = await storage.createCompany(req.userId, companyData);
      res.status(201).json(company);
    } catch (error) {
      console.error("Error in POST /api/companies:", error);
      if (error.message && (error.message.includes("Die Erstellung eines Unternehmens erfordert mindestens ein Basic-Abonnement") || error.message.includes("Sie sind bereits Mitglied eines Unternehmens"))) {
        return res.status(400).json({ error: error.message });
      }
      res.status(500).json({ error: "Fehler beim Erstellen des Unternehmens" });
    }
  });
  app2.get("/api/team-members", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      const result = await storage.getTeamMembers(userId);
      res.json(result);
    } catch (error) {
      console.error("Failed to fetch team members:", error);
      res.status(500).json({ message: "Failed to fetch team members" });
    }
  });
  app2.post("/api/upload", requireAuth, fileUpload.single("file"), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "Keine Datei hochgeladen" });
      }
      ensureDirectoryExists("./uploads/attachments/tasks");
      ensureDirectoryExists("./uploads/attachments/objectives");
      ensureDirectoryExists("./uploads/attachments/key-results");
      ensureDirectoryExists("./uploads/attachments/comments");
      const userId = req.userId;
      const { type = "general", entityId } = req.body;
      const filePath = req.file.path.replace(/^\.\//, "");
      const urlPath = filePath.startsWith("/") ? filePath : `/${filePath}`;
      console.log("Datei hochgeladen:", {
        userId,
        type,
        entityId,
        originalname: req.file.originalname,
        mimetype: req.file.mimetype,
        size: req.file.size,
        path: filePath
      });
      if (entityId) {
        try {
          const entityIdNum = parseInt(entityId);
          if (!isNaN(entityIdNum)) {
            const logData = {
              action: "upload",
              details: `Datei "${req.file.originalname}" hochgeladen`,
              user_id: userId
            };
            switch (type) {
              case "task":
                logData.task_id = entityIdNum;
                try {
                  const taskResult = await pool.query(
                    "SELECT board_id FROM tasks WHERE id = $1",
                    [entityIdNum]
                  );
                  if (taskResult.rows.length > 0) {
                    logData.board_id = taskResult.rows[0].board_id;
                  }
                } catch (err) {
                  console.error("Fehler beim Abrufen der Board-ID f\xFCr die Task:", err);
                }
                break;
              case "objective":
                logData.objective_id = entityIdNum;
                break;
              case "keyResult":
                logData.key_result_id = entityIdNum;
                try {
                  const krResult = await pool.query(
                    "SELECT objective_id FROM key_results WHERE id = $1",
                    [entityIdNum]
                  );
                  if (krResult.rows.length > 0) {
                    logData.objective_id = krResult.rows[0].objective_id;
                  }
                } catch (err) {
                  console.error("Fehler beim Abrufen der Objective-ID f\xFCr das Key Result:", err);
                }
                break;
              case "comment":
                logData.comment_id = entityIdNum;
                break;
            }
            const activityLog = await storage.createActivityLog(logData);
            await notificationService.processActivityLog(activityLog.id);
          }
        } catch (logError) {
          console.error("Fehler beim Erstellen des Aktivit\xE4tslogs f\xFCr den Upload:", logError);
        }
      }
      if (type === "task" && entityId) {
        try {
          const taskId = parseInt(entityId);
          if (!isNaN(taskId)) {
            const taskResult = await pool.query(
              "SELECT attachments FROM tasks WHERE id = $1",
              [taskId]
            );
            if (taskResult.rows.length > 0) {
              const currentTask = taskResult.rows[0];
              let currentAttachments = currentTask.attachments || [];
              if (!Array.isArray(currentAttachments)) {
                currentAttachments = [];
              }
              currentAttachments.push(urlPath);
              await pool.query(
                "UPDATE tasks SET attachments = $1 WHERE id = $2",
                [currentAttachments, taskId]
              );
              console.log(`Task ${taskId} mit neuem Anhang ${filePath} aktualisiert.`);
            }
          }
        } catch (err) {
          console.error("Fehler beim direkten Aktualisieren der Task mit dem Anhang:", err);
        }
      }
      res.json({
        url: urlPath,
        // Hier urlPath statt filePath verwenden, damit der Pfad korrekt für den Browser formatiert ist
        filename: req.file.filename,
        originalname: req.file.originalname,
        mimetype: req.file.mimetype,
        size: req.file.size
      });
    } catch (error) {
      console.error("Fehler beim Hochladen der Datei:", error);
      res.status(500).json({ message: "Fehler beim Hochladen der Datei" });
    }
  });
  app2.post("/api/objectives", requireAuth, async (req, res) => {
    try {
      console.log("Received objective creation request:", req.body);
      const result = insertObjectiveSchema.safeParse(req.body);
      if (!result.success) {
        console.error("Objective validation failed:", result.error.errors);
        return res.status(400).json({
          message: "Invalid objective data",
          errors: result.error.errors
        });
      }
      const userId = req.userId;
      result.data.creatorId = userId;
      const user = await storage.getUser(userId, userId);
      if (user.companyId) {
        const hasReachedLimit = await subscriptionService.hasReachedOkrLimit(user.companyId);
        if (hasReachedLimit) {
          return res.status(403).json({
            message: "OKR-Limit erreicht",
            details: "Das OKR-Limit f\xFCr Ihr Abonnement wurde erreicht. Bitte upgraden Sie Ihr Abonnement, um weitere OKRs zu erstellen."
          });
        }
      }
      console.log("Creating objective with validated data:", result.data);
      const objective = await storage.createObjective(userId, result.data);
      console.log("Created objective:", objective);
      console.log("Creating activity log with data:", {
        action: "create",
        details: "Neues OKR erstellt",
        user_id: result.data.creatorId,
        objective_id: objective.id,
        project_id: result.data.projectId || null
      });
      const activityLog = await storage.createActivityLog({
        action: "create",
        details: "Neues OKR erstellt",
        user_id: result.data.creatorId,
        objective_id: objective.id,
        project_id: result.data.projectId || null,
        board_id: null,
        task_id: null
      });
      await notificationService.processActivityLog(activityLog.id);
      console.log("Activity log created:", activityLog);
      res.status(201).json(objective);
    } catch (error) {
      console.error("Failed to create objective:", error);
      res.status(500).json({
        message: error instanceof Error ? error.message : "Failed to create objective",
        error
      });
    }
  });
  app2.delete("/api/tasks/:id", requireAuth, async (req, res) => {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      return res.status(400).json({ message: "Invalid task ID" });
    }
    try {
      const userId = req.userId;
      const task = await storage.getTasks(userId, null).then(
        (tasks2) => tasks2.find((t) => t.id === id)
      );
      if (!task) {
        return res.status(404).json({ message: "Task not found" });
      }
      const activityLog = await storage.createActivityLog({
        action: "delete",
        details: "Aufgabe gel\xF6scht",
        user_id: userId,
        task_id: id,
        board_id: task.boardId
      });
      await notificationService.processActivityLog(activityLog.id);
      await storage.deleteTask(userId, id);
      res.status(204).send();
    } catch (error) {
      res.status(404).json({ message: error.message });
    }
  });
  app2.get("/api/debug/board-limit", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      const userResult = await pool.query('SELECT id, username, email, "subscription_tier" AS "subscriptionTier", "company_id" AS "companyId" FROM users WHERE id = $1', [userId]);
      const boardCountResult = await pool.query(
        "SELECT COUNT(*) FROM boards WHERE creator_id = $1 AND (archived IS NULL OR archived = false)",
        [userId]
      );
      const boardCount = parseInt(boardCountResult.rows[0]?.count || "0");
      const boardsResult = await pool.query(
        "SELECT id, title, creator_id, archived FROM boards WHERE creator_id = $1 LIMIT 10",
        [userId]
      );
      const user = userResult.rows[0] || { subscriptionTier: "free" };
      const subscriptionTier = user?.subscriptionTier || "free";
      let maxBoards = 1;
      if (subscriptionTier === "freelancer") {
        maxBoards = 5;
      } else if (subscriptionTier === "business") {
        maxBoards = 10;
      } else if (subscriptionTier !== "free") {
        maxBoards = 20;
      }
      const hasReachedLimit = boardCount >= maxBoards;
      let companyLimitInfo = null;
      if (user.companyId) {
        try {
          const paymentInfoResult = await pool.query(
            'SELECT "subscription_tier" AS "subscriptionTier" FROM company_payment_info WHERE "company_id" = $1',
            [user.companyId]
          );
          const companySubscriptionTier = paymentInfoResult.rows[0]?.subscriptionTier || "free";
          const packageLimitsResult = await pool.query(
            'SELECT "max_boards" AS "maxBoards" FROM subscription_packages WHERE name = $1',
            [companySubscriptionTier]
          );
          let companyMaxBoards = 1;
          if (companySubscriptionTier === "freelancer") {
            companyMaxBoards = 5;
          } else if (companySubscriptionTier === "business") {
            companyMaxBoards = 10;
          } else if (companySubscriptionTier !== "free") {
            companyMaxBoards = 20;
          }
          const companyUsersResult = await pool.query(
            'SELECT id FROM users WHERE "company_id" = $1',
            [user.companyId]
          );
          const companyUserIds = companyUsersResult.rows.map((u) => u.id);
          let companyBoardCount = 0;
          if (companyUserIds.length > 0) {
            const companyBoardCountResult = await pool.query(
              'SELECT COUNT(*) FROM boards WHERE (archived IS NULL OR archived = false) AND creator_id IN (SELECT id FROM users WHERE "company_id" = $1)',
              [user.companyId]
            );
            companyBoardCount = parseInt(companyBoardCountResult.rows[0]?.count || "0");
          }
          const hasCompanyReachedLimit = companyBoardCount >= companyMaxBoards;
          companyLimitInfo = {
            companyId: user.companyId,
            companySubscriptionTier,
            companyMaxBoards,
            companyBoardCount,
            hasCompanyReachedLimit,
            companyUserCount: companyUserIds.length
          };
        } catch (companyError) {
          console.error("Fehler bei Firmenpr\xFCfung:", companyError);
          companyLimitInfo = { error: String(companyError) };
        }
      }
      res.json({
        userId,
        username: user.username,
        subscriptionTier,
        maxBoards,
        currentBoards: boardCount,
        hasReachedLimit,
        boardDetails: boardsResult.rows,
        companyLimitInfo,
        message: hasReachedLimit ? `Board-Limit erreicht (${boardCount}/${maxBoards})` : `Board-Limit nicht erreicht (${boardCount}/${maxBoards})`
      });
    } catch (error) {
      console.error("Debug board limit error:", error);
      res.status(500).json({
        message: "Fehler beim Debug-Check",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });
  app2.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
  });
}

// server/vite.ts
import express from "express";
import fs2 from "fs";
import path4 from "path";
import { fileURLToPath as fileURLToPath2 } from "url";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import themePlugin from "@replit/vite-plugin-shadcn-theme-json";
import path3, { dirname } from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
import { fileURLToPath } from "url";
var __filename = fileURLToPath(import.meta.url);
var __dirname = dirname(__filename);
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    themePlugin(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      )
    ] : []
  ],
  server: {
    host: "0.0.0.0",
    port: 3e3,
    hmr: {
      clientPort: 443,
      host: "0.0.0.0"
    },
    headers: {
      "Content-Type": "application/javascript"
    }
  },
  resolve: {
    alias: {
      "@": path3.resolve(__dirname, "client", "src"),
      "@shared": path3.resolve(__dirname, "shared")
    }
  },
  root: path3.resolve(__dirname, "client"),
  build: {
    outDir: path3.resolve(__dirname, "dist/public"),
    emptyOutDir: true
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var __filename2 = fileURLToPath2(import.meta.url);
var __dirname2 = path4.dirname(__filename2);
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: {
      server,
      port: 443,
      clientPort: 443,
      path: "/hmr/"
    },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        console.error("Vite error:", msg);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path4.resolve(
        __dirname2,
        "..",
        "client",
        "index.html"
      );
      let template = await fs2.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}

// server/index.ts
init_auth();
init_storage();
import path5 from "path";
import cors from "cors";
import knex from "knex";
import session from "express-session";
import MemoryStore from "memorystore";
import { createServer } from "http";

// server/protocolRoutes.ts
init_storage();
init_auth();
init_schema();
function registerProtocolRoutes(app2) {
  app2.get("/api/protocols/team/:teamId", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      const teamId = parseInt(req.params.teamId);
      const protocols = await storage.getMeetingProtocolsByTeam(userId, teamId);
      res.json(protocols);
    } catch (error) {
      console.error("Error fetching team protocols:", error);
      res.status(400).json({ message: error.message || "Fehler beim Abrufen der Protokolle" });
    }
  });
  app2.get("/api/protocols/project/:projectId", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      const projectId = parseInt(req.params.projectId);
      const protocols = await storage.getMeetingProtocolsByProject(userId, projectId);
      res.json(protocols);
    } catch (error) {
      console.error("Error fetching project protocols:", error);
      res.status(400).json({ message: error.message || "Fehler beim Abrufen der Protokolle" });
    }
  });
  app2.get("/api/protocols/objective/:objectiveId", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      const objectiveId = parseInt(req.params.objectiveId);
      const protocols = await storage.getMeetingProtocolsByObjective(userId, objectiveId);
      res.json(protocols);
    } catch (error) {
      console.error("Error fetching objective protocols:", error);
      res.status(400).json({ message: error.message || "Fehler beim Abrufen der Protokolle" });
    }
  });
  app2.get("/api/protocols/:id", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      const protocolId = parseInt(req.params.id);
      const protocol = await storage.getMeetingProtocol(userId, protocolId);
      res.json(protocol);
    } catch (error) {
      console.error("Error fetching protocol:", error);
      res.status(400).json({ message: error.message || "Fehler beim Abrufen des Protokolls" });
    }
  });
  app2.post("/api/protocols", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      if (!req.body.creatorId) {
        req.body.creatorId = userId;
      }
      if (req.body.date && typeof req.body.date === "string") {
        req.body.date = new Date(req.body.date);
      }
      const validationResult = insertMeetingProtocolSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Ung\xFCltige Protokolldaten",
          errors: validationResult.error.format()
        });
      }
      if (!validationResult.data.teamId && !validationResult.data.projectId && !validationResult.data.objectiveId) {
        return res.status(400).json({
          message: "Entweder teamId, projectId oder objectiveId muss angegeben werden"
        });
      }
      const newProtocol = await storage.createMeetingProtocol(userId, validationResult.data);
      const activityLog = await storage.createActivityLog({
        action: "create",
        details: "Neues Protokoll erstellt",
        userId,
        requiresNotification: true,
        notificationType: "protocol",
        teamId: validationResult.data.teamId,
        projectId: validationResult.data.projectId,
        objectiveId: validationResult.data.objectiveId
      });
      await notificationService.processActivityLog(activityLog.id);
      res.status(201).json(newProtocol);
    } catch (error) {
      console.error("Error creating protocol:", error);
      res.status(400).json({ message: error.message || "Fehler beim Erstellen des Protokolls" });
    }
  });
  app2.patch("/api/protocols/:id", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      const protocolId = parseInt(req.params.id);
      if (!req.body.creatorId) {
        req.body.creatorId = userId;
      }
      if (req.body.date && typeof req.body.date === "string") {
        req.body.date = new Date(req.body.date);
      }
      const updateData = insertMeetingProtocolSchema.partial().safeParse(req.body);
      if (!updateData.success) {
        return res.status(400).json({
          message: "Ung\xFCltige Protokolldaten",
          errors: updateData.error.format()
        });
      }
      const updatedProtocol = await storage.updateMeetingProtocol(userId, protocolId, updateData.data);
      const activityLog = await storage.createActivityLog({
        action: "update",
        details: "Protokoll aktualisiert",
        userId,
        requiresNotification: true,
        notificationType: "protocol_update",
        teamId: updateData.data.teamId,
        projectId: updateData.data.projectId,
        objectiveId: updateData.data.objectiveId,
        protocolId,
        visibleToTeams: updateData.data.teamParticipants || []
      });
      await notificationService.processActivityLog(activityLog.id);
      res.json(updatedProtocol);
    } catch (error) {
      console.error("Error updating protocol:", error);
      res.status(400).json({ message: error.message || "Fehler beim Aktualisieren des Protokolls" });
    }
  });
  app2.delete("/api/protocols/:id", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      const protocolId = parseInt(req.params.id);
      const protocol = await storage.getMeetingProtocol(userId, protocolId);
      await storage.deleteMeetingProtocol(userId, protocolId);
      const activityLog = await storage.createActivityLog({
        action: "delete",
        details: "Protokoll gel\xF6scht",
        userId,
        requiresNotification: true,
        notificationType: "protocol_delete",
        teamId: protocol.teamId,
        projectId: protocol.projectId,
        objectiveId: protocol.objectiveId
      });
      await notificationService.processActivityLog(activityLog.id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting protocol:", error);
      res.status(400).json({ message: error.message || "Fehler beim L\xF6schen des Protokolls" });
    }
  });
}

// server/subscriptionRoutes.ts
init_db();
init_schema();
init_schema();
init_auth();
init_subscription_service();

// server/stripe-service.ts
init_db();
init_schema();
import Stripe from "stripe";
import { eq as eq8, desc as desc4 } from "drizzle-orm";
var secretKeyToUse = process.env.STRIPE_SECRET_KEY || "";
if (!secretKeyToUse) {
  console.error("WARNUNG: Kein Stripe Secret Key gefunden! Stelle sicher, dass STRIPE_SECRET_KEY als Umgebungsvariable verf\xFCgbar ist.");
} else {
  console.log("Stripe Secret Key aus Umgebungsvariable f\xFCr Stripe-Service verwenden");
}
var stripe = new Stripe(secretKeyToUse, {
  apiVersion: "2025-02-24.acacia"
  // Aktueller API-Version für die Stripe-Typelib, Type-Cast zum Umgehen der Typrüfung
});
var StripeService = class {
  /**
   * Erstellt einen Checkout-Link für den Wechsel zu einem neuen Abonnement-Paket
   * 
   * @param userId Benutzer-ID
   * @param newTier Neue Abonnement-Stufe
   * @param billingCycle Abrechnungszyklus ('monthly' oder 'yearly')
   * @returns Objekt mit Erfolgs-Flag und optionalem Checkout-URL
   */
  async switchSubscription(userId, newTier, billingCycle = "monthly") {
    try {
      console.log(`StripeService: Wechsel des Abonnements f\xFCr Benutzer ${userId} auf Tier ${newTier} mit Zyklus ${billingCycle}`);
      console.log(`StripeService: DEBUG - Stripe-Konfiguration: API-Schl\xFCssel vorhanden=${!!secretKeyToUse}, API-Key-Length=${secretKeyToUse.length}`);
      console.log(`StripeService: DEBUG - Stripe-Instance initialisiert: ${!!stripe}`);
      console.log(`StripeService: DEBUG - Aktion: switchSubscription wird ausgef\xFChrt`);
      if (!secretKeyToUse) {
        console.error("StripeService: Kein Stripe Secret Key vorhanden. Die Stripe-Integration wird \xFCbersprungen, aber die Datenbank wird aktualisiert.");
        await this.updateDatabaseOnly(userId, newTier, billingCycle);
        return { success: true, checkoutUrl: null, requiresPayment: false };
      }
      const user = await db.query.users.findFirst({
        where: eq8(users.id, userId)
      });
      if (!user) {
        console.error(`StripeService: Benutzer ${userId} nicht gefunden`);
        return { success: false, requiresPayment: false };
      }
      const currentSubscription = await db.select().from(subscriptions).where(eq8(subscriptions.userId, userId)).orderBy(desc4(subscriptions.createdAt)).limit(1);
      const newPackage = await db.query.subscriptionPackages.findFirst({
        where: eq8(subscriptionPackages.name, newTier)
      });
      if (!newPackage) {
        console.error(`StripeService: Paket ${newTier} nicht gefunden`);
        return { success: false, requiresPayment: false };
      }
      if (currentSubscription.length > 0 && currentSubscription[0].stripeSubscriptionId) {
        try {
          console.log(`StripeService: K\xFCndige bestehendes Abonnement ${currentSubscription[0].stripeSubscriptionId}`);
          await stripe.subscriptions.cancel(currentSubscription[0].stripeSubscriptionId);
          await db.update(subscriptions).set({
            status: "cancelled",
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq8(subscriptions.id, currentSubscription[0].id));
          console.log(`StripeService: Bestehendes Abonnement ${currentSubscription[0].id} wurde gek\xFCndigt`);
        } catch (stripeError) {
          console.error("StripeService: Fehler beim K\xFCndigen des Abonnements bei Stripe:", stripeError);
        }
      } else {
        console.log(`StripeService: Kein bestehendes Abonnement mit Stripe-ID f\xFCr Benutzer ${userId} gefunden`);
      }
      const tempSubscription = await db.insert(subscriptions).values({
        userId,
        packageId: newPackage.id,
        status: "pending",
        // Status auf "pending" setzen
        billingCycle,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      if (!tempSubscription || tempSubscription.length === 0) {
        console.error("StripeService: Konnte keine tempor\xE4re Subscription erstellen");
        return { success: false, requiresPayment: false };
      }
      const subscriptionId = tempSubscription[0].id;
      try {
        const baseUrl = process.env.REQUEST_URL || "https://0fe82899-989d-49e3-8509-b9664bfb91a4.id.replit.app";
        const interval = billingCycle === "yearly" ? "year" : "month";
        console.log(`StripeService: Erstelle Checkout-Session mit Basis-URL: ${baseUrl}`);
        console.log(`StripeService: Package Daten: name=${newPackage.name}, price=${newPackage.price}, interval=${interval}`);
        try {
          const session2 = await stripe.checkout.sessions.create({
            payment_method_types: ["card"],
            line_items: [
              {
                price_data: {
                  currency: "eur",
                  product_data: {
                    name: newPackage.displayName || newPackage.name,
                    description: `Abonnement-Paket: ${newPackage.name}`
                  },
                  unit_amount: newPackage.price,
                  recurring: {
                    interval
                  }
                },
                quantity: 1
              }
            ],
            mode: "subscription",
            success_url: `${baseUrl}/payment/success?session_id={CHECKOUT_SESSION_ID}&subscription_id=${subscriptionId}`,
            cancel_url: `${baseUrl}/subscription-plans`,
            customer_email: user.email,
            client_reference_id: subscriptionId.toString(),
            metadata: {
              subscriptionId: subscriptionId.toString(),
              packageId: newPackage.id.toString(),
              packageName: newPackage.name,
              userId: userId.toString(),
              billingCycle
            },
            // Zahlungsmethode für zukünftige Abrechnungen speichern
            payment_method_collection: "always",
            payment_intent_data: {
              setup_future_usage: "off_session"
            }
          });
          if (!session2.url) {
            throw new Error("Keine Checkout-URL von Stripe erhalten");
          }
          console.log(`StripeService: Checkout-Session erfolgreich erstellt, URL: ${session2.url}`);
          await db.insert(subscriptionAuditLogs).values({
            userId,
            companyId: user.companyId,
            action: "checkout_started",
            oldTier: currentSubscription.length > 0 ? currentSubscription[0].packageId.toString() : "none",
            newTier,
            details: `Checkout-Prozess f\xFCr Abonnement ${newTier} gestartet mit ${billingCycle} Abrechnungszyklus`
          });
          return {
            success: true,
            checkoutUrl: session2.url,
            requiresPayment: true
          };
        } catch (stripeSessionError) {
          console.error(`StripeService: Fehler beim Erstellen der Checkout-Session:`, stripeSessionError);
          throw stripeSessionError;
        }
      } catch (stripeError) {
        console.error("StripeService: Fehler bei der Stripe-Integration:", stripeError);
        console.log("StripeService: Setze die Datenbankaktualisierung fort ohne Stripe-Integration...");
        const result = await this.updateDatabaseOnly(userId, newTier, billingCycle);
        return result;
      }
    } catch (error) {
      console.error("StripeService: Fehler beim Wechseln des Abonnements:", error);
      return { success: false, requiresPayment: false };
    }
  }
  /**
   * Aktualisiert nur die Datenbank ohne Stripe-Integration
   * Diese Methode wird verwendet, wenn die Stripe-Integration fehlschlägt oder nicht verfügbar ist
   */
  async updateDatabaseOnly(userId, newTier, billingCycle) {
    try {
      console.log(`StripeService: Aktualisiere nur die Datenbank f\xFCr Benutzer ${userId} auf Tier ${newTier}`);
      const user = await db.query.users.findFirst({
        where: eq8(users.id, userId)
      });
      if (!user) {
        console.error(`StripeService: Benutzer ${userId} nicht gefunden`);
        return { success: false, requiresPayment: false };
      }
      const currentSubscription = await db.select().from(subscriptions).where(eq8(subscriptions.userId, userId)).orderBy(desc4(subscriptions.createdAt)).limit(1);
      const newPackage = await db.query.subscriptionPackages.findFirst({
        where: eq8(subscriptionPackages.name, newTier)
      });
      if (!newPackage) {
        console.error(`StripeService: Paket ${newTier} nicht gefunden`);
        return { success: false, requiresPayment: false };
      }
      const newSubscription = await db.insert(subscriptions).values({
        userId,
        packageId: newPackage.id,
        status: "active",
        // Einfach als aktiv markieren ohne Stripe
        billingCycle,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      await db.update(users).set({
        subscriptionTier: newTier,
        subscriptionBillingCycle: billingCycle,
        subscriptionExpiresAt: billingCycle === "yearly" ? new Date(Date.now() + 365 * 24 * 60 * 60 * 1e3) : new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3),
        // 30 Tage
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq8(users.id, userId));
      await db.insert(subscriptionAuditLogs).values({
        userId,
        companyId: user.companyId,
        action: "subscription_switch_db_only",
        oldTier: currentSubscription.length > 0 ? currentSubscription[0].packageId.toString() : "none",
        newTier,
        details: `Abonnement nur in Datenbank gewechselt von ${currentSubscription.length > 0 ? currentSubscription[0].packageId : "keinem"} zu ${newTier} (Stripe-Integration fehlgeschlagen oder deaktiviert)`
      });
      if (user.companyId && user.isCompanyAdmin) {
        const existingPaymentInfo = await db.query.companyPaymentInfo.findFirst({
          where: eq8(companyPaymentInfo.companyId, user.companyId)
        });
        if (existingPaymentInfo) {
          await db.update(companyPaymentInfo).set({
            subscriptionTier: newTier,
            billingCycle,
            subscriptionStatus: "active",
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq8(companyPaymentInfo.companyId, user.companyId));
        }
      }
      console.log(`StripeService: Datenbankaktualisierung abgeschlossen f\xFCr Benutzer ${userId}`);
      return { success: true, checkoutUrl: null, requiresPayment: false };
    } catch (dbError) {
      console.error("StripeService: Fehler bei der Datenbankaktualisierung:", dbError);
      return { success: false, requiresPayment: false };
    }
  }
  /**
   * Erstellt ein Zahlungslink für ein Abonnement
   * 
   * @param userId Benutzer-ID
   * @param packageId Paket-ID
   * @param billingCycle Abrechnungszyklus ('monthly' oder 'yearly') 
   * @returns URL zum Zahlungslink oder null bei Fehler
   */
  async createCheckoutLink(userId, packageId, billingCycle = "monthly") {
    try {
      console.log(`StripeService: Erstelle Checkout-Link f\xFCr Benutzer ${userId}, Paket ${packageId}, Zyklus ${billingCycle}`);
      if (!secretKeyToUse) {
        console.error("StripeService: Kein Stripe Secret Key vorhanden. Die Stripe-Integration wird \xFCbersprungen.");
        return null;
      }
      const user = await db.query.users.findFirst({
        where: eq8(users.id, userId)
      });
      if (!user) {
        console.error(`StripeService: Benutzer ${userId} nicht gefunden`);
        return null;
      }
      const packageInfo = await db.query.subscriptionPackages.findFirst({
        where: eq8(subscriptionPackages.id, packageId)
      });
      if (!packageInfo) {
        console.error(`StripeService: Paket ${packageId} nicht gefunden`);
        return null;
      }
      const tempSubscription = await db.insert(subscriptions).values({
        userId,
        packageId,
        status: "pending",
        billingCycle,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      if (!tempSubscription || tempSubscription.length === 0) {
        console.error("StripeService: Konnte keine tempor\xE4re Subscription erstellen");
        return null;
      }
      const subscriptionId = tempSubscription[0].id;
      try {
        const baseUrl = process.env.REQUEST_URL || "https://0fe82899-989d-49e3-8509-b9664bfb91a4.id.replit.app";
        const interval = billingCycle === "yearly" ? "year" : "month";
        let unitAmount = billingCycle === "yearly" ? Math.round(packageInfo.price * 12 * 0.9) : packageInfo.price;
        console.log(`StripeService: Preisberechnung f\xFCr ${packageInfo.name} (${billingCycle}): 
          Basispreis: ${packageInfo.price} Cent
          Berechneter Preis: ${unitAmount} Cent
          Verwendeter Intervall: ${interval}`);
        const session2 = await stripe.checkout.sessions.create({
          payment_method_types: ["card"],
          line_items: [
            {
              price_data: {
                currency: "eur",
                product_data: {
                  name: packageInfo.displayName || packageInfo.name,
                  description: `Abonnement-Paket: ${packageInfo.name}`
                },
                unit_amount: billingCycle === "yearly" ? Math.round(packageInfo.price * 12 * 0.9) : packageInfo.price,
                // Detaillierte Logging für Preisinformationen
                ...billingCycle === "yearly" ? {
                  description: `J\xE4hrlich: ${packageInfo.price} \xD7 12 \xD7 0.9 = ${Math.round(packageInfo.price * 12 * 0.9)} Cent (Ersparnis von 10%)`
                } : {},
                recurring: {
                  interval
                }
              },
              quantity: 1
            }
          ],
          mode: "subscription",
          success_url: `${baseUrl}/payment/success?session_id={CHECKOUT_SESSION_ID}`,
          cancel_url: `${baseUrl}/subscription-plans`,
          customer_email: user.email,
          client_reference_id: subscriptionId.toString(),
          metadata: {
            subscriptionId: subscriptionId.toString(),
            packageId: packageId.toString(),
            userId: userId.toString(),
            billingCycle
          }
        });
        console.log(`StripeService: Checkout-Session erstellt: ${session2.id}`);
        return session2.url;
      } catch (stripeError) {
        console.error("StripeService: Fehler beim Erstellen der Stripe-Checkout-Session:", stripeError);
        await db.update(subscriptions).set({
          status: "failed",
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq8(subscriptions.id, tempSubscription[0].id));
        console.log(`StripeService: Tempor\xE4res Abonnement ${tempSubscription[0].id} auf 'failed' gesetzt`);
        await db.insert(subscriptionAuditLogs).values({
          userId,
          companyId: user.companyId,
          action: "checkout_failed",
          oldTier: "none",
          newTier: packageInfo.name,
          details: `Stripe-Checkout konnte nicht erstellt werden f\xFCr Paket ${packageInfo.name} (${billingCycle})`
        });
        return null;
      }
    } catch (error) {
      console.error("StripeService: Fehler beim Erstellen des Checkout-Links:", error);
      return null;
    }
  }
};
var stripeService = new StripeService();

// server/subscriptionRoutes.ts
init_permissions();
import { eq as eq10, and as and7, count as count3, sql as sql7 } from "drizzle-orm";

// server/automated-subscription-service.ts
init_db();
init_schema();
import { eq as eq9 } from "drizzle-orm";
async function guaranteedSubscriptionUpdate(userId, tierName, billingCycle) {
  const logBillingCycle = billingCycle === "yearly" ? "yearly" : "monthly";
  console.log(`\u{1F504} [AUTOMATED-UPDATE] Garantiertes Update f\xFCr Benutzer ${userId}, Tier ${tierName}, Zyklus ${logBillingCycle}`);
  console.log(`\u2699\uFE0F [AUTOMATED-UPDATE] Erhaltener billingCycle=${billingCycle}, Typ=${typeof billingCycle}`);
  try {
    const user = await db.query.users.findFirst({
      where: eq9(users.id, userId)
    });
    if (!user) {
      return { success: false, message: "Benutzer nicht gefunden", error: "USER_NOT_FOUND" };
    }
    console.log(`\u{1F464} [AUTOMATED-UPDATE] Benutzer gefunden: ${user.email}`);
    const packageInfo = await db.query.subscriptionPackages.findFirst({
      where: eq9(subscriptionPackages.name, tierName.toLowerCase())
    });
    if (!packageInfo) {
      return { success: false, message: "Paket nicht gefunden", error: "PACKAGE_NOT_FOUND" };
    }
    const packageId = packageInfo.id;
    console.log(`\u{1F4E6} [AUTOMATED-UPDATE] Paket gefunden: ${packageInfo.name} (ID: ${packageId})`);
    const normalizedBillingCycle = billingCycle && billingCycle.toLowerCase() === "yearly" ? "yearly" : "monthly";
    console.log(`\u{1F504} [AUTOMATED-UPDATE] Normalisierter Billing-Zyklus: ${normalizedBillingCycle} (Original: ${billingCycle})`);
    const expirationPeriod = normalizedBillingCycle === "yearly" ? 365 * 24 * 60 * 60 * 1e3 : 30 * 24 * 60 * 60 * 1e3;
    console.log(`\u23F1\uFE0F [AUTOMATED-UPDATE] Expiration basierend auf Zyklus ${normalizedBillingCycle} berechnet: ${expirationPeriod}ms`);
    const expirationDate = tierName.toLowerCase() === "free" ? null : new Date(Date.now() + expirationPeriod);
    console.log(`\u{1F4C5} [AUTOMATED-UPDATE] Ablaufdatum berechnet: ${expirationDate}`);
    const userUpdateResult = await db.update(users).set({
      subscriptionTier: tierName.toLowerCase(),
      subscriptionBillingCycle: normalizedBillingCycle,
      subscriptionExpiresAt: expirationDate,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq9(users.id, userId)).returning();
    console.log(`\u2705 [AUTOMATED-UPDATE] Benutzer aktualisiert:`, userUpdateResult);
    const existingSubscription = await db.query.subscriptions.findFirst({
      where: eq9(subscriptions.userId, userId)
    });
    let subscriptionUpdateResult;
    if (existingSubscription) {
      subscriptionUpdateResult = await db.update(subscriptions).set({
        packageId,
        status: "active",
        billingCycle: normalizedBillingCycle,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq9(subscriptions.id, existingSubscription.id)).returning();
      console.log(`\u2705 [AUTOMATED-UPDATE] Vorhandenes Abonnement aktualisiert:`, subscriptionUpdateResult);
    } else {
      subscriptionUpdateResult = await db.insert(subscriptions).values({
        userId,
        packageId,
        status: "active",
        billingCycle: normalizedBillingCycle,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      console.log(`\u2705 [AUTOMATED-UPDATE] Neues Abonnement erstellt:`, subscriptionUpdateResult);
    }
    if (user.companyId && user.isCompanyAdmin) {
      try {
        console.log(`\u{1F3E2} [AUTOMATED-UPDATE] Benutzer ist Admin der Firma ${user.companyId}, aktualisiere Firmen-Abonnement`);
        await db.update(companyPaymentInfo).set({
          subscriptionTier: tierName.toLowerCase(),
          subscriptionStatus: "active",
          subscriptionStartDate: /* @__PURE__ */ new Date(),
          subscriptionEndDate: expirationDate,
          billingCycle: normalizedBillingCycle,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq9(companyPaymentInfo.companyId, user.companyId));
        console.log(`\u2705 [AUTOMATED-UPDATE] Firmen-Abonnement aktualisiert f\xFCr Firma ${user.companyId}`);
      } catch (companyError) {
        console.error(`\u274C [AUTOMATED-UPDATE] Fehler beim Aktualisieren des Firmen-Abonnements:`, companyError);
      }
    }
    return {
      success: true,
      message: "Abonnement erfolgreich aktualisiert",
      data: {
        user: userUpdateResult[0],
        subscription: subscriptionUpdateResult[0]
      }
    };
  } catch (error) {
    console.error(`\u274C [AUTOMATED-UPDATE] Fehler bei garantiertem Update:`, error);
    return {
      success: false,
      message: "Fehler beim Aktualisieren des Abonnements",
      error
    };
  }
}

// server/subscriptionRoutes.ts
function registerSubscriptionRoutes(app2) {
  app2.get("/api/public/subscription-packages", async (req, res) => {
    try {
      const packages = await db.query.subscriptionPackages.findMany({
        where: and7(
          eq10(subscriptionPackages.isActive, true),
          sql7`(${subscriptionPackages.name} != 'kanbax')`
        )
      });
      const safePackages = packages.map((pkg) => {
        const { stripeProductId, stripePriceId, ...safePackage } = pkg;
        return safePackage;
      });
      res.json(safePackages);
    } catch (error) {
      console.error("Fehler beim Abrufen der \xF6ffentlichen Abonnement-Pakete:", error);
      res.status(500).json({ message: "Fehler beim Abrufen der Abonnement-Pakete" });
    }
  });
  app2.patch("/api/admin/users/:id/subscription", requireHyperAdmin, async (req, res) => {
    try {
      const userId = parseInt(req.params.id);
      const adminUserId = req.session.userId;
      const { tier } = req.body;
      if (!tier) {
        return res.status(400).json({ message: "Keine Abo-Stufe angegeben" });
      }
      const user = await db.query.users.findFirst({
        where: eq10(users.id, userId)
      });
      if (!user) {
        return res.status(404).json({ message: "Benutzer nicht gefunden" });
      }
      const success = await subscriptionService.updateUserSubscriptionTier(userId, tier, adminUserId);
      if (!success) {
        return res.status(500).json({ message: "Fehler beim Aktualisieren des Abonnements" });
      }
      res.json({ message: "Benutzer-Abonnement erfolgreich aktualisiert" });
    } catch (error) {
      console.error("Fehler beim Aktualisieren des Benutzer-Abonnements:", error);
      res.status(500).json({ message: "Fehler beim Aktualisieren des Benutzer-Abonnements" });
    }
  });
  app2.get("/api/subscription/packages", requireAuth, async (req, res) => {
    try {
      const packages = await db.query.subscriptionPackages.findMany({
        where: eq10(subscriptionPackages.isActive, true)
      });
      const safePackages = packages.map((pkg) => {
        const { stripeProductId, stripePriceId, ...safePackage } = pkg;
        return safePackage;
      });
      res.json(safePackages);
    } catch (error) {
      console.error("Fehler beim Abrufen der Abonnement-Pakete:", error);
      res.status(500).json({ message: "Fehler beim Abrufen der Abonnement-Pakete" });
    }
  });
  app2.get("/api/subscription/current", requireAuth, async (req, res) => {
    try {
      const userId = req.session.userId;
      const user = await db.select().from(users).where(eq10(users.id, userId)).limit(1).then((rows) => rows[0]);
      if (!user?.companyId) {
        const userSubscriptionTier = user?.subscriptionTier || "free";
        const packageInfo2 = await db.query.subscriptionPackages.findFirst({
          where: eq10(subscriptionPackages.name, userSubscriptionTier)
        });
        if (!packageInfo2) {
          return res.status(500).json({ message: `Paket ${userSubscriptionTier} nicht gefunden` });
        }
        const result = await db.execute(sql7`
          SELECT subscription_billing_cycle 
          FROM users 
          WHERE id = ${user.id}
        `);
        const actualBillingCycle = result.rows[0]?.subscription_billing_cycle || "monthly";
        const response2 = {
          companyId: null,
          subscriptionTier: userSubscriptionTier,
          subscriptionBillingCycle: actualBillingCycle,
          subscriptionStatus: "active",
          subscriptionStartDate: (/* @__PURE__ */ new Date()).toISOString(),
          subscriptionEndDate: user?.subscriptionExpiresAt || null,
          packageInfo: {
            displayName: packageInfo2.displayName,
            description: packageInfo2.description,
            price: packageInfo2.price,
            features: {
              maxProjects: packageInfo2.maxProjects,
              maxBoards: packageInfo2.maxBoards,
              maxTeams: packageInfo2.maxTeams,
              maxUsersPerCompany: packageInfo2.maxUsersPerCompany,
              hasGanttView: packageInfo2.hasGanttView,
              hasAdvancedReporting: packageInfo2.hasAdvancedReporting,
              hasApiAccess: packageInfo2.hasApiAccess,
              hasCustomBranding: packageInfo2.hasCustomBranding,
              hasPrioritySupport: packageInfo2.hasPrioritySupport
            }
          }
        };
        console.log("[SUBSCRIPTION DEBUG] Final response:", JSON.stringify(response2, null, 2));
        return res.json(response2);
      }
      const hasAccess = await permissionService.canAccessCompany(userId, user.companyId);
      if (!hasAccess) {
        return res.status(403).json({ message: "Keine Berechtigung f\xFCr den Zugriff auf diese Firma" });
      }
      const company = await db.query.companies.findFirst({
        where: eq10(companies.id, user.companyId)
      });
      if (!company) {
        return res.status(404).json({ message: "Unternehmen nicht gefunden" });
      }
      const subscription = await db.query.companyPaymentInfo.findFirst({
        where: eq10(companyPaymentInfo.companyId, user.companyId)
      });
      const subscriptionTier = subscription?.subscriptionTier || "organisation";
      const packageInfo = await db.query.subscriptionPackages.findFirst({
        where: eq10(subscriptionPackages.name, subscriptionTier)
      });
      const response = {
        companyId: user.companyId,
        subscriptionTier,
        subscriptionStatus: subscription?.subscriptionStatus || "active",
        subscriptionStartDate: subscription?.subscriptionStartDate || /* @__PURE__ */ new Date(),
        subscriptionEndDate: subscription?.subscriptionEndDate || null,
        subscriptionBillingCycle: user.subscriptionBillingCycle || "monthly",
        packageInfo: packageInfo ? {
          displayName: packageInfo.displayName,
          description: packageInfo.description,
          price: packageInfo.price,
          features: {
            maxProjects: packageInfo.maxProjects,
            maxBoards: packageInfo.maxBoards,
            maxTeams: packageInfo.maxTeams,
            maxUsersPerCompany: packageInfo.maxUsersPerCompany,
            hasGanttView: packageInfo.hasGanttView,
            hasAdvancedReporting: packageInfo.hasAdvancedReporting,
            hasApiAccess: packageInfo.hasApiAccess,
            hasCustomBranding: packageInfo.hasCustomBranding,
            hasPrioritySupport: packageInfo.hasPrioritySupport
          }
        } : null
      };
      res.json(response);
    } catch (error) {
      console.error("Fehler beim Abrufen der Abonnement-Informationen:", error);
      res.status(500).json({ message: "Fehler beim Abrufen der Abonnement-Informationen" });
    }
  });
  app2.post("/api/internal/update-subscription", async (req, res) => {
    try {
      const { userId, tier, billingCycle = "monthly", apiKey } = req.body;
      const validApiKey = process.env.INTERNAL_API_KEY || "local_development_key";
      if (apiKey !== validApiKey) {
        return res.status(403).json({
          success: false,
          message: "Ung\xFCltiger API-Key"
        });
      }
      if (!userId || !tier) {
        return res.status(400).json({
          success: false,
          message: "Fehlende erforderliche Parameter (userId und tier werden ben\xF6tigt)"
        });
      }
      console.log(`[INTERNAL UPDATE] Starte interne Aktualisierung f\xFCr Benutzer ${userId}, Tier: ${tier}, Zyklus: ${billingCycle}`);
      console.log(`[INTERNAL UPDATE] Explicit billingCycle=${billingCycle} - ensuring correct cycle is passed to update service`);
      const result = await guaranteedSubscriptionUpdate(userId, tier, billingCycle);
      if (result.success) {
        console.log(`[INTERNAL UPDATE] \u2705 Interne Aktualisierung erfolgreich f\xFCr ${userId}`);
        return res.json({
          success: true,
          message: "Abonnement erfolgreich aktualisiert via internen Endpunkt",
          data: result.data
        });
      } else {
        console.error(`[INTERNAL UPDATE] \u274C Fehler bei interner Aktualisierung:`, result.error);
        return res.status(500).json({
          success: false,
          message: "Fehler bei interner Aktualisierung",
          error: result.message
        });
      }
    } catch (error) {
      console.error(`[INTERNAL UPDATE] \u274C Unerwarteter Fehler:`, error);
      return res.status(500).json({
        success: false,
        message: "Unerwarteter Fehler bei interner Aktualisierung",
        error: String(error)
      });
    }
  });
  app2.post("/api/subscription/guaranteed-update", requireAuth, async (req, res) => {
    try {
      const userId = req.session.userId;
      const { tier, billingCycle = "monthly" } = req.body;
      console.log(`[GUARANTEED UPDATE] Starte garantierte Aktualisierung f\xFCr Benutzer ${userId}, Tier: ${tier}, Zyklus: ${billingCycle}`);
      if (!tier) {
        return res.status(400).json({ message: "Keine Abonnement-Stufe angegeben" });
      }
      console.log(`[GUARANTEED UPDATE] Explicit billingCycle=${billingCycle} - ensuring correct cycle is passed to update service`);
      const result = await guaranteedSubscriptionUpdate(userId, tier, billingCycle);
      if (result.success) {
        console.log(`[GUARANTEED UPDATE] \u2705 Garantierte Aktualisierung erfolgreich abgeschlossen f\xFCr ${userId}`);
        return res.json({
          success: true,
          message: "Abonnement garantiert aktualisiert",
          data: result.data
        });
      } else {
        console.error(`[GUARANTEED UPDATE] \u274C Garantierte Aktualisierung fehlgeschlagen:`, result.error);
        return res.status(500).json({
          success: false,
          message: "Fehler bei garantierter Aktualisierung",
          error: result.message
        });
      }
    } catch (error) {
      console.error(`[GUARANTEED UPDATE] \u274C Unerwarteter Fehler:`, error);
      return res.status(500).json({
        success: false,
        message: "Unerwarteter Fehler bei der Aktualisierung",
        error: String(error)
      });
    }
  });
  app2.post("/api/subscription/update-user", requireAuth, async (req, res) => {
    try {
      const userId = req.session.userId;
      const { tier, billingCycle = "monthly", forceDowngrade = false } = req.body;
      console.log(`[SUBSCRIPTION DEBUG] Abonnement\xE4nderung angefordert f\xFCr Benutzer ${userId}, Tier: ${tier}, Zyklus: ${billingCycle}, forceDowngrade=${forceDowngrade}`);
      if (forceDowngrade === true) {
        console.log(`[SUBSCRIPTION AUTO] Automatisches Update mit forceDowngrade=true wird durchgef\xFChrt`);
        try {
          const getPackageId = (tierName) => {
            switch (tierName.toLowerCase()) {
              case "free":
                return 1;
              case "freelancer":
                return 2;
              case "organisation":
                return 3;
              case "enterprise":
                return 4;
              case "kanbax":
                return 5;
              default:
                return 2;
            }
          };
          const directUpdateResponse = await fetch(`http://localhost:${process.env.PORT || 5e3}/api/payments/direct-update`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              userId,
              packageId: getPackageId(tier),
              billingCycle,
              sessionId: `auto_update_${Date.now()}`,
              forceDowngrade: true
            })
          });
          if (directUpdateResponse.ok) {
            const updateResult = await directUpdateResponse.json();
            console.log(`[SUBSCRIPTION AUTO] \u2705 Direktes Update erfolgreich:`, updateResult);
            return res.status(200).json({
              success: true,
              message: "Abonnement erfolgreich aktualisiert \xFCber direktes Update",
              tier,
              billingCycle,
              ...updateResult
            });
          } else {
            console.error(`[SUBSCRIPTION AUTO] \u274C Direktes Update fehlgeschlagen, Status:`, directUpdateResponse.status);
          }
        } catch (directError) {
          console.error(`[SUBSCRIPTION AUTO] \u274C Fehler beim direkten Update:`, directError);
        }
      }
      if (!tier) {
        return res.status(400).json({ message: "Keine Abonnement-Stufe angegeben" });
      }
      const packageExists = await db.query.subscriptionPackages.findFirst({
        where: and7(
          eq10(subscriptionPackages.name, tier),
          eq10(subscriptionPackages.isActive, true)
        )
      });
      if (!packageExists) {
        return res.status(400).json({ message: "Ung\xFCltige Abonnement-Stufe" });
      }
      const user = await db.query.users.findFirst({
        where: eq10(users.id, userId)
      });
      if (!user) {
        return res.status(404).json({ message: "Benutzer nicht gefunden" });
      }
      const result = await stripeService.switchSubscription(userId, tier, billingCycle);
      if (!result.success) {
        console.error(`Fehler beim Erstellen des Checkout-Links f\xFCr Benutzer ${userId}`);
        return res.status(500).json({
          message: "Fehler beim Erstellen des Zahlungslinks f\xFCr das Abonnement",
          error: "Stripe-Integration fehlgeschlagen"
        });
      }
      console.log(`Checkout-Prozess initiiert f\xFCr Benutzer ${userId}`);
      if (result.checkoutUrl) {
        console.log(`Checkout-URL erstellt f\xFCr Benutzer ${userId}: ${result.checkoutUrl}`);
        return res.json({
          success: true,
          message: "Bitte schlie\xDFen Sie den Zahlungsvorgang bei Stripe ab",
          checkoutUrl: result.checkoutUrl,
          requiresPayment: true
        });
      } else {
        console.log(`Nur Datenbank f\xFCr Benutzer ${userId} aktualisiert, ohne Stripe-Integration`);
        try {
          const normalizedBillingCycle = billingCycle === "yearly" ? "yearly" : "monthly";
          const expirationPeriod = normalizedBillingCycle === "yearly" ? 365 * 24 * 60 * 60 * 1e3 : 30 * 24 * 60 * 60 * 1e3;
          const expirationDate = tier.toLowerCase() === "free" ? null : new Date(Date.now() + expirationPeriod);
          console.log(`[DIRECT-USER-UPDATE] Aktualisiere Benutzer ${userId} auf Tier ${tier.toLowerCase()} mit Ablaufdatum: ${expirationDate}`);
          await db.update(users).set({
            subscriptionTier: tier.toLowerCase(),
            subscriptionBillingCycle: normalizedBillingCycle,
            subscriptionExpiresAt: expirationDate,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq10(users.id, userId));
          console.log(`[DIRECT-USER-UPDATE] Benutzer ${userId} erfolgreich aktualisiert`);
        } catch (userUpdateError) {
          console.error(`[DIRECT-USER-UPDATE] Fehler beim Aktualisieren des Benutzers ${userId}:`, userUpdateError);
        }
        if (user.companyId && user.isCompanyAdmin) {
          const success = await subscriptionService.updateSubscription(user.companyId, tier, userId, billingCycle);
          if (!success) {
            return res.status(500).json({ message: "Fehler beim Aktualisieren des Firmen-Abonnements" });
          }
          console.log(`\u2713 [BILLING_CYCLE] Update f\xFCr Firma ${user.companyId}: Zyklus gesetzt auf ${billingCycle}`);
          return res.json({
            success: true,
            message: "Firmen-Abonnement erfolgreich aktualisiert",
            requiresPayment: false
          });
        } else {
          const success = await subscriptionService.updateUserSubscriptionTier(userId, tier, userId, billingCycle);
          if (!success) {
            return res.status(500).json({ message: "Fehler beim Aktualisieren des Benutzer-Abonnements" });
          }
          console.log(`\u2713 [BILLING_CYCLE] Update f\xFCr Benutzer ${userId}: Zyklus gesetzt auf ${billingCycle}`);
          return res.json({
            success: true,
            message: "Benutzer-Abonnement erfolgreich aktualisiert",
            requiresPayment: false
          });
        }
      }
    } catch (error) {
      console.error("Fehler beim Aktualisieren des Abonnements:", error);
      res.status(500).json({ message: "Fehler beim Aktualisieren des Abonnements" });
    }
  });
  app2.post("/api/subscription/update", requireCompanyAdmin, async (req, res) => {
    try {
      const userId = req.session.userId;
      const user = await db.query.users.findFirst({ where: eq10(users.id, userId) });
      if (!user?.companyId) {
        return res.status(400).json({ message: "Benutzer ist keinem Unternehmen zugeordnet" });
      }
      const { tier } = req.body;
      if (!tier) {
        return res.status(400).json({ message: "Keine Abo-Stufe angegeben" });
      }
      const packageExists = await db.query.subscriptionPackages.findFirst({
        where: and7(
          eq10(subscriptionPackages.name, tier),
          eq10(subscriptionPackages.isActive, true)
        )
      });
      if (!packageExists) {
        return res.status(400).json({ message: "Ung\xFCltige Abo-Stufe" });
      }
      const billingCycle = req.body.billingCycle || "monthly";
      const success = await subscriptionService.updateSubscription(user.companyId, tier, userId, billingCycle);
      if (!success) {
        return res.status(500).json({ message: "Fehler beim Aktualisieren des Abonnements" });
      }
      res.json({ message: "Abonnement erfolgreich aktualisiert" });
    } catch (error) {
      console.error("Fehler beim Aktualisieren des Abonnements:", error);
      res.status(500).json({ message: "Fehler beim Aktualisieren des Abonnements" });
    }
  });
  app2.get("/api/subscription/check-limit/:limitType", requireAuth, async (req, res) => {
    try {
      const userId = req.session.userId;
      const user = await db.query.users.findFirst({ where: eq10(users.id, userId) });
      console.log(`DEBUG Limit-Check: Benutzer ${userId} pr\xFCft Limit f\xFCr ${req.params.limitType}`);
      console.log(`DEBUG Limit-Check: Benutzer Daten:`, user);
      let hasReachedLimit = false;
      const limitType = req.params.limitType;
      if (user?.companyId) {
        switch (limitType) {
          case "projects":
            hasReachedLimit = await subscriptionService.hasReachedProjectLimit(user.companyId);
            break;
          case "boards":
            hasReachedLimit = await subscriptionService.hasReachedBoardLimit(user.companyId);
            break;
          case "teams":
            hasReachedLimit = await subscriptionService.hasReachedTeamLimit(user.companyId);
            break;
          case "users":
            hasReachedLimit = await subscriptionService.hasReachedUserLimit(user.companyId);
            break;
          default:
            return res.status(400).json({ message: "Ung\xFCltiger Limit-Typ" });
        }
      } else {
        const subscriptionTier = user?.subscriptionTier || "free";
        const packageInfo = await db.query.subscriptionPackages.findFirst({
          where: eq10(subscriptionPackages.name, subscriptionTier)
        });
        if (!packageInfo) {
          return res.status(500).json({ message: "Fehler: Paketinformationen nicht gefunden" });
        }
        console.log(`DEBUG Limit-Check: Benutzer ${userId} hat Paket ${subscriptionTier} mit folgenden Limits:`, {
          maxProjects: packageInfo.maxProjects,
          maxBoards: packageInfo.maxBoards,
          maxTeams: packageInfo.maxTeams,
          maxTasks: packageInfo.maxTasks
        });
        if (limitType === "boards") {
          const boardCountResult = await db.execute(
            sql7`SELECT COUNT(*) as count FROM boards WHERE creator_id = ${userId} AND archived = false`
          );
          const boardCount = parseInt(String(boardCountResult.rows[0]?.count) || "0");
          console.log(`DEBUG Limit-Check: Benutzer ${userId} hat ${boardCount} pers\xF6nliche Boards`);
          const maxBoards = packageInfo.maxBoards || 0;
          hasReachedLimit = boardCount >= maxBoards;
          console.log(`DEBUG Limit-Check: Limit erreicht? ${hasReachedLimit} (${boardCount}/${maxBoards})`);
        } else if (limitType === "projects") {
          const projectCountResult = await db.execute(
            sql7`SELECT COUNT(*) as count FROM projects WHERE creator_id = ${userId} AND archived = false`
          );
          const projectCount = parseInt(String(projectCountResult.rows[0]?.count) || "0");
          console.log(`DEBUG Limit-Check: Benutzer ${userId} hat ${projectCount} pers\xF6nliche Projekte`);
          const maxProjects = packageInfo.maxProjects || 0;
          hasReachedLimit = projectCount >= maxProjects;
          console.log(`DEBUG Limit-Check: Projekt-Limit erreicht? ${hasReachedLimit} (${projectCount}/${maxProjects})`);
        } else if (limitType === "tasks") {
          const taskCountResult = await db.execute(
            sql7`SELECT COUNT(*) as count FROM tasks WHERE assigned_user_ids && ARRAY[${userId}]`
          );
          const taskCount = parseInt(String(taskCountResult.rows[0]?.count) || "0");
          console.log(`DEBUG Limit-Check: Benutzer ${userId} hat ${taskCount} pers\xF6nliche Aufgaben`);
          const maxTasks = packageInfo.maxTasks || 0;
          hasReachedLimit = taskCount >= maxTasks;
          console.log(`DEBUG Limit-Check: Aufgaben-Limit erreicht? ${hasReachedLimit} (${taskCount}/${maxTasks})`);
        } else {
          console.log(`DEBUG Limit-Check: F\xFCr Einzelnutzer ohne Firma nicht relevant: ${limitType}`);
        }
      }
      console.log(`DEBUG Limit-Check: Antwort -> hasReachedLimit = ${hasReachedLimit}`);
      res.json({ hasReachedLimit });
    } catch (error) {
      console.error(`Fehler beim Pr\xFCfen des Limits (${req.params.limitType}):`, error);
      res.status(500).json({ message: "Fehler beim Pr\xFCfen des Limits" });
    }
  });
  app2.get("/api/subscription/check-feature/:featureName", requireAuth, async (req, res) => {
    try {
      const userId = req.session.userId;
      const user = await db.query.users.findFirst({ where: eq10(users.id, userId) });
      if (!user?.companyId) {
        const userSubscriptionTier = user?.subscriptionTier || "free";
        const packageInfo = await db.query.subscriptionPackages.findFirst({
          where: eq10(subscriptionPackages.name, userSubscriptionTier)
        });
        if (!packageInfo) {
          return res.status(500).json({ message: "Fehler: Paketinformationen nicht gefunden" });
        }
        const featureName2 = req.params.featureName;
        let hasAccess2 = false;
        switch (featureName2) {
          case "gantt_view":
            hasAccess2 = packageInfo.hasGanttView ?? false;
            break;
          case "advanced_reporting":
            hasAccess2 = packageInfo.hasAdvancedReporting ?? false;
            break;
          case "api_access":
            hasAccess2 = packageInfo.hasApiAccess ?? false;
            break;
          case "custom_branding":
            hasAccess2 = packageInfo.hasCustomBranding ?? false;
            break;
          case "priority_support":
            hasAccess2 = packageInfo.hasPrioritySupport ?? false;
            break;
          default:
            return res.status(400).json({ message: "Ung\xFCltiger Feature-Typ" });
        }
        return res.json({ hasAccess: hasAccess2 });
      }
      const featureName = req.params.featureName;
      const hasAccess = await subscriptionService.hasFeatureAccess(user.companyId, featureName);
      res.json({ hasAccess });
    } catch (error) {
      console.error(`Fehler beim Pr\xFCfen des Features (${req.params.featureName}):`, error);
      res.status(500).json({ message: "Fehler beim Pr\xFCfen des Features" });
    }
  });
  app2.get("/api/subscription/usage", requireAuth, async (req, res) => {
    try {
      const userId = req.session.userId;
      const user = await db.query.users.findFirst({ where: eq10(users.id, userId) });
      if (!user?.companyId) {
        const boardCountResult = await db.execute(
          sql7`SELECT COUNT(*) as count FROM boards 
              WHERE creator_id = ${userId} 
              AND archived = false`
        );
        const boardCount2 = parseInt(String(boardCountResult.rows[0]?.count) || "0");
        const projectCountResult2 = await db.execute(
          sql7`SELECT COUNT(*) as count FROM projects 
              WHERE creator_id = ${userId} 
              AND archived = false`
        );
        const projectCount2 = parseInt(String(projectCountResult2.rows[0]?.count) || "0");
        const teamCount2 = 0;
        const userCount2 = 1;
        return res.json({
          projectCount: projectCount2,
          boardCount: boardCount2,
          teamCount: teamCount2,
          userCount: userCount2
        });
      }
      const projectCountResult = await db.select({ count: count3() }).from(projects).where(eq10(projects.companyId, user.companyId));
      const projectCount = projectCountResult[0]?.count || 0;
      const companyUsers = await db.query.users.findMany({
        where: eq10(users.companyId, user.companyId)
      });
      const userIds = companyUsers.map((u) => u.id);
      let boardCount = 0;
      if (userIds.length > 0) {
        const userIdsStr = userIds.join(",");
        const boardCountResult = await db.execute(
          sql7`SELECT COUNT(*) as count FROM boards 
              WHERE creator_id IN (${sql7.raw(userIdsStr)}) 
              AND archived = false`
        );
        boardCount = parseInt(String(boardCountResult.rows[0]?.count) || "0");
      }
      const teamCountResult = await db.select({ count: count3() }).from(teams).where(eq10(teams.companyId, user.companyId));
      const teamCount = teamCountResult[0]?.count || 0;
      const userCountResult = await db.select({ count: count3() }).from(users).where(and7(
        eq10(users.companyId, user.companyId),
        eq10(users.isActive, true)
      ));
      const userCount = userCountResult[0]?.count || 0;
      res.json({
        projectCount,
        boardCount,
        teamCount,
        userCount
      });
    } catch (error) {
      console.error("Fehler beim Abrufen der Nutzungsdaten:", error);
      res.status(500).json({ message: "Fehler beim Abrufen der Nutzungsdaten" });
    }
  });
  app2.get("/api/admin/subscriptions", requireHyperAdmin, async (req, res) => {
    try {
      const subscriptions3 = await db.query.companyPaymentInfo.findMany();
      const enrichedSubscriptions = await Promise.all(
        subscriptions3.map(async (subscription) => {
          if (subscription.companyId) {
            const company = await db.query.companies.findFirst({
              where: eq10(companies.id, subscription.companyId)
            });
            return {
              ...subscription,
              companyName: company?.name || "Unbekannte Firma"
            };
          }
          return {
            ...subscription,
            companyName: "Unbekannte Firma"
          };
        })
      );
      res.json(enrichedSubscriptions);
    } catch (error) {
      console.error("Fehler beim Abrufen der Abonnements:", error);
      res.status(500).json({ message: "Fehler beim Abrufen der Abonnements" });
    }
  });
  app2.get("/api/admin/subscription-packages", requireHyperAdmin, async (req, res) => {
    try {
      const packages = await db.query.subscriptionPackages.findMany();
      res.json(packages);
    } catch (error) {
      console.error("Fehler beim Abrufen der Abonnement-Pakete:", error);
      res.status(500).json({ message: "Fehler beim Abrufen der Abonnement-Pakete" });
    }
  });
  app2.patch("/api/admin/subscription-packages/:id", requireHyperAdmin, async (req, res) => {
    try {
      const packageId = parseInt(req.params.id);
      const packageData = req.body;
      const { name, createdAt, updatedAt, ...updateData } = packageData;
      await db.update(subscriptionPackages).set({
        ...updateData,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq10(subscriptionPackages.id, packageId));
      res.json({ message: "Abonnement-Paket erfolgreich aktualisiert" });
    } catch (error) {
      console.error("Fehler beim Aktualisieren des Abonnement-Pakets:", error);
      res.status(500).json({ message: "Fehler beim Aktualisieren des Abonnement-Pakets" });
    }
  });
  app2.patch("/api/admin/company-subscription/:companyId", requireHyperAdmin, async (req, res) => {
    try {
      const companyId = parseInt(req.params.companyId);
      const userId = req.session.userId;
      const { tier } = req.body;
      if (!tier) {
        return res.status(400).json({ message: "Keine Abo-Stufe angegeben" });
      }
      const packageExists = await db.query.subscriptionPackages.findFirst({
        where: eq10(subscriptionPackages.name, tier)
      });
      if (!packageExists) {
        return res.status(400).json({ message: "Ung\xFCltige Abo-Stufe" });
      }
      const success = await subscriptionService.updateSubscription(companyId, tier, userId);
      if (!success) {
        return res.status(500).json({ message: "Fehler beim Aktualisieren des Abonnements" });
      }
      await db.insert(subscriptionAuditLogs).values({
        companyId,
        userId,
        action: "admin_change",
        newTier: tier,
        details: "Abonnement manuell vom Admin ge\xE4ndert"
      });
      res.json({ message: "Abonnement erfolgreich aktualisiert" });
    } catch (error) {
      console.error("Fehler beim Aktualisieren des Abonnements:", error);
      res.status(500).json({ message: "Fehler beim Aktualisieren des Abonnements" });
    }
  });
  app2.get("/api/admin/subscription-audit/:companyId", requireHyperAdmin, async (req, res) => {
    try {
      const companyId = parseInt(req.params.companyId);
      const auditLogs = await db.select({
        id: subscriptionAuditLogs.id,
        companyId: subscriptionAuditLogs.companyId,
        userId: subscriptionAuditLogs.userId,
        changedByUserId: subscriptionAuditLogs.changedByUserId,
        action: subscriptionAuditLogs.action,
        oldTier: subscriptionAuditLogs.oldTier,
        newTier: subscriptionAuditLogs.newTier,
        details: subscriptionAuditLogs.details,
        stripeEventId: subscriptionAuditLogs.stripeEventId,
        createdAt: subscriptionAuditLogs.createdAt
      }).from(subscriptionAuditLogs).where(eq10(subscriptionAuditLogs.companyId, companyId)).orderBy(sql7`${subscriptionAuditLogs.createdAt} DESC`);
      res.json(auditLogs);
    } catch (error) {
      console.error("Fehler beim Abrufen des Audit-Logs:", error);
      res.status(500).json({ message: "Fehler beim Abrufen des Audit-Logs" });
    }
  });
}
async function initializeSubscriptionPackages() {
  try {
    const existingPackages = await db.query.subscriptionPackages.findMany();
    if (existingPackages.length === 0) {
      console.log("Initialisiere Standard-Abonnement-Pakete...");
      const defaultPackages = subscriptionService.getDefaultPackagesForDb();
      for (const pkg of defaultPackages) {
        await db.insert(subscriptionPackages).values({
          ...pkg,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        });
      }
      console.log("Standard-Abonnement-Pakete erfolgreich initialisiert.");
    }
  } catch (error) {
    console.error("Fehler bei der Initialisierung der Standard-Abonnement-Pakete:", error);
  }
}

// server/paymentRoutes.ts
init_db();
init_schema();
import Stripe2 from "stripe";
import { eq as eq11, desc as desc5 } from "drizzle-orm";
var secretKeyToUse2 = process.env.STRIPE_SECRET_KEY;
if (!secretKeyToUse2) {
  throw new Error("STRIPE_SECRET_KEY Umgebungsvariable ist erforderlich");
}
console.log("Stripe Secret Key aus Umgebungsvariable verwenden");
var stripe2 = new Stripe2(secretKeyToUse2, {
  apiVersion: "2025-02-24.acacia"
  // Aktualisierte API-Version von Stripe
});
var BASE_URL = process.env.REQUEST_URL || "https://0fe82899-989d-49e3-8509-b9664bfb91a4.id.replit.app";
function getDynamicBaseUrl(req) {
  const host = req.get("X-Forwarded-Host") || req.get("Host");
  if (host) {
    const protocol = req.protocol || "https";
    return `${protocol}://${host}`;
  }
  return BASE_URL;
}
function getTierRank(tier) {
  switch (tier.toLowerCase()) {
    case "free":
      return 0;
    case "freelancer":
      return 1;
    case "organisation":
      return 2;
    case "enterprise":
      return 3;
    case "kanbax":
      return 4;
    default:
      return -1;
  }
}
function registerPaymentRoutes(app2) {
  app2.get("/api/payments/config", (req, res) => {
    const publishableKey = process.env.STRIPE_PUBLISHABLE_KEY || "pk_test_placeholder_for_development";
    return res.json({ publishableKey });
  });
  app2.post("/api/payments/create-checkout", async (req, res) => {
    try {
      const { subscriptionId, packageId, userId, billingCycle } = req.body;
      const interval = billingCycle === "yearly" ? "year" : "month";
      console.log(`Erzeugen eines Stripe Checkout f\xFCr Paket mit Abrechnungszyklus ${billingCycle} (Interval: ${interval})`);
      if (!packageId || !userId) {
        return res.status(400).json({ message: "Fehlende Paket-ID oder Benutzer-ID f\xFCr die Checkout-Session" });
      }
      const isTemporarySubscription = subscriptionId === -1;
      if (isTemporarySubscription) {
        console.log("Tempor\xE4re Subscription-ID (-1) erkannt. Fortfahren mit tempor\xE4rer ID f\xFCr Freelancer.");
      } else if (!subscriptionId) {
        return res.status(400).json({ message: "Fehlende Subscription-ID f\xFCr die Checkout-Session" });
      }
      console.log("Checkout-Anfrage erhalten:", { subscriptionId, packageId, userId });
      const dynamicBaseUrl = getDynamicBaseUrl(req);
      console.log("Verwendete Basis-URL f\xFCr Stripe:", dynamicBaseUrl);
      const packageInfo = await db.select().from(subscriptionPackages).where(eq11(subscriptionPackages.id, packageId)).limit(1);
      if (!packageInfo || packageInfo.length === 0) {
        console.error("Abonnement-Paket nicht gefunden:", packageId);
        return res.status(404).json({ message: "Abonnement-Paket nicht gefunden" });
      }
      console.log("Paket gefunden:", packageInfo[0]);
      const userInfo = await db.select().from(users).where(eq11(users.id, userId)).limit(1);
      if (!userInfo || userInfo.length === 0) {
        console.error("Benutzer nicht gefunden:", userId);
        return res.status(404).json({ message: "Benutzer nicht gefunden" });
      }
      console.log("Benutzer gefunden:", { id: userInfo[0].id, email: userInfo[0].email });
      let calculatedPrice = packageInfo[0].price;
      if (interval === "year") {
        calculatedPrice = Math.round(packageInfo[0].price * 12 * 0.9);
        console.log(`Preisberechnung f\xFCr j\xE4hrliches Abonnement: ${packageInfo[0].price} \xD7 12 \xD7 0.9 = ${calculatedPrice} Cent`);
      }
      const session2 = await stripe2.checkout.sessions.create({
        payment_method_types: ["card"],
        line_items: [
          {
            price_data: {
              currency: "eur",
              product_data: {
                name: packageInfo[0].displayName || packageInfo[0].name,
                description: `Abonnement-Paket: ${packageInfo[0].name}`
              },
              unit_amount: interval === "year" ? Math.round(packageInfo[0].price * 12 * 0.9) : (
                // Jahrespreis mit 10% Rabatt
                packageInfo[0].price
              ),
              // Monatlicher Preis bleibt unverändert
              recurring: {
                // Verwende den vom Client angegebenen Abrechnungszeitraum
                interval
                // Kann 'month' oder 'year' sein
              }
            },
            quantity: 1
          }
        ],
        mode: "subscription",
        // Für die success_url verwenden wir die dynamisch ermittelte Basis-URL
        success_url: `${dynamicBaseUrl}/payment/success?session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${dynamicBaseUrl}/auth`,
        customer_email: userInfo[0].email,
        client_reference_id: subscriptionId.toString(),
        metadata: {
          subscriptionId,
          packageId,
          userId,
          billingCycle
          // Speichere auch den Abrechnungszyklus in den Metadaten
        }
      });
      return res.status(200).json({ checkoutUrl: session2.url });
    } catch (error) {
      console.error("Fehler bei der Erstellung der Checkout-Session:", error);
      return res.status(500).json({ message: "Fehler bei der Erstellung der Checkout-Session" });
    }
  });
  app2.post("/api/payments/webhook", async (req, res) => {
    const sig = req.headers["stripe-signature"];
    if (!sig) {
      console.error("\u274C Webhook: Keine Stripe-Signatur in den Headers gefunden");
      return res.status(400).json({ message: "Keine Stripe-Signatur gefunden" });
    }
    const stripeWebhookSecret = process.env.STRIPE_WEBHOOK_SECRET || "whsec_placeholder_for_development";
    let event;
    try {
      console.log(`\u{1F4E8} Webhook: Rohdaten empfangen, L\xE4nge: ${req.body?.length || "keine Daten"}`);
      event = stripe2.webhooks.constructEvent(
        req.body,
        sig,
        stripeWebhookSecret
      );
      console.log(`\u2705 Webhook: Signatur erfolgreich verifiziert f\xFCr Event ${event.id}`);
    } catch (err) {
      console.error("\u274C Webhook: Fehler bei der Signaturpr\xFCfung:", err);
      return res.status(400).json({ message: "Ung\xFCltige Signatur" });
    }
    console.log(`\u26A1 STRIPE WEBHOOK: Event-Typ ${event.type} empfangen (ID: ${event.id})`);
    switch (event.type) {
      case "checkout.session.completed": {
        const session2 = event.data.object;
        console.log(`\u{1F4B0} CHECKOUT COMPLETED - Session: ${JSON.stringify(session2, null, 2)}`);
        const subscriptionId = session2.metadata?.subscriptionId;
        const packageId = session2.metadata?.packageId;
        const userId = session2.metadata?.userId;
        const rawBillingCycle = session2.metadata?.billingCycle || "monthly";
        const billingCycle = rawBillingCycle && rawBillingCycle.toLowerCase() === "yearly" ? "yearly" : "monthly";
        console.log(`\u{1F504} Normalisierter Billing-Zyklus: ${billingCycle} (Original: ${rawBillingCycle})`);
        if (!packageId || !userId) {
          console.error("Fehlende Package-ID oder User-ID in der Session:", session2);
          return res.status(400).json({ message: "Fehlende Paket- oder Benutzer-Metadaten in der Session" });
        }
        const isTemporarySubscription = subscriptionId === "-1";
        let finalSubscriptionId = subscriptionId;
        if (isTemporarySubscription) {
          console.log("Tempor\xE4re Subscription-ID (-1) im Webhook erkannt. Erstelle neue Subscription f\xFCr den Benutzer.");
          try {
            const newSubscriptionResult = await db.insert(subscriptions).values({
              userId: parseInt(userId),
              packageId: parseInt(packageId),
              status: "active",
              stripeCustomerId: session2.customer,
              stripeSubscriptionId: session2.subscription,
              billingCycle,
              // Abrechnungszyklus wurde bereits normalisiert
              createdAt: /* @__PURE__ */ new Date(),
              updatedAt: /* @__PURE__ */ new Date()
            }).returning();
            if (newSubscriptionResult && newSubscriptionResult.length > 0) {
              finalSubscriptionId = newSubscriptionResult[0].id.toString();
              console.log("Neue Subscription erstellt mit ID:", finalSubscriptionId);
            } else {
              console.error("Subscription konnte nicht erstellt werden.");
            }
          } catch (dbError) {
            console.error("Fehler beim Erstellen der Subscription:", dbError);
          }
        } else if (!finalSubscriptionId) {
          console.error("Keine Subscription-ID in der Session:", session2);
          return res.status(400).json({ message: "Fehlende Subscription-ID in der Session" });
        }
        let expirationPeriod = 30 * 24 * 60 * 60 * 1e3;
        if (billingCycle === "yearly") {
          console.log("J\xE4hrliches Abonnement erkannt, setze Ablaufzeit auf 365 Tage");
          expirationPeriod = 365 * 24 * 60 * 60 * 1e3;
        } else {
          console.log("Monatliches Abonnement erkannt, setze Ablaufzeit auf 30 Tage");
        }
        const packageDetails = await db.select().from(subscriptionPackages).where(eq11(subscriptionPackages.id, parseInt(packageId))).limit(1);
        if (!packageDetails || packageDetails.length === 0) {
          console.error("Paket nicht gefunden f\xFCr ID:", packageId);
          return res.status(404).json({ message: "Paket nicht gefunden" });
        }
        const packageTier = packageDetails[0].name.toLowerCase();
        console.log(`\u26A1 Setze Subscription-Tier des Benutzers #${userId} auf: ${packageTier}`);
        const userBefore = await db.select().from(users).where(eq11(users.id, parseInt(userId))).limit(1);
        if (userBefore && userBefore.length > 0) {
          console.log(`\u{1F464} Aktueller Benutzer-Status vor Update:`, {
            id: userBefore[0].id,
            email: userBefore[0].email,
            subscriptionTier: userBefore[0].subscriptionTier,
            subscriptionBillingCycle: userBefore[0].subscriptionBillingCycle,
            subscriptionExpiresAt: userBefore[0].subscriptionExpiresAt
          });
        }
        const userUpdateResult = await db.update(users).set({
          isActive: true,
          subscriptionTier: packageTier,
          // Hier setzen wir den Tier-Wert des Benutzers
          subscriptionBillingCycle: billingCycle,
          // Bereits normalisiert
          subscriptionExpiresAt: new Date(Date.now() + expirationPeriod)
        }).where(eq11(users.id, parseInt(userId))).returning();
        console.log(`\u2705 Benutzer ${userId} aktualisiert:`, userUpdateResult);
        const userAfter = await db.select().from(users).where(eq11(users.id, parseInt(userId))).limit(1);
        if (userAfter && userAfter.length > 0) {
          console.log(`\u{1F451} Benutzer-Status nach Update:`, {
            id: userAfter[0].id,
            email: userAfter[0].email,
            subscriptionTier: userAfter[0].subscriptionTier,
            subscriptionBillingCycle: userAfter[0].subscriptionBillingCycle,
            subscriptionExpiresAt: userAfter[0].subscriptionExpiresAt
          });
        }
        try {
          await db.update(subscriptions).set({
            status: "active",
            stripeCustomerId: session2.customer,
            stripeSubscriptionId: session2.subscription,
            billingCycle,
            // Abrechnungszyklus wurde bereits normalisiert
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq11(subscriptions.id, parseInt(finalSubscriptionId || "0")));
          console.log(`Subscription ${finalSubscriptionId} wurde aktiviert f\xFCr Benutzer ${userId}`);
        } catch (dbError) {
          console.error("Fehler bei der Aktualisierung der Subscription:", dbError);
        }
        break;
      }
      case "customer.subscription.deleted": {
        const subscription = event.data.object;
        try {
          const subscriptionInDb = await db.select().from(subscriptions).where(eq11(subscriptions.stripeSubscriptionId, subscription.id)).limit(1);
          if (subscriptionInDb.length > 0) {
            await db.update(subscriptions).set({
              status: "inactive",
              updatedAt: /* @__PURE__ */ new Date()
            }).where(eq11(subscriptions.id, subscriptionInDb[0].id));
            console.log(`Subscription ${subscriptionInDb[0].id} wurde deaktiviert`);
          }
        } catch (dbError) {
          console.error("Fehler bei der Aktualisierung der Subscription:", dbError);
        }
        break;
      }
      // Weitere Event-Typen können hier hinzugefügt werden
      default:
        console.log(`Unbehandeltes Stripe-Event: ${event.type}`);
    }
    return res.status(200).json({ received: true });
  });
  app2.get("/api/payments/success", async (req, res) => {
    const { session_id } = req.query;
    if (!session_id) {
      return res.status(400).json({ message: "Keine Session-ID gefunden" });
    }
    try {
      const dynamicBaseUrl = getDynamicBaseUrl(req);
      console.log(`Payment success API aufgerufen mit session_id: ${session_id}, Base URL: ${dynamicBaseUrl}`);
      const session2 = await stripe2.checkout.sessions.retrieve(session_id);
      const stripeCustomerId = session2.customer;
      const stripeSubscriptionId = session2.subscription;
      console.log(`Stripe Customer ID: ${stripeCustomerId}, Stripe Subscription ID: ${stripeSubscriptionId}`);
      let subscriptionInfo;
      if (stripeSubscriptionId) {
        subscriptionInfo = await db.select().from(subscriptions).where(eq11(subscriptions.stripeSubscriptionId, stripeSubscriptionId)).limit(1);
      }
      if (!subscriptionInfo || subscriptionInfo.length === 0) {
        const clientRefId = session2.client_reference_id;
        if (clientRefId) {
          console.log(`Suche nach Subscription mit Client Reference ID: ${clientRefId}`);
          subscriptionInfo = await db.select().from(subscriptions).where(eq11(subscriptions.id, parseInt(clientRefId))).limit(1);
        }
      }
      if (!subscriptionInfo || subscriptionInfo.length === 0) {
        const subscriptionId = session2.metadata?.subscriptionId;
        if (subscriptionId) {
          console.log(`Suche nach Subscription mit Metadata ID: ${subscriptionId}`);
          subscriptionInfo = await db.select().from(subscriptions).where(eq11(subscriptions.id, parseInt(subscriptionId))).limit(1);
        }
      }
      if (!subscriptionInfo || subscriptionInfo.length === 0) {
        const userId = session2.metadata?.userId;
        if (userId) {
          console.log(`Suche nach Subscription f\xFCr User: ${userId}`);
          subscriptionInfo = await db.select().from(subscriptions).where(eq11(subscriptions.userId, parseInt(userId))).orderBy(desc5(subscriptions.createdAt)).limit(1);
        }
      }
      if (!subscriptionInfo || subscriptionInfo.length === 0) {
        console.error("Keine passende Subscription in der Datenbank gefunden f\xFCr Session:", session2);
        return res.status(404).json({
          message: "Subscription nicht gefunden",
          sessionInfo: {
            id: session2.id,
            clientReferenceId: session2.client_reference_id,
            metadata: session2.metadata,
            customerId: stripeCustomerId,
            subscriptionId: stripeSubscriptionId
          }
        });
      }
      const subscription = subscriptionInfo[0];
      console.log("Gefundene Subscription:", subscription);
      if (subscription && stripeCustomerId && stripeSubscriptionId && (!subscription.stripeCustomerId || !subscription.stripeSubscriptionId)) {
        console.log("Aktualisiere Stripe-IDs in der Subscription");
        try {
          await db.update(subscriptions).set({
            status: "active",
            stripeCustomerId,
            stripeSubscriptionId,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq11(subscriptions.id, subscription.id));
          const updatedSubscription = await db.select().from(subscriptions).where(eq11(subscriptions.id, subscription.id)).limit(1);
          if (updatedSubscription.length > 0) {
            subscription.status = updatedSubscription[0].status;
            subscription.stripeCustomerId = updatedSubscription[0].stripeCustomerId;
            subscription.stripeSubscriptionId = updatedSubscription[0].stripeSubscriptionId;
          }
        } catch (updateError) {
          console.error("Fehler bei der Aktualisierung der Subscription:", updateError);
        }
      }
      return res.status(200).json({
        success: true,
        message: "Zahlung erfolgreich",
        subscription
      });
    } catch (error) {
      console.error("Fehler beim Abrufen der Session-Informationen:", error);
      return res.status(500).json({
        message: "Fehler beim Verarbeiten der erfolgreichen Zahlung",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });
  app2.get("/api/payments/cancel", (req, res) => {
    return res.status(200).json({
      success: false,
      message: "Zahlung abgebrochen"
    });
  });
  app2.post("/api/payments/direct-update", async (req, res) => {
    try {
      const { userId, packageId, billingCycle = "monthly", sessionId, forceDowngrade = false } = req.body;
      const normalizedBillingCycle = billingCycle && String(billingCycle).toLowerCase() === "yearly" ? "yearly" : "monthly";
      console.log(`\u{1F504} DIREKTE AKTUALISIERUNG: Benutzer ${userId}, Paket ${packageId}, `);
      console.log(`   Original Zyklus=${billingCycle} (Typ: ${typeof billingCycle}), Normalisiert=${normalizedBillingCycle}, forceDowngrade=${forceDowngrade}`);
      if (!userId || !packageId) {
        return res.status(400).json({ success: false, message: "Fehlende Benutzer- oder Paket-ID" });
      }
      const userBefore = await db.select().from(users).where(eq11(users.id, userId)).limit(1);
      if (!userBefore || userBefore.length === 0) {
        return res.status(404).json({ success: false, message: "Benutzer nicht gefunden" });
      }
      console.log(`\u{1F464} Aktueller Benutzer-Status vor Update:`, {
        id: userBefore[0].id,
        email: userBefore[0].email,
        subscriptionTier: userBefore[0].subscriptionTier,
        subscriptionBillingCycle: userBefore[0].subscriptionBillingCycle,
        subscriptionExpiresAt: userBefore[0].subscriptionExpiresAt
      });
      const packageInfo = await db.select().from(subscriptionPackages).where(eq11(subscriptionPackages.id, packageId)).limit(1);
      if (!packageInfo || packageInfo.length === 0) {
        return res.status(404).json({ success: false, message: "Paket nicht gefunden" });
      }
      const packageTier = packageInfo[0].name.toLowerCase();
      console.log(`\u{1F53C} Setze Subscription-Tier des Benutzers ${userId} auf: ${packageTier} mit Billing-Zyklus: ${normalizedBillingCycle}`);
      const currentTier = userBefore[0].subscriptionTier?.toLowerCase() || "free";
      const currentTierRank = getTierRank(currentTier);
      const newTierRank = getTierRank(packageTier);
      const isDowngrade = newTierRank < currentTierRank;
      console.log(`Tier-Vergleich: ${currentTier}(${currentTierRank}) -> ${packageTier}(${newTierRank}), isDowngrade=${isDowngrade}, forceDowngrade=${forceDowngrade}`);
      console.log(`Billing-Zyklus: ${userBefore[0].subscriptionBillingCycle || "nicht gesetzt"} -> ${normalizedBillingCycle}`);
      if (isDowngrade && !forceDowngrade) {
        console.log(`\u26A0\uFE0F WARNUNG: Downgrade von ${currentTier} auf ${packageTier} ohne forceDowngrade-Flag abgelehnt`);
        return res.status(403).json({
          success: false,
          message: "Downgrade nicht erlaubt ohne forceDowngrade=true"
        });
      }
      const expirationPeriod = normalizedBillingCycle === "yearly" ? 365 * 24 * 60 * 60 * 1e3 : 30 * 24 * 60 * 60 * 1e3;
      console.log(`\u26A1 WICHTIG: Setze subscriptionBillingCycle auf: "${normalizedBillingCycle}" f\xFCr User ${userId}`);
      const userUpdateResult = await db.update(users).set({
        isActive: true,
        subscriptionTier: packageTier,
        subscriptionBillingCycle: normalizedBillingCycle,
        // Verwende den normalisierten Wert!
        subscriptionExpiresAt: new Date(Date.now() + expirationPeriod),
        updatedAt: /* @__PURE__ */ new Date()
        // Stelle sicher, dass updatedAt auch aktualisiert wird
      }).where(eq11(users.id, userId)).returning();
      console.log(`\u2705 Benutzer ${userId} aktualisiert:`, userUpdateResult);
      const userAfter = await db.select().from(users).where(eq11(users.id, userId)).limit(1);
      let subscriptionEntry;
      const existingSubscription = await db.select().from(subscriptions).where(eq11(subscriptions.userId, userId)).orderBy(desc5(subscriptions.createdAt)).limit(1);
      console.log(`Subscription f\xFCr User ${userId} \xFCberpr\xFCfen...`);
      if (existingSubscription && existingSubscription.length > 0) {
        console.log(`Bestehende Subscription gefunden: ID=${existingSubscription[0].id}, billingCycle=${existingSubscription[0].billingCycle}`);
        subscriptionEntry = await db.update(subscriptions).set({
          packageId,
          status: "active",
          billingCycle: normalizedBillingCycle,
          // Verwende den normalisierten Wert!
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq11(subscriptions.id, existingSubscription[0].id)).returning();
        console.log(`\u2705 Bestehende Subscription ${existingSubscription[0].id} aktualisiert mit billingCycle=${normalizedBillingCycle}`);
      } else {
        console.log(`Keine bestehende Subscription f\xFCr User ${userId} gefunden, erstelle neu`);
        subscriptionEntry = await db.insert(subscriptions).values({
          userId,
          packageId,
          status: "active",
          billingCycle: normalizedBillingCycle,
          // Verwende den normalisierten Wert!
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).returning();
        console.log(`\u2705 Neue Subscription erstellt f\xFCr Benutzer ${userId} mit billingCycle=${normalizedBillingCycle}`);
      }
      const updatedSubscription = await db.select().from(subscriptions).where(eq11(subscriptions.userId, userId)).orderBy(desc5(subscriptions.createdAt)).limit(1);
      console.log(`\u{1F50D} FINAL CHECK - Subscription nach Update:`, {
        id: updatedSubscription[0]?.id,
        userId: updatedSubscription[0]?.userId,
        packageId: updatedSubscription[0]?.packageId,
        billingCycle: updatedSubscription[0]?.billingCycle,
        status: updatedSubscription[0]?.status
      });
      console.log(`\u{1F50D} FINAL CHECK - User nach Update:`, {
        id: userAfter[0]?.id,
        subscriptionTier: userAfter[0]?.subscriptionTier,
        subscriptionBillingCycle: userAfter[0]?.subscriptionBillingCycle
      });
      return res.status(200).json({
        success: true,
        message: "Benutzerabonnement erfolgreich aktualisiert",
        updatedUser: userAfter.length > 0 ? {
          id: userAfter[0].id,
          email: userAfter[0].email,
          subscriptionTier: userAfter[0].subscriptionTier,
          subscriptionBillingCycle: userAfter[0].subscriptionBillingCycle,
          subscriptionExpiresAt: userAfter[0].subscriptionExpiresAt
        } : null,
        subscriptionEntry: updatedSubscription[0] || subscriptionEntry,
        billingCycle: normalizedBillingCycle
        // Explizit auch im Response zurückgeben
      });
    } catch (error) {
      console.error("\u274C Fehler bei der direkten Aktualisierung:", error);
      return res.status(500).json({
        success: false,
        message: "Fehler bei der Aktualisierung des Benutzerabonnements",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });
}

// server/limitRoutes.ts
init_db();
init_auth();
import { sql as sql8 } from "drizzle-orm";
import { eq as eq12 } from "drizzle-orm/expressions";
function setupLimitRoutes(app2) {
  app2.get("/api/limits/task-creation", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      if (!userId) {
        return res.status(401).json({
          message: "Nicht autorisiert. Bitte melden Sie sich an."
        });
      }
      const user = await db.query.users.findFirst({
        where: (users2) => eq12(users2.id, userId)
      });
      if (!user) {
        return res.status(404).json({
          message: "Benutzer nicht gefunden."
        });
      }
      const paymentInfo = await db.query.companyPaymentInfo.findFirst({
        where: (cp) => eq12(cp.companyId, user.companyId || -1)
      });
      const subscriptionTier = paymentInfo?.subscriptionTier || "free";
      const packageLimits = await db.query.subscriptionPackages.findFirst({
        where: (sp) => eq12(sp.name, subscriptionTier)
      });
      const maxTasks = packageLimits?.maxTasks || 10;
      const taskCountResult = await db.execute(
        sql8`SELECT COUNT(*) as count FROM tasks WHERE ${userId} = ANY(assigned_user_ids)`
      );
      const currentCount = parseInt(String(taskCountResult.rows[0]?.count) || "0");
      let limitReached = false;
      if (maxTasks < 999999) {
        limitReached = currentCount >= maxTasks;
      }
      console.log(`Sending task limit response for user ${userId}: `, {
        limitReached,
        currentCount,
        maxCount: maxTasks,
        plan: subscriptionTier
      });
      return res.json({
        limitReached,
        currentPlan: subscriptionTier,
        currentCount,
        maxCount: maxTasks,
        nextTier: limitReached ? getNextTier(subscriptionTier) : null
      });
    } catch (error) {
      console.error("Fehler bei der Limit-Pr\xFCfung f\xFCr Aufgaben:", error);
      return res.status(500).json({
        message: "Bei der Pr\xFCfung des Limits ist ein Fehler aufgetreten."
      });
    }
  });
}
function getNextTier(currentTier) {
  switch (currentTier.toLowerCase()) {
    case "free":
      return "freelancer";
    case "freelancer":
      return "organisation";
    case "organisation":
      return "enterprise";
    default:
      return "enterprise";
  }
}

// server/dataExportRoutes.ts
init_db();
init_auth();
function registerDataExportRoutes(app2) {
  app2.get("/api/data-export/personal", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      const format = req.query.format || "json";
      console.log(`[DATA_EXPORT] Starting personal data export for user ${userId} in format ${format}`);
      const exportData = await collectPersonalData(userId);
      if (format === "csv") {
        const csvData = await generateCSVExport(exportData);
        res.setHeader("Content-Type", "text/csv");
        res.setHeader("Content-Disposition", `attachment; filename="personal_data_export_${userId}_${Date.now()}.csv"`);
        return res.send(csvData);
      }
      if (format === "json") {
        res.setHeader("Content-Type", "application/json");
        res.setHeader("Content-Disposition", `attachment; filename="personal_data_export_${userId}_${Date.now()}.json"`);
        return res.json(exportData);
      }
      return res.status(400).json({ message: "Unsupported format. Use json or csv" });
    } catch (error) {
      console.error("[DATA_EXPORT] Error exporting personal data:", error);
      res.status(500).json({ message: "Fehler beim Exportieren der pers\xF6nlichen Daten" });
    }
  });
  app2.get("/api/data-export/company", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      const format = req.query.format || "json";
      const userResult = await pool.query(`
        SELECT company_id, is_company_admin FROM users WHERE id = $1
      `, [userId]);
      if (userResult.rows.length === 0) {
        return res.status(404).json({ message: "Benutzer nicht gefunden" });
      }
      const user = userResult.rows[0];
      if (!user.is_company_admin || !user.company_id) {
        return res.status(403).json({ message: "Nur Firmen-Administratoren k\xF6nnen Firmendaten exportieren" });
      }
      console.log(`[DATA_EXPORT] Starting company data export for company ${user.company_id} by admin ${userId}`);
      const exportData = await collectCompanyData(user.company_id, userId);
      if (format === "csv") {
        const csvData = await generateCSVExport(exportData);
        res.setHeader("Content-Type", "text/csv");
        res.setHeader("Content-Disposition", `attachment; filename="company_data_export_${user.company_id}_${Date.now()}.csv"`);
        return res.send(csvData);
      }
      if (format === "json") {
        res.setHeader("Content-Type", "application/json");
        res.setHeader("Content-Disposition", `attachment; filename="company_data_export_${user.company_id}_${Date.now()}.json"`);
        return res.json(exportData);
      }
      return res.status(400).json({ message: "Unsupported format. Use json or csv" });
    } catch (error) {
      console.error("[DATA_EXPORT] Error exporting company data:", error);
      res.status(500).json({ message: "Fehler beim Exportieren der Firmendaten" });
    }
  });
  app2.get("/api/data-export/info", requireAuth, async (req, res) => {
    try {
      const userId = req.userId;
      const userResult = await pool.query(`
        SELECT id, username, email, company_id, is_company_admin FROM users WHERE id = $1
      `, [userId]);
      if (userResult.rows.length === 0) {
        return res.status(404).json({ message: "Benutzer nicht gefunden" });
      }
      const user = userResult.rows[0];
      const exportInfo = {
        availableExports: {
          personal: true,
          company: user.is_company_admin && user.company_id ? true : false
        },
        supportedFormats: ["json", "csv"],
        user: {
          id: user.id,
          username: user.username,
          email: user.email,
          hasCompany: !!user.company_id,
          isCompanyAdmin: user.is_company_admin
        },
        gdprCompliant: true,
        lastExportDate: null
        // TODO: Implementiere Export-Historie
      };
      res.json(exportInfo);
    } catch (error) {
      console.error("[DATA_EXPORT] Error getting export info:", error);
      res.status(500).json({ message: "Fehler beim Abrufen der Export-Informationen" });
    }
  });
}
async function collectPersonalData(userId) {
  console.log(`[DATA_EXPORT] Collecting personal data for user ${userId}`);
  try {
    const userResult = await pool.query(`
      SELECT id, username, email, created_at, updated_at, 
             company_id, is_company_admin, subscription_tier
      FROM users WHERE id = $1
    `, [userId]);
    if (userResult.rows.length === 0) {
      throw new Error("Benutzer nicht gefunden");
    }
    const user = userResult.rows[0];
    let tasksData = [];
    try {
      const tasksResult = await pool.query(`
        SELECT id, title, description, status, "createdAt", "updatedAt", board_id
        FROM tasks 
        WHERE $1 = ANY(assigned_user_ids)
        ORDER BY "createdAt" DESC
      `, [userId]);
      tasksData = tasksResult.rows;
    } catch (error) {
      console.log(`[DATA_EXPORT] Tasks query failed:`, error);
    }
    let boardsData = [];
    try {
      const boardsResult = await pool.query(`
        SELECT id, title, description, "createdAt", project_id
        FROM boards 
        WHERE creator_id = $1 OR $1 = ANY(assigned_user_ids)
        ORDER BY "createdAt" DESC
      `, [userId]);
      boardsData = boardsResult.rows;
    } catch (error) {
      console.log(`[DATA_EXPORT] Boards query failed:`, error);
    }
    let projectsData = [];
    try {
      const projectsResult = await pool.query(`
        SELECT id, title, description, "createdAt", creator_id
        FROM projects 
        WHERE creator_id = $1 OR $1 = ANY(assigned_user_ids)
        ORDER BY "createdAt" DESC
      `, [userId]);
      projectsData = projectsResult.rows;
    } catch (error) {
      console.log(`[DATA_EXPORT] Projects query failed:`, error);
    }
    let objectivesData = [];
    try {
      const objectivesResult = await pool.query(`
        SELECT id, title, description, progress, "createdAt", "updatedAt"
        FROM objectives 
        WHERE creator_id = $1 OR $1 = ANY(assigned_user_ids)
        ORDER BY "createdAt" DESC
      `, [userId]);
      objectivesData = objectivesResult.rows;
    } catch (error) {
      console.log(`[DATA_EXPORT] Objectives query failed:`, error);
    }
    let keyResultsData = [];
    try {
      const keyResultsResult = await pool.query(`
        SELECT id, title, description, progress, target_value, "createdAt", "updatedAt", objective_id
        FROM key_results 
        WHERE creator_id = $1 OR $1 = ANY(assigned_user_ids)
        ORDER BY "createdAt" DESC
      `, [userId]);
      keyResultsData = keyResultsResult.rows;
    } catch (error) {
      console.log(`[DATA_EXPORT] Key Results query failed:`, error);
    }
    let teamsData = [];
    try {
      const teamsResult = await pool.query(`
        SELECT t.id, t.name, t.description, t."createdAt"
        FROM teams t
        JOIN team_members tm ON t.id = tm.team_id
        WHERE tm.user_id = $1
        ORDER BY t."createdAt" DESC
      `, [userId]);
      teamsData = teamsResult.rows;
    } catch (error) {
      console.log(`[DATA_EXPORT] Teams query failed:`, error);
    }
    let commentsData = [];
    try {
      const commentsResult = await pool.query(`
        SELECT id, content, "createdAt", task_id
        FROM comments 
        WHERE "userId" = $1
        ORDER BY "createdAt" DESC
      `, [userId]);
      commentsData = commentsResult.rows;
    } catch (error) {
      console.log(`[DATA_EXPORT] Comments query failed:`, error);
    }
    let activityData = [];
    try {
      const activityResult = await pool.query(`
        SELECT id, action, details, "createdAt"
        FROM activity_logs 
        WHERE "userId" = $1
        ORDER BY "createdAt" DESC
        LIMIT 1000
      `, [userId]);
      activityData = activityResult.rows;
    } catch (error) {
      console.log(`[DATA_EXPORT] Activity query failed:`, error);
    }
    let companyData = null;
    if (user.company_id) {
      try {
        const companyResult = await pool.query(`
          SELECT id, name, description, created_at FROM companies WHERE id = $1
        `, [user.company_id]);
        companyData = companyResult.rows[0] || null;
      } catch (error) {
        console.log(`[DATA_EXPORT] Company query failed:`, error);
      }
    }
    return {
      user,
      profile: null,
      projects: projectsData,
      boards: boardsData,
      tasks: tasksData,
      comments: commentsData,
      activityLogs: activityData,
      teams: teamsData,
      objectives: objectivesData,
      keyResults: keyResultsData,
      company: companyData,
      exportMetadata: {
        exportDate: (/* @__PURE__ */ new Date()).toISOString(),
        exportType: "personal",
        requestedBy: user.username,
        version: "2.0"
      }
    };
  } catch (error) {
    console.error(`[DATA_EXPORT] Error in collectPersonalData:`, error);
    throw error;
  }
}
async function collectCompanyData(companyId, adminUserId) {
  console.log(`[DATA_EXPORT] Collecting company data for company ${companyId}`);
  try {
    const usersResult = await pool.query(`
      SELECT id, username, email, created_at, is_company_admin, subscription_tier
      FROM users WHERE company_id = $1
    `, [companyId]);
    const companyResult = await pool.query(`
      SELECT id, name, description, created_at FROM companies WHERE id = $1
    `, [companyId]);
    const adminResult = await pool.query(`
      SELECT username FROM users WHERE id = $1
    `, [adminUserId]);
    return {
      user: usersResult.rows,
      profile: null,
      projects: [],
      // Kann später erweitert werden
      boards: [],
      // Kann später erweitert werden
      tasks: [],
      // Kann später erweitert werden
      comments: [],
      activityLogs: [],
      teams: [],
      objectives: [],
      keyResults: [],
      company: companyResult.rows[0],
      exportMetadata: {
        exportDate: (/* @__PURE__ */ new Date()).toISOString(),
        exportType: "company",
        requestedBy: adminResult.rows[0]?.username || "Unknown",
        version: "1.0"
      }
    };
  } catch (error) {
    console.error(`[DATA_EXPORT] Error in collectCompanyData:`, error);
    throw error;
  }
}
async function generateCSVExport(data) {
  const csvLines = [];
  csvLines.push("DSGVO-KONFORMER DATENEXPORT");
  csvLines.push(`Export-Datum: ${data.exportMetadata.exportDate}`);
  csvLines.push(`Export-Typ: ${data.exportMetadata.exportType}`);
  csvLines.push(`Angefordert von: ${data.exportMetadata.requestedBy}`);
  csvLines.push("");
  if (data.user) {
    csvLines.push("=== BENUTZERDATEN ===");
    const user = Array.isArray(data.user) ? data.user[0] : data.user;
    if (user) {
      csvLines.push(`ID,Username,E-Mail,Erstellt am`);
      csvLines.push(`${user.id},"${user.username}","${user.email}","${user.created_at}"`);
    }
    csvLines.push("");
  }
  if (data.projects && data.projects.length > 0) {
    csvLines.push("=== PROJEKTE ===");
    csvLines.push("ID,Titel,Beschreibung,Erstellt am");
    data.projects.forEach((project) => {
      csvLines.push(`${project.id},"${project.title || ""}","${project.description || ""}","${project.created_at}"`);
    });
    csvLines.push("");
  }
  if (data.tasks && data.tasks.length > 0) {
    csvLines.push("=== AUFGABEN ===");
    csvLines.push("ID,Titel,Beschreibung,Status,Erstellt am");
    data.tasks.forEach((task) => {
      csvLines.push(`${task.id},"${task.title || ""}","${task.description || ""}","${task.status || ""}","${task.created_at}"`);
    });
    csvLines.push("");
  }
  return csvLines.join("\n");
}

// server/simple-api-routes.ts
import crypto2 from "crypto";
var apiKeys = /* @__PURE__ */ new Map();
function generateAPIKey() {
  return `sk_${crypto2.randomBytes(32).toString("hex")}`;
}
function registerSimpleAPIRoutes(app2) {
  app2.post("/api/keys", async (req, res) => {
    try {
      const { name, permissions = ["read"] } = req.body;
      if (!name) {
        return res.status(400).json({ error: "Key name is required" });
      }
      const userId = req.session?.userId;
      if (!userId) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const apiKey = {
        id: crypto2.randomUUID(),
        name,
        key: generateAPIKey(),
        userId,
        permissions,
        createdAt: /* @__PURE__ */ new Date(),
        isActive: true
      };
      apiKeys.set(apiKey.key, apiKey);
      res.json({
        id: apiKey.id,
        name: apiKey.name,
        key: apiKey.key,
        permissions: apiKey.permissions,
        createdAt: apiKey.createdAt.toISOString(),
        isActive: apiKey.isActive
      });
    } catch (error) {
      console.error("Error creating API key:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.get("/api/keys", async (req, res) => {
    try {
      const userId = req.session?.userId;
      if (!userId) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const userKeys = [];
      for (const key of apiKeys.values()) {
        if (key.userId === userId) {
          userKeys.push(key);
        }
      }
      const result = userKeys.map((key) => ({
        id: key.id,
        name: key.name,
        permissions: key.permissions,
        createdAt: key.createdAt.toISOString(),
        lastUsed: key.lastUsed?.toISOString(),
        isActive: key.isActive
      }));
      res.json(userKeys);
    } catch (error) {
      console.error("Error fetching API keys:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.delete("/api/keys/:keyId", async (req, res) => {
    try {
      const { keyId } = req.params;
      const userId = req.session?.userId;
      if (!userId) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      let keyToDelete;
      let keyToken;
      for (const [token, key] of apiKeys.entries()) {
        if (key.id === keyId && key.userId === userId) {
          keyToDelete = key;
          keyToken = token;
          break;
        }
      }
      if (!keyToDelete || !keyToken) {
        return res.status(404).json({ error: "API key not found" });
      }
      apiKeys.delete(keyToken);
      res.json({ message: "API key deleted successfully" });
    } catch (error) {
      console.error("Error deleting API key:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.get("/api/docs", (req, res) => {
    const docs = {
      title: "SuperOrga REST API",
      version: "1.0.0",
      description: "REST API f\xFCr Drittanbieter-Integrationen",
      baseUrl: `${req.protocol}://${req.get("host")}/api/v1`,
      authentication: {
        type: "Bearer Token",
        header: "Authorization: Bearer YOUR_API_KEY"
      },
      endpoints: {
        "GET /user": "Aktuelle Benutzerinformationen abrufen",
        "GET /projects": "Alle zug\xE4nglichen Projekte auflisten",
        "POST /projects": "Neues Projekt erstellen",
        "GET /boards": "Alle zug\xE4nglichen Boards auflisten",
        "POST /boards": "Neues Board erstellen",
        "GET /tasks": "Alle zug\xE4nglichen Aufgaben auflisten",
        "POST /tasks": "Neue Aufgabe erstellen"
      },
      examples: {
        "Benutzer abrufen": `curl -H "Authorization: Bearer YOUR_API_KEY" ${req.protocol}://${req.get("host")}/api/v1/user`,
        "Projekt erstellen": `curl -X POST -H "Authorization: Bearer YOUR_API_KEY" -H "Content-Type: application/json" -d '{"title":"Mein Projekt","description":"Beschreibung"}' ${req.protocol}://${req.get("host")}/api/v1/projects`
      }
    };
    res.json(docs);
  });
}

// server/index.ts
var app = express2();
app.use(cors({
  origin: true,
  credentials: true,
  methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization"]
}));
app.use(express2.json());
app.use(express2.urlencoded({ extended: false }));
var MemoryStoreSession = MemoryStore(session);
app.use(session({
  secret: process.env.SESSION_SECRET || "your-secret-key",
  resave: false,
  saveUninitialized: false,
  store: new MemoryStoreSession({
    checkPeriod: 864e5
    // Prüfe Ablauf jeden Tag
  }),
  cookie: {
    secure: false,
    // Set to true only in production with HTTPS
    httpOnly: true,
    maxAge: 24 * 60 * 60 * 1e3,
    // 24 Stunden
    sameSite: "lax"
  }
}));
var db4 = knex({
  client: "pg",
  connection: process.env.DATABASE_URL
});
app.use("/uploads", express2.static(path5.join(process.cwd(), "uploads")));
app.use(express2.static(path5.join(process.cwd(), "public")));
app.get("/payment/success", (req, res) => {
  const sessionId = req.query.session_id;
  if (!sessionId) {
    return res.redirect("/auth");
  }
  res.sendFile(path5.join(process.cwd(), "public", "payment-success.html"));
});
app.get("/payment-success.html", (req, res) => {
  res.sendFile(path5.join(process.cwd(), "public", "payment-success.html"));
});
app.get("/health", (_req, res) => {
  res.json({ status: "healthy" });
});
app.use((req, res, next) => {
  const start = Date.now();
  const path6 = req.path;
  let capturedJsonResponse = void 0;
  console.log(`[${(/* @__PURE__ */ new Date()).toISOString()}] Incoming ${req.method} request for ${req.url}`);
  if (req.session) {
    console.log(`Session data:`, {
      userId: req.session.userId,
      isNew: req.session && "isNew" in req.session ? req.session.isNew : void 0
    });
  }
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path6.startsWith("/api") || path6 === "/health") {
      let logLine = `${req.method} ${path6} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  try {
    log("Starting server initialization...");
    const server = createServer(app);
    await registerRoutes(app, db4);
    log("Routes registered successfully");
    registerProtocolRoutes(app);
    log("Protocol routes registered successfully");
    registerSimpleAPIRoutes(app);
    log("REST API routes registered successfully");
    setupAdminRoutes(app, db4);
    log("Admin routes registered successfully");
    registerSubscriptionRoutes(app);
    log("Subscription routes registered successfully");
    registerPaymentRoutes(app);
    log("Payment routes registered successfully");
    await initializeSubscriptionPackages();
    log("Subscription packages initialized successfully");
    setupLimitRoutes(app);
    registerDataExportRoutes(app);
    log("Data export routes registered successfully");
    app.get("/api/auth/current-user", optionalAuth, async (req, res) => {
      try {
        if (!req.userId) {
          return res.json(null);
        }
        const user = await storage.getUser(req.userId, req.userId);
        const { passwordHash: _, ...userWithoutPassword } = user;
        res.json(userWithoutPassword);
      } catch (error) {
        console.error("Error fetching current user:", error);
        res.status(500).json({ message: "Fehler beim Abrufen des aktuellen Benutzers" });
      }
    });
    app.get("*", (req, res, next) => {
      if (req.url.startsWith("/api")) {
        next();
        return;
      }
      console.log(`[${(/* @__PURE__ */ new Date()).toISOString()}] Serving client app for route: ${req.url}`);
      if (process.env.NODE_ENV === "development") {
        next();
      } else {
        res.sendFile(path5.join(process.cwd(), "dist", "client", "index.html"));
      }
    });
    app.use((err, _req, res, _next) => {
      const status = err.status || err.statusCode || 500;
      const message = err.message || "Internal Server Error";
      res.status(status).json({ message });
      console.error("Server error:", err);
    });
    process.env.NODE_ENV = "development";
    log("\u{1F680} SERVER STARTUP: Minimale Konfiguration f\xFCr schnellen Start...");
    const startServer = async (initialPort = 3001) => {
      const host = "0.0.0.0";
      let port = initialPort;
      const maxPortAttempts = 10;
      for (let attempt = 0; attempt < maxPortAttempts; attempt++) {
        try {
          log(`EINFACHER ANSATZ: Starte Server auf Port ${port}... (Versuch ${attempt + 1})`);
          log(`Starte Hauptserver auf Port ${port}...`);
          await new Promise((resolve, reject) => {
            server.once("error", (err) => {
              if (err.code === "EADDRINUSE") {
                log(`\u26A0\uFE0F Port ${port} ist bereits belegt, versuche Port ${port + 1}`);
                port++;
                reject(new Error(`Port ${port - 1} ist bereits belegt`));
              } else {
                reject(err);
              }
            });
            server.listen(port, host, () => {
              log(`\u2705 HAUPT-SERVER gestartet auf ${host}:${port}`);
              log(`App aufrufen: https://${process.env.REPL_ID}.id.replit.app/`);
              console.log(`PORT INFO - Server l\xE4uft auf: ${host}:${port}`);
              console.log(`IMPORTANT: Server now running on port ${port}`);
              resolve();
            });
          });
          return;
        } catch (error) {
          log(`Port-Bindungsversuch fehlgeschlagen: ${error instanceof Error ? error.message : String(error)}`);
          if (attempt === maxPortAttempts - 1) {
            throw new Error(`Konnte keinen freien Port zwischen ${initialPort} und ${port} finden`);
          }
        }
      }
    };
    log(`Starting server on port 5000 for Replit workflow detection`);
    await startServer(5e3);
    log("Server ist gestartet, initialisiere Vite direkt...");
    try {
      log("Vite wird jetzt initialisiert...");
      if (process.env.NODE_ENV === "development") {
        await setupVite(app, server);
        log("Vite-Setup abgeschlossen - HMR-Verbindung sollte jetzt stabil sein");
      }
      log("Benachrichtigungsdienst wird erst nach 30 Sekunden initialisiert, um den Server-Start zu beschleunigen");
      setTimeout(() => {
        log("Delayed: Benachrichtigungsdienst wird jetzt initialisiert...");
        notificationService.processAllPendingActivityLogs().then(() => log("Benachrichtigungsdienst Initialisierung abgeschlossen")).catch((err) => console.error("Fehler bei der Initialisierung des Benachrichtigungsdienstes:", err));
        setTimeout(() => {
          setInterval(async () => {
            try {
              await notificationService.processAllPendingActivityLogs();
            } catch (error) {
              console.error("Fehler bei der Verarbeitung ausstehender Benachrichtigungen:", error);
            }
          }, 12e4);
        }, 6e4);
      }, 3e4);
    } catch (error) {
      console.error("Fehler beim Setup von Vite:", error);
    }
  } catch (error) {
    console.error("Failed to start server:", error);
    process.exit(1);
  }
})();
console.log("DEBUG: Checking Board Limit on server side...");